/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const RTE_EXEC_ENV: &'static [u8; 9usize] = b"linuxapp\x00";
pub const RTE_ARCH: &'static [u8; 7usize] = b"x86_64\x00";
pub const RTE_MACHINE: &'static [u8; 7usize] = b"native\x00";
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\x00";
pub const RTE_NEXT_ABI: ::std::os::raw::c_uint = 1;
pub const RTE_CACHE_LINE_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_LIBRTE_EAL: ::std::os::raw::c_uint = 1;
pub const RTE_MAX_LCORE: ::std::os::raw::c_uint = 128;
pub const RTE_MAX_NUMA_NODES: ::std::os::raw::c_uint = 8;
pub const RTE_MAX_MEMSEG: ::std::os::raw::c_uint = 256;
pub const RTE_MAX_MEMZONE: ::std::os::raw::c_uint = 2560;
pub const RTE_MAX_TAILQ: ::std::os::raw::c_uint = 32;
pub const RTE_LOG_HISTORY: ::std::os::raw::c_uint = 256;
pub const RTE_EAL_IGB_UIO: ::std::os::raw::c_uint = 1;
pub const RTE_EAL_VFIO: ::std::os::raw::c_uint = 1;
pub const RTE_EAL_PMD_PATH: &'static [u8; 1usize] = b"\x00";
pub const RTE_LIBRTE_EAL_VMWARE_TSC_MAP_SUPPORT: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_KVARGS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ETHER: ::std::os::raw::c_uint = 1;
pub const RTE_MAX_ETHPORTS: ::std::os::raw::c_uint = 32;
pub const RTE_MAX_QUEUES_PER_PORT: ::std::os::raw::c_uint = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: ::std::os::raw::c_uint = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ENA_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_EM_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IGB_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IXGBE_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_IXGBE_INC_VECTOR: ::std::os::raw::c_uint = 1;
pub const RTE_IXGBE_RX_OLFLAGS_ENABLE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_RX_OLFLAGS_ENABLE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: ::std::os::raw::c_uint = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_I40E_ITR_INTERVAL: ::std::os::raw::c_int = -1;
pub const RTE_LIBRTE_FM10K_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_MLX4_SGE_WR_N: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_MLX4_MAX_INLINE: ::std::os::raw::c_uint = 0;
pub const RTE_LIBRTE_MLX4_TX_MP_CACHE: ::std::os::raw::c_uint = 8;
pub const RTE_LIBRTE_MLX4_SOFT_COUNTERS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_MLX5_TX_MP_CACHE: ::std::os::raw::c_uint = 8;
pub const RTE_LIBRTE_CXGBE_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ENIC_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_BNXT_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_SZEDATA2_AS: ::std::os::raw::c_uint = 0;
pub const RTE_LIBRTE_VIRTIO_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_VIRTIO_USER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_RING: ::std::os::raw::c_uint = 1;
pub const RTE_PMD_RING_MAX_RX_RINGS: ::std::os::raw::c_uint = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: ::std::os::raw::c_uint = 16;
pub const RTE_LIBRTE_PMD_BOND: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_QEDE_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\x00";
pub const RTE_LIBRTE_PMD_AF_PACKET: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_NULL: ::std::os::raw::c_uint = 1;
pub const RTE_PMD_PACKET_PREFETCH: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_CRYPTODEV: ::std::os::raw::c_uint = 1;
pub const RTE_CRYPTO_MAX_DEVS: ::std::os::raw::c_uint = 64;
pub const RTE_CRYPTODEV_NAME_LEN: ::std::os::raw::c_uint = 64;
pub const RTE_QAT_PMD_MAX_NB_SESSIONS: ::std::os::raw::c_uint = 2048;
pub const RTE_LIBRTE_PMD_NULL_CRYPTO: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_RING: ::std::os::raw::c_uint = 1;
pub const RTE_RING_PAUSE_REP_COUNT: ::std::os::raw::c_uint = 0;
pub const RTE_LIBRTE_MEMPOOL: ::std::os::raw::c_uint = 1;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: ::std::os::raw::c_uint = 512;
pub const RTE_LIBRTE_MBUF: ::std::os::raw::c_uint = 1;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] =
    b"ring_mp_mc\x00";
pub const RTE_MBUF_REFCNT_ATOMIC: ::std::os::raw::c_uint = 1;
pub const RTE_PKTMBUF_HEADROOM: ::std::os::raw::c_uint = 128;
pub const RTE_LIBRTE_TIMER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_CFGFILE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_CMDLINE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_HASH: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_JOBSTATS: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_LPM: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_ACL: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_POWER: ::std::os::raw::c_uint = 1;
pub const RTE_MAX_LCORE_FREQS: ::std::os::raw::c_uint = 64;
pub const RTE_LIBRTE_NET: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IP_FRAG: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: ::std::os::raw::c_uint = 4;
pub const RTE_LIBRTE_METER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_SCHED: ::std::os::raw::c_uint = 1;
pub const RTE_SCHED_PORT_N_GRINDERS: ::std::os::raw::c_uint = 8;
pub const RTE_LIBRTE_DISTRIBUTOR: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_REORDER: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PORT: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_TABLE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PIPELINE: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_KNI: ::std::os::raw::c_uint = 1;
pub const RTE_KNI_KMOD: ::std::os::raw::c_uint = 1;
pub const RTE_KNI_PREEMPT_DEFAULT: ::std::os::raw::c_uint = 1;
pub const RTE_KNI_VHOST_MAX_CACHE_SIZE: ::std::os::raw::c_uint = 1024;
pub const RTE_LIBRTE_PDUMP: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_VHOST: ::std::os::raw::c_uint = 1;
pub const RTE_LIBRTE_PMD_VHOST: ::std::os::raw::c_uint = 1;
pub const RTE_APP_TEST: ::std::os::raw::c_uint = 1;
pub const RTE_TEST_PMD: ::std::os::raw::c_uint = 1;
pub const RTE_EXEC_ENV_LINUXAPP: ::std::os::raw::c_uint = 1;
pub const RTE_ARCH_X86_64: ::std::os::raw::c_uint = 1;
pub const RTE_ARCH_X86: ::std::os::raw::c_uint = 1;
pub const RTE_ARCH_64: ::std::os::raw::c_uint = 1;
pub const RTE_TOOLCHAIN_GCC: ::std::os::raw::c_uint = 1;
pub const RTE_BIG_ENDIAN: ::std::os::raw::c_uint = 1;
pub const RTE_LITTLE_ENDIAN: ::std::os::raw::c_uint = 2;
pub const RTE_BYTE_ORDER: ::std::os::raw::c_uint = 2;
pub const RTE_LOGTYPE_EAL: ::std::os::raw::c_uint = 1;
pub const RTE_LOGTYPE_MALLOC: ::std::os::raw::c_uint = 2;
pub const RTE_LOGTYPE_RING: ::std::os::raw::c_uint = 4;
pub const RTE_LOGTYPE_MEMPOOL: ::std::os::raw::c_uint = 8;
pub const RTE_LOGTYPE_TIMER: ::std::os::raw::c_uint = 16;
pub const RTE_LOGTYPE_PMD: ::std::os::raw::c_uint = 32;
pub const RTE_LOGTYPE_HASH: ::std::os::raw::c_uint = 64;
pub const RTE_LOGTYPE_LPM: ::std::os::raw::c_uint = 128;
pub const RTE_LOGTYPE_KNI: ::std::os::raw::c_uint = 256;
pub const RTE_LOGTYPE_ACL: ::std::os::raw::c_uint = 512;
pub const RTE_LOGTYPE_POWER: ::std::os::raw::c_uint = 1024;
pub const RTE_LOGTYPE_METER: ::std::os::raw::c_uint = 2048;
pub const RTE_LOGTYPE_SCHED: ::std::os::raw::c_uint = 4096;
pub const RTE_LOGTYPE_PORT: ::std::os::raw::c_uint = 8192;
pub const RTE_LOGTYPE_TABLE: ::std::os::raw::c_uint = 16384;
pub const RTE_LOGTYPE_PIPELINE: ::std::os::raw::c_uint = 32768;
pub const RTE_LOGTYPE_MBUF: ::std::os::raw::c_uint = 65536;
pub const RTE_LOGTYPE_CRYPTODEV: ::std::os::raw::c_uint = 131072;
pub const RTE_LOGTYPE_USER1: ::std::os::raw::c_uint = 16777216;
pub const RTE_LOGTYPE_USER2: ::std::os::raw::c_uint = 33554432;
pub const RTE_LOGTYPE_USER3: ::std::os::raw::c_uint = 67108864;
pub const RTE_LOGTYPE_USER4: ::std::os::raw::c_uint = 134217728;
pub const RTE_LOGTYPE_USER5: ::std::os::raw::c_uint = 268435456;
pub const RTE_LOGTYPE_USER6: ::std::os::raw::c_uint = 536870912;
pub const RTE_LOGTYPE_USER7: ::std::os::raw::c_uint = 1073741824;
pub const RTE_LOGTYPE_USER8: ::std::os::raw::c_uint = 2147483648;
pub const RTE_LOG_EMERG: ::std::os::raw::c_uint = 1;
pub const RTE_LOG_ALERT: ::std::os::raw::c_uint = 2;
pub const RTE_LOG_CRIT: ::std::os::raw::c_uint = 3;
pub const RTE_LOG_ERR: ::std::os::raw::c_uint = 4;
pub const RTE_LOG_WARNING: ::std::os::raw::c_uint = 5;
pub const RTE_LOG_NOTICE: ::std::os::raw::c_uint = 6;
pub const RTE_LOG_INFO: ::std::os::raw::c_uint = 7;
pub const RTE_LOG_DEBUG: ::std::os::raw::c_uint = 8;
pub const RTE_MAX_RXTX_INTR_VEC_ID: ::std::os::raw::c_uint = 32;
pub const RTE_INTR_VEC_ZERO_OFFSET: ::std::os::raw::c_uint = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: ::std::os::raw::c_uint = 1;
pub const RTE_INTR_EVENT_ADD: ::std::os::raw::c_uint = 1;
pub const RTE_INTR_EVENT_DEL: ::std::os::raw::c_uint = 2;
pub const RTE_EPOLL_PER_THREAD: ::std::os::raw::c_int = -1;
pub const RTE_CLASS_ANY_ID: ::std::os::raw::c_uint = 16777215;
pub const RTE_PCI_DRV_NEED_MAPPING: ::std::os::raw::c_uint = 1;
pub const RTE_PCI_DRV_FORCE_UNBIND: ::std::os::raw::c_uint = 4;
pub const RTE_PCI_DRV_INTR_LSC: ::std::os::raw::c_uint = 8;
pub const RTE_PCI_DRV_DETACHABLE: ::std::os::raw::c_uint = 16;
pub const RTE_TAILQ_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const SOCKET_ID_ANY: ::std::os::raw::c_int = -1;
pub const RTE_CACHE_LINE_MASK: ::std::os::raw::c_uint = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: ::std::os::raw::c_uint = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_MEMZONE_2MB: ::std::os::raw::c_uint = 1;
pub const RTE_MEMZONE_1GB: ::std::os::raw::c_uint = 2;
pub const RTE_MEMZONE_16MB: ::std::os::raw::c_uint = 256;
pub const RTE_MEMZONE_16GB: ::std::os::raw::c_uint = 512;
pub const RTE_MEMZONE_256KB: ::std::os::raw::c_uint = 65536;
pub const RTE_MEMZONE_256MB: ::std::os::raw::c_uint = 131072;
pub const RTE_MEMZONE_512MB: ::std::os::raw::c_uint = 262144;
pub const RTE_MEMZONE_4GB: ::std::os::raw::c_uint = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: ::std::os::raw::c_uint = 4;
pub const RTE_MEMZONE_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_MAGIC: ::std::os::raw::c_uint = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: ::std::os::raw::c_uint = 16;
pub const RTE_XBEGIN_STARTED: ::std::os::raw::c_int = -1;
pub const RTE_XABORT_EXPLICIT: ::std::os::raw::c_uint = 1;
pub const RTE_XABORT_RETRY: ::std::os::raw::c_uint = 2;
pub const RTE_XABORT_CONFLICT: ::std::os::raw::c_uint = 4;
pub const RTE_XABORT_CAPACITY: ::std::os::raw::c_uint = 8;
pub const RTE_XABORT_DEBUG: ::std::os::raw::c_uint = 16;
pub const RTE_XABORT_NESTED: ::std::os::raw::c_uint = 32;
pub const RTE_RTM_MAX_RETRIES: ::std::os::raw::c_uint = 10;
pub const RTE_XABORT_LOCK_BUSY: ::std::os::raw::c_uint = 255;
pub const RTE_HEAP_NUM_FREELISTS: ::std::os::raw::c_uint = 13;
pub const RTE_KEEPALIVE_MAXCORES: ::std::os::raw::c_uint = 128;
pub const RTE_TIMER_STOP: ::std::os::raw::c_uint = 0;
pub const RTE_TIMER_PENDING: ::std::os::raw::c_uint = 1;
pub const RTE_TIMER_RUNNING: ::std::os::raw::c_uint = 2;
pub const RTE_TIMER_CONFIG: ::std::os::raw::c_uint = 3;
pub const RTE_TIMER_NO_OWNER: ::std::os::raw::c_int = -2;
pub const RTE_VER_PREFIX: &'static [u8; 5usize] = b"DPDK\x00";
pub const RTE_VER_YEAR: ::std::os::raw::c_uint = 16;
pub const RTE_VER_MONTH: ::std::os::raw::c_uint = 11;
pub const RTE_VER_MINOR: ::std::os::raw::c_uint = 0;
pub const RTE_VER_SUFFIX: &'static [u8; 1usize] = b"\x00";
pub const RTE_VER_RELEASE: ::std::os::raw::c_uint = 16;
pub const RTE_ACL_MAX_CATEGORIES: ::std::os::raw::c_uint = 16;
pub const RTE_ACL_MAX_LEVELS: ::std::os::raw::c_uint = 64;
pub const RTE_ACL_MAX_FIELDS: ::std::os::raw::c_uint = 64;
pub const RTE_ACL_INVALID_USERDATA: ::std::os::raw::c_uint = 0;
pub const RTE_ACL_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_TAILQ_RING_NAME: &'static [u8; 9usize] = b"RTE_RING\x00";
pub const RTE_RING_MZ_PREFIX: &'static [u8; 4usize] = b"RG_\x00";
pub const RTE_RING_QUOT_EXCEED: ::std::os::raw::c_uint = 2147483648;
pub const RTE_MEMPOOL_HEADER_COOKIE1: ::std::os::raw::c_longlong =
    -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: ::std::os::raw::c_longlong =
    -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: ::std::os::raw::c_longlong =
    -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &'static [u8; 4usize] = b"MP_\x00";
pub const RTE_MEMPOOL_MZ_FORMAT: &'static [u8; 6usize] = b"MP_%s\x00";
pub const RTE_MEMPOOL_ALIGN: ::std::os::raw::c_uint = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: ::std::os::raw::c_uint = 63;
pub const RTE_MEMPOOL_OPS_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_MEMPOOL_MAX_OPS_IDX: ::std::os::raw::c_uint = 16;
pub const RTE_PTYPE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const RTE_PTYPE_L2_ETHER: ::std::os::raw::c_uint = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: ::std::os::raw::c_uint = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: ::std::os::raw::c_uint = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: ::std::os::raw::c_uint = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: ::std::os::raw::c_uint = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: ::std::os::raw::c_uint = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: ::std::os::raw::c_uint = 7;
pub const RTE_PTYPE_L2_MASK: ::std::os::raw::c_uint = 15;
pub const RTE_PTYPE_L3_IPV4: ::std::os::raw::c_uint = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: ::std::os::raw::c_uint = 48;
pub const RTE_PTYPE_L3_IPV6: ::std::os::raw::c_uint = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: ::std::os::raw::c_uint = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: ::std::os::raw::c_uint = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: ::std::os::raw::c_uint = 224;
pub const RTE_PTYPE_L3_MASK: ::std::os::raw::c_uint = 240;
pub const RTE_PTYPE_L4_TCP: ::std::os::raw::c_uint = 256;
pub const RTE_PTYPE_L4_UDP: ::std::os::raw::c_uint = 512;
pub const RTE_PTYPE_L4_FRAG: ::std::os::raw::c_uint = 768;
pub const RTE_PTYPE_L4_SCTP: ::std::os::raw::c_uint = 1024;
pub const RTE_PTYPE_L4_ICMP: ::std::os::raw::c_uint = 1280;
pub const RTE_PTYPE_L4_NONFRAG: ::std::os::raw::c_uint = 1536;
pub const RTE_PTYPE_L4_MASK: ::std::os::raw::c_uint = 3840;
pub const RTE_PTYPE_TUNNEL_IP: ::std::os::raw::c_uint = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: ::std::os::raw::c_uint = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: ::std::os::raw::c_uint = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: ::std::os::raw::c_uint = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: ::std::os::raw::c_uint = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: ::std::os::raw::c_uint = 24576;
pub const RTE_PTYPE_TUNNEL_MASK: ::std::os::raw::c_uint = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: ::std::os::raw::c_uint = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: ::std::os::raw::c_uint = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: ::std::os::raw::c_uint = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: ::std::os::raw::c_uint = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: ::std::os::raw::c_uint = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: ::std::os::raw::c_uint = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: ::std::os::raw::c_uint = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: ::std::os::raw::c_uint =
    4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: ::std::os::raw::c_uint = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: ::std::os::raw::c_uint =
    6291456;
pub const RTE_PTYPE_INNER_L3_MASK: ::std::os::raw::c_uint = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: ::std::os::raw::c_uint = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: ::std::os::raw::c_uint = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: ::std::os::raw::c_uint = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: ::std::os::raw::c_uint = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: ::std::os::raw::c_uint = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: ::std::os::raw::c_uint = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: ::std::os::raw::c_uint = 251658240;
pub const RTE_PTYPE_ALL_MASK: ::std::os::raw::c_uint = 268435455;
pub const PKT_RX_VLAN_PKT: ::std::os::raw::c_uint = 1;
pub const PKT_RX_RSS_HASH: ::std::os::raw::c_uint = 2;
pub const PKT_RX_FDIR: ::std::os::raw::c_uint = 4;
pub const PKT_RX_L4_CKSUM_BAD: ::std::os::raw::c_uint = 8;
pub const PKT_RX_IP_CKSUM_BAD: ::std::os::raw::c_uint = 16;
pub const PKT_RX_EIP_CKSUM_BAD: ::std::os::raw::c_uint = 32;
pub const PKT_RX_VLAN_STRIPPED: ::std::os::raw::c_uint = 64;
pub const PKT_RX_IP_CKSUM_MASK: ::std::os::raw::c_uint = 144;
pub const PKT_RX_IP_CKSUM_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const PKT_RX_IP_CKSUM_GOOD: ::std::os::raw::c_uint = 128;
pub const PKT_RX_IP_CKSUM_NONE: ::std::os::raw::c_uint = 144;
pub const PKT_RX_L4_CKSUM_MASK: ::std::os::raw::c_uint = 264;
pub const PKT_RX_L4_CKSUM_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const PKT_RX_L4_CKSUM_GOOD: ::std::os::raw::c_uint = 256;
pub const PKT_RX_L4_CKSUM_NONE: ::std::os::raw::c_uint = 264;
pub const PKT_RX_IEEE1588_PTP: ::std::os::raw::c_uint = 512;
pub const PKT_RX_IEEE1588_TMST: ::std::os::raw::c_uint = 1024;
pub const PKT_RX_FDIR_ID: ::std::os::raw::c_uint = 8192;
pub const PKT_RX_FDIR_FLX: ::std::os::raw::c_uint = 16384;
pub const PKT_RX_QINQ_STRIPPED: ::std::os::raw::c_uint = 32768;
pub const PKT_RX_QINQ_PKT: ::std::os::raw::c_uint = 32768;
pub const PKT_RX_LRO: ::std::os::raw::c_uint = 65536;
pub const PKT_TX_TUNNEL_VXLAN: ::std::os::raw::c_ulonglong = 35184372088832;
pub const PKT_TX_TUNNEL_GRE: ::std::os::raw::c_ulonglong = 70368744177664;
pub const PKT_TX_TUNNEL_IPIP: ::std::os::raw::c_ulonglong = 105553116266496;
pub const PKT_TX_TUNNEL_GENEVE: ::std::os::raw::c_ulonglong = 140737488355328;
pub const PKT_TX_TUNNEL_MASK: ::std::os::raw::c_ulonglong = 527765581332480;
pub const PKT_TX_QINQ_PKT: ::std::os::raw::c_ulonglong = 562949953421312;
pub const PKT_TX_TCP_SEG: ::std::os::raw::c_ulonglong = 1125899906842624;
pub const PKT_TX_IEEE1588_TMST: ::std::os::raw::c_ulonglong =
    2251799813685248;
pub const PKT_TX_L4_NO_CKSUM: ::std::os::raw::c_uint = 0;
pub const PKT_TX_TCP_CKSUM: ::std::os::raw::c_ulonglong = 4503599627370496;
pub const PKT_TX_SCTP_CKSUM: ::std::os::raw::c_ulonglong = 9007199254740992;
pub const PKT_TX_UDP_CKSUM: ::std::os::raw::c_ulonglong = 13510798882111488;
pub const PKT_TX_L4_MASK: ::std::os::raw::c_ulonglong = 13510798882111488;
pub const PKT_TX_IP_CKSUM: ::std::os::raw::c_ulonglong = 18014398509481984;
pub const PKT_TX_IPV4: ::std::os::raw::c_ulonglong = 36028797018963968;
pub const PKT_TX_IPV6: ::std::os::raw::c_ulonglong = 72057594037927936;
pub const PKT_TX_VLAN_PKT: ::std::os::raw::c_ulonglong = 144115188075855872;
pub const PKT_TX_OUTER_IP_CKSUM: ::std::os::raw::c_ulonglong =
    288230376151711744;
pub const PKT_TX_OUTER_IPV4: ::std::os::raw::c_ulonglong = 576460752303423488;
pub const PKT_TX_OUTER_IPV6: ::std::os::raw::c_ulonglong =
    1152921504606846976;
pub const RTE_MBUF_PRIV_ALIGN: ::std::os::raw::c_uint = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: ::std::os::raw::c_uint = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: ::std::os::raw::c_uint = 2176;
pub const ETHER_ADDR_LEN: ::std::os::raw::c_uint = 6;
pub const ETHER_TYPE_LEN: ::std::os::raw::c_uint = 2;
pub const ETHER_CRC_LEN: ::std::os::raw::c_uint = 4;
pub const ETHER_HDR_LEN: ::std::os::raw::c_uint = 14;
pub const ETHER_MIN_LEN: ::std::os::raw::c_uint = 64;
pub const ETHER_MAX_LEN: ::std::os::raw::c_uint = 1518;
pub const ETHER_MTU: ::std::os::raw::c_uint = 1500;
pub const ETHER_MAX_VLAN_FRAME_LEN: ::std::os::raw::c_uint = 1522;
pub const ETHER_MAX_JUMBO_FRAME_LEN: ::std::os::raw::c_uint = 16128;
pub const ETHER_MAX_VLAN_ID: ::std::os::raw::c_uint = 4095;
pub const ETHER_MIN_MTU: ::std::os::raw::c_uint = 68;
pub const ETHER_LOCAL_ADMIN_ADDR: ::std::os::raw::c_uint = 2;
pub const ETHER_GROUP_ADDR: ::std::os::raw::c_uint = 1;
pub const ETHER_ADDR_FMT_SIZE: ::std::os::raw::c_uint = 18;
pub const ETHER_TYPE_IPv4: ::std::os::raw::c_uint = 2048;
pub const ETHER_TYPE_IPv6: ::std::os::raw::c_uint = 34525;
pub const ETHER_TYPE_ARP: ::std::os::raw::c_uint = 2054;
pub const ETHER_TYPE_RARP: ::std::os::raw::c_uint = 32821;
pub const ETHER_TYPE_VLAN: ::std::os::raw::c_uint = 33024;
pub const ETHER_TYPE_QINQ: ::std::os::raw::c_uint = 34984;
pub const ETHER_TYPE_1588: ::std::os::raw::c_uint = 35063;
pub const ETHER_TYPE_SLOW: ::std::os::raw::c_uint = 34825;
pub const ETHER_TYPE_TEB: ::std::os::raw::c_uint = 25944;
pub const BONDING_MODE_ROUND_ROBIN: ::std::os::raw::c_uint = 0;
pub const BONDING_MODE_ACTIVE_BACKUP: ::std::os::raw::c_uint = 1;
pub const BONDING_MODE_BALANCE: ::std::os::raw::c_uint = 2;
pub const BONDING_MODE_BROADCAST: ::std::os::raw::c_uint = 3;
pub const BONDING_MODE_8023AD: ::std::os::raw::c_uint = 4;
pub const BONDING_MODE_TLB: ::std::os::raw::c_uint = 5;
pub const BONDING_MODE_ALB: ::std::os::raw::c_uint = 6;
pub const CMDLINE_PARSE_SUCCESS: ::std::os::raw::c_uint = 0;
pub const CMDLINE_PARSE_AMBIGUOUS: ::std::os::raw::c_int = -1;
pub const CMDLINE_PARSE_NOMATCH: ::std::os::raw::c_int = -2;
pub const CMDLINE_PARSE_BAD_ARGS: ::std::os::raw::c_int = -3;
pub const CMDLINE_PARSE_COMPLETE_FINISHED: ::std::os::raw::c_uint = 0;
pub const CMDLINE_PARSE_COMPLETE_AGAIN: ::std::os::raw::c_uint = 1;
pub const CMDLINE_PARSE_COMPLETED_BUFFER: ::std::os::raw::c_uint = 2;
pub const CMDLINE_PARSE_RESULT_BUFSIZE: ::std::os::raw::c_uint = 8192;
pub const CMDLINE_IPADDR_V4: ::std::os::raw::c_uint = 1;
pub const CMDLINE_IPADDR_V6: ::std::os::raw::c_uint = 2;
pub const CMDLINE_IPADDR_NETWORK: ::std::os::raw::c_uint = 4;
pub const CMDLINE_KEY_UP_ARR: ::std::os::raw::c_uint = 0;
pub const CMDLINE_KEY_DOWN_ARR: ::std::os::raw::c_uint = 1;
pub const CMDLINE_KEY_RIGHT_ARR: ::std::os::raw::c_uint = 2;
pub const CMDLINE_KEY_LEFT_ARR: ::std::os::raw::c_uint = 3;
pub const CMDLINE_KEY_BKSPACE: ::std::os::raw::c_uint = 4;
pub const CMDLINE_KEY_RETURN: ::std::os::raw::c_uint = 5;
pub const CMDLINE_KEY_CTRL_A: ::std::os::raw::c_uint = 6;
pub const CMDLINE_KEY_CTRL_E: ::std::os::raw::c_uint = 7;
pub const CMDLINE_KEY_CTRL_K: ::std::os::raw::c_uint = 8;
pub const CMDLINE_KEY_CTRL_Y: ::std::os::raw::c_uint = 9;
pub const CMDLINE_KEY_CTRL_C: ::std::os::raw::c_uint = 10;
pub const CMDLINE_KEY_CTRL_F: ::std::os::raw::c_uint = 11;
pub const CMDLINE_KEY_CTRL_B: ::std::os::raw::c_uint = 12;
pub const CMDLINE_KEY_SUPPR: ::std::os::raw::c_uint = 13;
pub const CMDLINE_KEY_TAB: ::std::os::raw::c_uint = 14;
pub const CMDLINE_KEY_CTRL_D: ::std::os::raw::c_uint = 15;
pub const CMDLINE_KEY_CTRL_L: ::std::os::raw::c_uint = 16;
pub const CMDLINE_KEY_RETURN2: ::std::os::raw::c_uint = 17;
pub const CMDLINE_KEY_META_BKSPACE: ::std::os::raw::c_uint = 18;
pub const CMDLINE_KEY_WLEFT: ::std::os::raw::c_uint = 19;
pub const CMDLINE_KEY_WRIGHT: ::std::os::raw::c_uint = 20;
pub const CMDLINE_KEY_HELP: ::std::os::raw::c_uint = 21;
pub const CMDLINE_KEY_CTRL_W: ::std::os::raw::c_uint = 22;
pub const CMDLINE_KEY_CTRL_P: ::std::os::raw::c_uint = 23;
pub const CMDLINE_KEY_CTRL_N: ::std::os::raw::c_uint = 24;
pub const CMDLINE_KEY_META_D: ::std::os::raw::c_uint = 25;
pub const CMDLINE_VT100_BUF_SIZE: ::std::os::raw::c_uint = 8;
pub const RTE_DISTRIBUTOR_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_ETH_FLOW_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const RTE_ETH_FLOW_RAW: ::std::os::raw::c_uint = 1;
pub const RTE_ETH_FLOW_IPV4: ::std::os::raw::c_uint = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: ::std::os::raw::c_uint = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: ::std::os::raw::c_uint = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: ::std::os::raw::c_uint = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: ::std::os::raw::c_uint = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: ::std::os::raw::c_uint = 7;
pub const RTE_ETH_FLOW_IPV6: ::std::os::raw::c_uint = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: ::std::os::raw::c_uint = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: ::std::os::raw::c_uint = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: ::std::os::raw::c_uint = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: ::std::os::raw::c_uint = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: ::std::os::raw::c_uint = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: ::std::os::raw::c_uint = 14;
pub const RTE_ETH_FLOW_IPV6_EX: ::std::os::raw::c_uint = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: ::std::os::raw::c_uint = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: ::std::os::raw::c_uint = 17;
pub const RTE_ETH_FLOW_PORT: ::std::os::raw::c_uint = 18;
pub const RTE_ETH_FLOW_VXLAN: ::std::os::raw::c_uint = 19;
pub const RTE_ETH_FLOW_GENEVE: ::std::os::raw::c_uint = 20;
pub const RTE_ETH_FLOW_NVGRE: ::std::os::raw::c_uint = 21;
pub const RTE_ETH_FLOW_MAX: ::std::os::raw::c_uint = 22;
pub const RTE_ETHTYPE_FLAGS_MAC: ::std::os::raw::c_uint = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: ::std::os::raw::c_uint = 2;
pub const RTE_FLEX_FILTER_MAXLEN: ::std::os::raw::c_uint = 128;
pub const RTE_NTUPLE_FLAGS_DST_IP: ::std::os::raw::c_uint = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: ::std::os::raw::c_uint = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: ::std::os::raw::c_uint = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: ::std::os::raw::c_uint = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: ::std::os::raw::c_uint = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: ::std::os::raw::c_uint = 32;
pub const RTE_5TUPLE_FLAGS: ::std::os::raw::c_uint = 31;
pub const RTE_2TUPLE_FLAGS: ::std::os::raw::c_uint = 20;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN: ::std::os::raw::c_uint = 24;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID: ::std::os::raw::c_uint = 28;
pub const RTE_TUNNEL_FILTER_IMAC_TENID: ::std::os::raw::c_uint = 12;
pub const RTE_TUNNEL_FILTER_OMAC_TENID_IMAC: ::std::os::raw::c_uint = 13;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: ::std::os::raw::c_uint = 16;
pub const RTE_ETH_INSET_SIZE_MAX: ::std::os::raw::c_uint = 128;
pub const RTE_RETA_GROUP_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_ETH_XSTATS_NAME_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_ETH_QUEUE_STATE_STOPPED: ::std::os::raw::c_uint = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: ::std::os::raw::c_uint = 1;
pub const RTE_ETH_NAME_MAX_LEN: ::std::os::raw::c_uint = 32;
pub const RTE_ETH_DEV_DETACHABLE: ::std::os::raw::c_uint = 1;
pub const RTE_ETH_DEV_INTR_LSC: ::std::os::raw::c_uint = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: ::std::os::raw::c_uint = 4;
pub const RTE_HASH_ENTRIES_MAX: ::std::os::raw::c_uint = 1073741824;
pub const RTE_HASH_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_HASH_LOOKUP_BULK_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_HASH_LOOKUP_MULTI_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT: ::std::os::raw::c_uint = 1;
pub const RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD: ::std::os::raw::c_uint = 2;
pub const RTE_IPV6_EHDR_MF_SHIFT: ::std::os::raw::c_uint = 0;
pub const RTE_IPV6_EHDR_MF_MASK: ::std::os::raw::c_uint = 1;
pub const RTE_IPV6_EHDR_FO_SHIFT: ::std::os::raw::c_uint = 3;
pub const RTE_IPV6_EHDR_FO_MASK: ::std::os::raw::c_int = -8;
pub const RTE_IPV6_FRAG_USED_MASK: ::std::os::raw::c_int = -7;
pub const RTE_KNI_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_LPM_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_LPM_MAX_DEPTH: ::std::os::raw::c_uint = 32;
pub const RTE_LPM_TBL24_NUM_ENTRIES: ::std::os::raw::c_uint = 16777216;
pub const RTE_LPM_TBL8_GROUP_NUM_ENTRIES: ::std::os::raw::c_uint = 256;
pub const RTE_LPM_MAX_TBL8_NUM_GROUPS: ::std::os::raw::c_uint = 16777216;
pub const RTE_LPM_TBL8_NUM_GROUPS: ::std::os::raw::c_uint = 256;
pub const RTE_LPM_TBL8_NUM_ENTRIES: ::std::os::raw::c_uint = 65536;
pub const RTE_LPM_VALID_EXT_ENTRY_BITMASK: ::std::os::raw::c_uint = 50331648;
pub const RTE_LPM_LOOKUP_SUCCESS: ::std::os::raw::c_uint = 16777216;
pub const RTE_LPM6_MAX_DEPTH: ::std::os::raw::c_uint = 128;
pub const RTE_LPM6_IPV6_ADDR_SIZE: ::std::os::raw::c_uint = 16;
pub const RTE_LPM6_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const ARP_HRD_ETHER: ::std::os::raw::c_uint = 1;
pub const ARP_OP_REQUEST: ::std::os::raw::c_uint = 1;
pub const ARP_OP_REPLY: ::std::os::raw::c_uint = 2;
pub const ARP_OP_REVREQUEST: ::std::os::raw::c_uint = 3;
pub const ARP_OP_REVREPLY: ::std::os::raw::c_uint = 4;
pub const ARP_OP_INVREQUEST: ::std::os::raw::c_uint = 8;
pub const ARP_OP_INVREPLY: ::std::os::raw::c_uint = 9;
pub const RTE_PDUMP_ALL_QUEUES: ::std::os::raw::c_uint = 65535;
pub const RTE_PORT_IN_BURST_SIZE_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_PIPELINE_TABLE_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_PIPELINE_PORT_IN_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_PIPELINE_PORT_OUT_MAX: ::std::os::raw::c_uint = 64;
pub const RTE_SCHED_TRAFFIC_CLASSES_PER_PIPE: ::std::os::raw::c_uint = 4;
pub const RTE_SCHED_QUEUES_PER_TRAFFIC_CLASS: ::std::os::raw::c_uint = 4;
pub const RTE_SCHED_QUEUES_PER_PIPE: ::std::os::raw::c_uint = 16;
pub const RTE_SCHED_PIPE_PROFILES_PER_PORT: ::std::os::raw::c_uint = 256;
pub const RTE_SCHED_FRAME_OVERHEAD_DEFAULT: ::std::os::raw::c_uint = 24;
pub const RTE_BITMAP_OPTIMIZATIONS: ::std::os::raw::c_uint = 1;
pub const RTE_BITMAP_SLAB_BIT_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_BITMAP_SLAB_BIT_SIZE_LOG2: ::std::os::raw::c_uint = 6;
pub const RTE_BITMAP_SLAB_BIT_MASK: ::std::os::raw::c_uint = 63;
pub const RTE_BITMAP_CL_BIT_SIZE: ::std::os::raw::c_uint = 512;
pub const RTE_BITMAP_CL_BIT_SIZE_LOG2: ::std::os::raw::c_uint = 9;
pub const RTE_BITMAP_CL_BIT_MASK: ::std::os::raw::c_uint = 511;
pub const RTE_BITMAP_CL_SLAB_SIZE: ::std::os::raw::c_uint = 8;
pub const RTE_BITMAP_CL_SLAB_SIZE_LOG2: ::std::os::raw::c_uint = 3;
pub const RTE_BITMAP_CL_SLAB_MASK: ::std::os::raw::c_uint = 7;
pub const RTE_RED_SCALING: ::std::os::raw::c_uint = 10;
pub const RTE_RED_S: ::std::os::raw::c_uint = 4194304;
pub const RTE_RED_MAX_TH_MAX: ::std::os::raw::c_uint = 1023;
pub const RTE_RED_WQ_LOG2_MIN: ::std::os::raw::c_uint = 1;
pub const RTE_RED_WQ_LOG2_MAX: ::std::os::raw::c_uint = 12;
pub const RTE_RED_MAXP_INV_MIN: ::std::os::raw::c_uint = 1;
pub const RTE_RED_MAXP_INV_MAX: ::std::os::raw::c_uint = 255;
pub const RTE_RED_2POW16: ::std::os::raw::c_uint = 65536;
pub const RTE_RED_WQ_LOG2_NUM: ::std::os::raw::c_uint = 12;
/**
 * Signature of callback back function called when an alarm goes off.
 */
pub type rte_eal_alarm_callback =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /**
 * Function to set a callback to be triggered when us microseconds
 * have expired. Accuracy of timing to the microsecond is not guaranteed. The
 * alarm function will not be called *before* the requested time, but may
 * be called a short period of time afterwards.
 * The alarm handler will be called only once. There is no need to call
 * "rte_eal_alarm_cancel" from within the callback function.
 *
 * @param us
 *   The time in microseconds before the callback is called
 * @param cb
 *   The function to be called when the alarm expires
 * @param cb_arg
 *   Pointer parameter to be passed to the callback function
 *
 * @return
 *   On success, zero.
 *   On failure, a negative error number
 */
    pub fn rte_eal_alarm_set(us: u64, cb: rte_eal_alarm_callback,
                             cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Function to cancel an alarm callback which has been registered before. If
 * used outside alarm callback it wait for all callbacks to finish execution.
 *
 * @param cb_fn
 *  alarm callback
 * @param cb_arg
 *  Pointer parameter to be passed to the callback function. To remove all
 *  copies of a given callback function, irrespective of parameter, (void *)-1
 *  can be used here.
 *
 * @return
 *    - value greater than 0 and rte_errno not changed - returned value is
 *      the number of canceled alarm callback functions
 *    - value greater or equal 0 and rte_errno set to EINPROGRESS, at least one
 *      alarm could not be canceled because cancellation was requested from alarm
 *      callback context. Returned value is the number of succesfuly canceled
 *      alarm callbacks
 *    -  0 and rte_errno set to ENOENT - no alarm found
 *    - -1 and rte_errno set to EINVAL - invalid parameter (NULL callback)
 */
    pub fn rte_eal_alarm_cancel(cb_fn: rte_eal_alarm_callback,
                                cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type off_t = __off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize);
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize);
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
extern "C" {
    /**
 * Function to terminate the application immediately, printing an error
 * message and returning the exit_code back to the shell.
 *
 * This function never returns
 *
 * @param exit_code
 *     The exit code to be returned by the application
 * @param format
 *     The format string to be used for printing the message. This can include
 *     printf format characters which will be expanded using any further parameters
 *     to the function.
 */
    pub fn rte_exit(exit_code: ::std::os::raw::c_int,
                    format: *const ::std::os::raw::c_char, ...);
}
/**
 * The atomic counter structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_17 {
    /**< An internal counter value. */
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 2usize);
    assert_eq! (::std::mem::align_of::<_bindgen_ty_17>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_17 ) ) . cnt as * const _ as
                usize } , 0usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
pub type rte_atomic16_t = _bindgen_ty_17;
/**
 * The atomic counter structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18 {
    /**< An internal counter value. */
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_18>() , 4usize);
    assert_eq! (::std::mem::align_of::<_bindgen_ty_18>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_18 ) ) . cnt as * const _ as
                usize } , 0usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
pub type rte_atomic32_t = _bindgen_ty_18;
/**
 * The atomic counter structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_19 {
    /**< Internal counter value. */
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_19() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_19>() , 8usize);
    assert_eq! (::std::mem::align_of::<_bindgen_ty_19>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_19 ) ) . cnt as * const _ as
                usize } , 0usize);
}
impl Clone for _bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
pub type rte_atomic64_t = _bindgen_ty_19;
#[repr(u32)]
/**
 * Enumeration of all CPU features supported
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_cpu_flag_t {
    RTE_CPUFLAG_SSE3 = 0,
    RTE_CPUFLAG_PCLMULQDQ = 1,
    RTE_CPUFLAG_DTES64 = 2,
    RTE_CPUFLAG_MONITOR = 3,
    RTE_CPUFLAG_DS_CPL = 4,
    RTE_CPUFLAG_VMX = 5,
    RTE_CPUFLAG_SMX = 6,
    RTE_CPUFLAG_EIST = 7,
    RTE_CPUFLAG_TM2 = 8,
    RTE_CPUFLAG_SSSE3 = 9,
    RTE_CPUFLAG_CNXT_ID = 10,
    RTE_CPUFLAG_FMA = 11,
    RTE_CPUFLAG_CMPXCHG16B = 12,
    RTE_CPUFLAG_XTPR = 13,
    RTE_CPUFLAG_PDCM = 14,
    RTE_CPUFLAG_PCID = 15,
    RTE_CPUFLAG_DCA = 16,
    RTE_CPUFLAG_SSE4_1 = 17,
    RTE_CPUFLAG_SSE4_2 = 18,
    RTE_CPUFLAG_X2APIC = 19,
    RTE_CPUFLAG_MOVBE = 20,
    RTE_CPUFLAG_POPCNT = 21,
    RTE_CPUFLAG_TSC_DEADLINE = 22,
    RTE_CPUFLAG_AES = 23,
    RTE_CPUFLAG_XSAVE = 24,
    RTE_CPUFLAG_OSXSAVE = 25,
    RTE_CPUFLAG_AVX = 26,
    RTE_CPUFLAG_F16C = 27,
    RTE_CPUFLAG_RDRAND = 28,
    RTE_CPUFLAG_FPU = 29,
    RTE_CPUFLAG_VME = 30,
    RTE_CPUFLAG_DE = 31,
    RTE_CPUFLAG_PSE = 32,
    RTE_CPUFLAG_TSC = 33,
    RTE_CPUFLAG_MSR = 34,
    RTE_CPUFLAG_PAE = 35,
    RTE_CPUFLAG_MCE = 36,
    RTE_CPUFLAG_CX8 = 37,
    RTE_CPUFLAG_APIC = 38,
    RTE_CPUFLAG_SEP = 39,
    RTE_CPUFLAG_MTRR = 40,
    RTE_CPUFLAG_PGE = 41,
    RTE_CPUFLAG_MCA = 42,
    RTE_CPUFLAG_CMOV = 43,
    RTE_CPUFLAG_PAT = 44,
    RTE_CPUFLAG_PSE36 = 45,
    RTE_CPUFLAG_PSN = 46,
    RTE_CPUFLAG_CLFSH = 47,
    RTE_CPUFLAG_DS = 48,
    RTE_CPUFLAG_ACPI = 49,
    RTE_CPUFLAG_MMX = 50,
    RTE_CPUFLAG_FXSR = 51,
    RTE_CPUFLAG_SSE = 52,
    RTE_CPUFLAG_SSE2 = 53,
    RTE_CPUFLAG_SS = 54,
    RTE_CPUFLAG_HTT = 55,
    RTE_CPUFLAG_TM = 56,
    RTE_CPUFLAG_PBE = 57,
    RTE_CPUFLAG_DIGTEMP = 58,
    RTE_CPUFLAG_TRBOBST = 59,
    RTE_CPUFLAG_ARAT = 60,
    RTE_CPUFLAG_PLN = 61,
    RTE_CPUFLAG_ECMD = 62,
    RTE_CPUFLAG_PTM = 63,
    RTE_CPUFLAG_MPERF_APERF_MSR = 64,
    RTE_CPUFLAG_ACNT2 = 65,
    RTE_CPUFLAG_ENERGY_EFF = 66,
    RTE_CPUFLAG_FSGSBASE = 67,
    RTE_CPUFLAG_BMI1 = 68,
    RTE_CPUFLAG_HLE = 69,
    RTE_CPUFLAG_AVX2 = 70,
    RTE_CPUFLAG_SMEP = 71,
    RTE_CPUFLAG_BMI2 = 72,
    RTE_CPUFLAG_ERMS = 73,
    RTE_CPUFLAG_INVPCID = 74,
    RTE_CPUFLAG_RTM = 75,
    RTE_CPUFLAG_AVX512F = 76,
    RTE_CPUFLAG_LAHF_SAHF = 77,
    RTE_CPUFLAG_LZCNT = 78,
    RTE_CPUFLAG_SYSCALL = 79,
    RTE_CPUFLAG_XD = 80,
    RTE_CPUFLAG_1GB_PG = 81,
    RTE_CPUFLAG_RDTSCP = 82,
    RTE_CPUFLAG_EM64T = 83,
    RTE_CPUFLAG_INVTSC = 84,
    RTE_CPUFLAG_NUMFLAGS = 85,
}
extern "C" {
    /**
 * Get name of CPU flag
 *
 * @param feature
 *     CPU flag ID
 * @return
 *     flag name
 *     NULL if flag ID is invalid
 */
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Function for checking a CPU flag availability
 *
 * @param feature
 *     CPU flag to query CPU for
 * @return
 *     1 if flag is available
 *     0 if flag is not available
 *     -ENOENT if flag is invalid
 */
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * This function checks that the currently used CPU supports the CPU features
 * that were specified at compile time. It is called automatically within the
 * EAL, so does not need to be used by applications.
 */
    pub fn rte_cpu_check_supported();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize);
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize);
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize);
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize);
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
/** The rte_log structure. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_logs {
    /**< Bitfield with enabled logs. */
    pub type_: u32,
    /**< Log level. */
    pub level: u32,
    /**< Output file set by rte_openlog_stream, or NULL. */
    pub file: *mut FILE,
}
#[test]
fn bindgen_test_layout_rte_logs() {
    assert_eq!(::std::mem::size_of::<rte_logs>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_logs>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . type_ as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . level as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_logs ) ) . file as * const _ as usize
                } , 8usize);
}
impl Clone for rte_logs {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Change the stream that will be used by the logging system.
 *
 * This can be done at any time. The f argument represents the stream
 * to be used to send the logs. If f is NULL, the default output is
 * used (stderr).
 *
 * @param f
 *   Pointer to the stream.
 * @return
 *   - 0 on success.
 *   - Negative on error.
 */
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the global log level.
 *
 * After this call, all logs that are lower or equal than level and
 * lower or equal than the RTE_LOG_LEVEL configuration option will be
 * displayed.
 *
 * @param level
 *   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
 */
    pub fn rte_set_log_level(level: u32);
}
extern "C" {
    /**
 * Get the global log level.
 */
    pub fn rte_get_log_level() -> u32;
}
extern "C" {
    /**
 * Enable or disable the log type.
 *
 * @param type
 *   Log type, for example, RTE_LOGTYPE_EAL.
 * @param enable
 *   True for enable; false for disable.
 */
    pub fn rte_set_log_type(type_: u32, enable: ::std::os::raw::c_int);
}
extern "C" {
    /**
 * Get the global log type.
 */
    pub fn rte_get_log_type() -> u32;
}
extern "C" {
    /**
 * Get the current loglevel for the message being processed.
 *
 * Before calling the user-defined stream for logging, the log
 * subsystem sets a per-lcore variable containing the loglevel and the
 * logtype of the message being processed. This information can be
 * accessed by the user-defined log output function through this
 * function.
 *
 * @return
 *   The loglevel of the message being processed.
 */
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the current logtype for the message being processed.
 *
 * Before calling the user-defined stream for logging, the log
 * subsystem sets a per-lcore variable containing the loglevel and the
 * logtype of the message being processed. This information can be
 * accessed by the user-defined log output function through this
 * function.
 *
 * @return
 *   The logtype of the message being processed.
 */
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Generates a log message.
 *
 * The message will be sent in the stream defined by the previous call
 * to rte_openlog_stream().
 *
 * The level argument determines if the log should be displayed or
 * not, depending on the global rte_logs variable.
 *
 * The preferred alternative is the RTE_LOG() function because debug logs may
 * be removed at compilation time if optimization is enabled. Moreover,
 * logs are automatically prefixed by type when using the macro.
 *
 * @param level
 *   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
 * @param logtype
 *   The log type, for example, RTE_LOGTYPE_EAL.
 * @param format
 *   The format string, as in printf(3), followed by the variable arguments
 *   required by the format.
 * @return
 *   - 0: Success.
 *   - Negative on error.
 */
    pub fn rte_log(level: u32, logtype: u32,
                   format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Generates a log message.
 *
 * The message will be sent in the stream defined by the previous call
 * to rte_openlog_stream().
 *
 * The level argument determines if the log should be displayed or
 * not, depending on the global rte_logs variable. A trailing
 * newline may be added if needed.
 *
 * The preferred alternative is the RTE_LOG() because debug logs may be
 * removed at compilation time.
 *
 * @param level
 *   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
 * @param logtype
 *   The log type, for example, RTE_LOGTYPE_EAL.
 * @param format
 *   The format string, as in printf(3), followed by the variable arguments
 *   required by the format.
 * @param ap
 *   The va_list of the variable arguments required by the format.
 * @return
 *   - 0: Success.
 *   - Negative on error.
 */
    pub fn rte_vlog(level: u32, logtype: u32,
                    format: *const ::std::os::raw::c_char,
                    ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Dump the stack of the calling core to the console.
 */
    pub fn rte_dump_stack();
}
extern "C" {
    /**
 * Dump the registers of the calling core to the console.
 *
 * Note: Not implemented in a userapp environment; use gdb instead.
 */
    pub fn rte_dump_registers();
}
extern "C" {
    /**
 * Get the measured frequency of the RDTSC counter
 *
 * @return
 *   The TSC frequency for this lcore
 */
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    /**
 * Blocking delay function.
 *
 * @param us
 *   Number of microseconds to wait.
 */
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    /**
 * Replace rte_delay_us with user defined function.
 *
 * @param userfunc
 *   User function which replaces rte_delay_us. rte_delay_us_block restores
 *   buildin block delay function.
 */
    pub fn rte_delay_us_callback_register(userfunc:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             ::std::os::raw::c_uint)>);
}
/**
 * A generic memory resource representation.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mem_resource {
    /**< Physical address, 0 if not resource. */
    pub phys_addr: u64,
    /**< Length of the resource. */
    pub len: u64,
    /**< Virtual address, NULL when not mapped. */
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_mem_resource() {
    assert_eq!(::std::mem::size_of::<rte_mem_resource>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_mem_resource>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_resource ) ) . phys_addr as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_resource ) ) . len as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mem_resource ) ) . addr as * const _
                as usize } , 16usize);
}
impl Clone for rte_mem_resource {
    fn clone(&self) -> Self { *self }
}
/** Double linked list of device drivers. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_driver_list {
    pub tqh_first: *mut rte_driver_list_rte_driver,
    pub tqh_last: *mut *mut rte_driver_list_rte_driver,
}
/**
 * A structure describing a device driver.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_driver_list_rte_driver {
    /**< Next in list. */
    pub next: rte_driver_list_rte_driver__bindgen_ty_1,
    /**< Driver name. */
    pub name: *const ::std::os::raw::c_char,
    /**< Driver alias. */
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_driver_list_rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver_list_rte_driver,
    pub tqe_prev: *mut *mut rte_driver_list_rte_driver,
}
#[test]
fn bindgen_test_layout_rte_driver_list_rte_driver__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_driver_list_rte_driver__bindgen_ty_1>()
               , 16usize);
    assert_eq! (::std::mem::align_of::<rte_driver_list_rte_driver__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_driver_list_rte_driver__bindgen_ty_1 ) )
                . tqe_next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_driver_list_rte_driver__bindgen_ty_1 ) )
                . tqe_prev as * const _ as usize } , 8usize);
}
impl Clone for rte_driver_list_rte_driver__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_driver_list_rte_driver() {
    assert_eq!(::std::mem::size_of::<rte_driver_list_rte_driver>() , 32usize);
    assert_eq! (::std::mem::align_of::<rte_driver_list_rte_driver>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver_list_rte_driver ) ) . next as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver_list_rte_driver ) ) . name as
                * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver_list_rte_driver ) ) . alias as
                * const _ as usize } , 24usize);
}
impl Clone for rte_driver_list_rte_driver {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_driver_list() {
    assert_eq!(::std::mem::size_of::<rte_driver_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_driver_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver_list ) ) . tqh_first as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_driver_list ) ) . tqh_last as * const
                _ as usize } , 8usize);
}
impl Clone for rte_driver_list {
    fn clone(&self) -> Self { *self }
}
/** Double linked list of devices. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list {
    pub tqh_first: *mut rte_device_list_rte_device,
    pub tqh_last: *mut *mut rte_device_list_rte_device,
}
/**
 * A structure describing a generic device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list_rte_device {
    /**< Next device */
    pub next: rte_device_list_rte_device__bindgen_ty_1,
    /**< Associated driver */
    pub driver: *mut rte_driver_list_rte_driver,
    /**< NUMA node connection */
    pub numa_node: ::std::os::raw::c_int,
    /**< Device user arguments */
    pub devargs: *mut rte_device_list_rte_device_rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list_rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device_list_rte_device,
    pub tqe_prev: *mut *mut rte_device_list_rte_device,
}
#[test]
fn bindgen_test_layout_rte_device_list_rte_device__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_device_list_rte_device__bindgen_ty_1>()
               , 16usize);
    assert_eq! (::std::mem::align_of::<rte_device_list_rte_device__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_device_list_rte_device__bindgen_ty_1 ) )
                . tqe_next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_device_list_rte_device__bindgen_ty_1 ) )
                . tqe_prev as * const _ as usize } , 8usize);
}
impl Clone for rte_device_list_rte_device__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/**
 * Structure that stores a device given by the user with its arguments
 *
 * A user device is a physical or a virtual device given by the user to
 * the DPDK application at startup through command line arguments.
 *
 * The structure stores the configuration of the device, its PCI
 * identifier if it's a PCI device or the driver name if it's a virtual
 * device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list_rte_device_rte_devargs {
    /** Next in list. */
    pub next: rte_device_list_rte_device_rte_devargs__bindgen_ty_1,
    /** Type of device. */
    pub type_: rte_devtype,
    pub __bindgen_anon_1: rte_device_list_rte_device_rte_devargs__bindgen_ty_2,
    /** Arguments string as given by user or "" for no argument. */
    pub args: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list_rte_device_rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_device_list_rte_device_rte_devargs,
    pub tqe_prev: *mut *mut rte_device_list_rte_device_rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_device_list_rte_device_rte_devargs__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_1>()
               , 16usize);
    assert_eq! (::std::mem::align_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_device_list_rte_device_rte_devargs__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_device_list_rte_device_rte_devargs__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize);
}
impl Clone for rte_device_list_rte_device_rte_devargs__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list_rte_device_rte_devargs__bindgen_ty_2 {
    pub pci: __BindgenUnionField<rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_1>,
    pub virt: __BindgenUnionField<rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_2>,
    pub bindgen_union_field: [u16; 16usize],
}
/** Used if type is RTE_DEVTYPE_*_PCI. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_1 {
    /** PCI location. */
    pub addr: rte_pci_addr,
}
#[test]
fn bindgen_test_layout_rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_1>()
               , 6usize);
    assert_eq! (::std::mem::align_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_1>()
                , 2usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_1
                ) ) . addr as * const _ as usize } , 0usize);
}
impl Clone for
 rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/** Used if type is RTE_DEVTYPE_VIRTUAL. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_2 {
    /** Driver name. */
    pub drv_name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_2>()
               , 32usize);
    assert_eq! (::std::mem::align_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_2>()
                , 1usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_2
                ) ) . drv_name as * const _ as usize } , 0usize);
}
impl Clone for
 rte_device_list_rte_device_rte_devargs__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_device_list_rte_device_rte_devargs__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_2>()
               , 32usize);
    assert_eq! (::std::mem::align_of::<rte_device_list_rte_device_rte_devargs__bindgen_ty_2>()
                , 2usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_device_list_rte_device_rte_devargs__bindgen_ty_2 ) ) . pci
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_device_list_rte_device_rte_devargs__bindgen_ty_2 ) ) .
                virt as * const _ as usize } , 0usize);
}
impl Clone for rte_device_list_rte_device_rte_devargs__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_device_list_rte_device_rte_devargs() {
    assert_eq!(::std::mem::size_of::<rte_device_list_rte_device_rte_devargs>()
               , 64usize);
    assert_eq! (::std::mem::align_of::<rte_device_list_rte_device_rte_devargs>()
                , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list_rte_device_rte_devargs )
                ) . next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list_rte_device_rte_devargs )
                ) . type_ as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list_rte_device_rte_devargs )
                ) . args as * const _ as usize } , 56usize);
}
impl Clone for rte_device_list_rte_device_rte_devargs {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_device_list_rte_device() {
    assert_eq!(::std::mem::size_of::<rte_device_list_rte_device>() , 40usize);
    assert_eq! (::std::mem::align_of::<rte_device_list_rte_device>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list_rte_device ) ) . next as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list_rte_device ) ) . driver
                as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list_rte_device ) ) .
                numa_node as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list_rte_device ) ) . devargs
                as * const _ as usize } , 32usize);
}
impl Clone for rte_device_list_rte_device {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_device_list() {
    assert_eq!(::std::mem::size_of::<rte_device_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_device_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list ) ) . tqh_first as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_device_list ) ) . tqh_last as * const
                _ as usize } , 8usize);
}
impl Clone for rte_device_list {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Insert a device detected by a bus scanning.
 *
 * @param dev
 *   A pointer to a rte_device structure describing the detected device.
 */
    pub fn rte_eal_device_insert(dev: *mut rte_device_list_rte_device);
}
extern "C" {
    /**
 * Remove a device (e.g. when being unplugged).
 *
 * @param dev
 *   A pointer to a rte_device structure describing the device to be removed.
 */
    pub fn rte_eal_device_remove(dev: *mut rte_device_list_rte_device);
}
extern "C" {
    /**
 * Register a device driver.
 *
 * @param driver
 *   A pointer to a rte_dev structure describing the driver
 *   to be registered.
 */
    pub fn rte_eal_driver_register(driver: *mut rte_driver_list_rte_driver);
}
extern "C" {
    /**
 * Unregister a device driver.
 *
 * @param driver
 *   A pointer to a rte_dev structure describing the driver
 *   to be unregistered.
 */
    pub fn rte_eal_driver_unregister(driver: *mut rte_driver_list_rte_driver);
}
extern "C" {
    /**
 * Initalize all the registered drivers in this process
 */
    pub fn rte_eal_dev_init() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Initialize a driver specified by name.
 *
 * @param name
 *   The pointer to a driver name to be initialized.
 * @param args
 *   The pointer to arguments used by driver initialization.
 * @return
 *  0 on success, negative on error
 */
    pub fn rte_eal_vdev_init(name: *const ::std::os::raw::c_char,
                             args: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Uninitalize a driver specified by name.
 *
 * @param name
 *   The pointer to a driver name to be initialized.
 * @return
 *  0 on success, negative on error
 */
    pub fn rte_eal_vdev_uninit(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Attach a device to a registered driver.
 *
 * @param name
 *   The device name, that refers to a pci device (or some private
 *   way of designating a vdev device). Based on this device name, eal
 *   will identify a driver capable of handling it and pass it to the
 *   driver probing function.
 * @param devargs
 *   Device arguments to be passed to the driver.
 * @return
 *   0 on success, negative on error.
 */
    pub fn rte_eal_dev_attach(name: *const ::std::os::raw::c_char,
                              devargs: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Detach a device from its driver.
 *
 * @param name
 *   Same description as for rte_eal_dev_attach().
 *   Here, eal will call the driver detaching function.
 * @return
 *   0 on success, negative on error.
 */
    pub fn rte_eal_dev_detach(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/** Interrupt handle */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    /**< interrupt event file descriptor */
    pub fd: ::std::os::raw::c_int,
    /**< handle type */
    pub type_: rte_intr_handle_type,
    /**< max interrupt requested */
    pub max_intr: u32,
    /**< number of available efd(event fd) */
    pub nb_efd: u32,
    /**< intr vectors/efds mapping */
    pub efds: [::std::os::raw::c_int; 32usize],
    pub elist: [rte_epoll_event; 32usize],
    /**< intr vector number array */
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_intr_handle__bindgen_ty_1 {
    /**< VFIO device file descriptor */
    pub vfio_dev_fd: __BindgenUnionField<::std::os::raw::c_int>,
    /**< UIO config file descriptor
					for uio_pci_generic */
    pub uio_cfg_fd: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_intr_handle__bindgen_ty_1>() ,
               4usize);
    assert_eq! (::std::mem::align_of::<rte_intr_handle__bindgen_ty_1>() ,
                4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle__bindgen_ty_1 ) ) .
                vfio_dev_fd as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle__bindgen_ty_1 ) ) .
                uio_cfg_fd as * const _ as usize } , 0usize);
}
impl Clone for rte_intr_handle__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_intr_handle() {
    assert_eq!(::std::mem::size_of::<rte_intr_handle>() , 1696usize);
    assert_eq! (::std::mem::align_of::<rte_intr_handle>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . fd as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . type_ as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . max_intr as * const
                _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . nb_efd as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . efds as * const _
                as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . elist as * const _
                as usize } , 152usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_handle ) ) . intr_vec as * const
                _ as usize } , 1688usize);
}
impl Clone for rte_intr_handle {
    fn clone(&self) -> Self { *self }
}
/** Function to be registered for the specific interrupt */
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(intr_handle:
                                                   *mut rte_intr_handle,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_intr_handle_type {
    RTE_INTR_HANDLE_UNKNOWN = 0,
    RTE_INTR_HANDLE_UIO = 1,
    RTE_INTR_HANDLE_UIO_INTX = 2,
    RTE_INTR_HANDLE_VFIO_LEGACY = 3,
    RTE_INTR_HANDLE_VFIO_MSI = 4,
    RTE_INTR_HANDLE_VFIO_MSIX = 5,
    RTE_INTR_HANDLE_ALARM = 6,
    RTE_INTR_HANDLE_EXT = 7,
    RTE_INTR_HANDLE_MAX = 8,
}
pub type rte_intr_event_cb_t =
    ::std::option::Option<unsafe extern "C" fn(fd: ::std::os::raw::c_int,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_epoll_data {
    /**< event type */
    pub event: u32,
    /**< User data */
    pub data: *mut ::std::os::raw::c_void,
    /**< IN: callback fun */
    pub cb_fun: rte_intr_event_cb_t,
    /**< IN: callback arg */
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_epoll_data() {
    assert_eq!(::std::mem::size_of::<rte_epoll_data>() , 32usize);
    assert_eq! (::std::mem::align_of::<rte_epoll_data>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . event as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . data as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . cb_fun as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_data ) ) . cb_arg as * const _
                as usize } , 24usize);
}
impl Clone for rte_epoll_data {
    fn clone(&self) -> Self { *self }
}
pub const RTE_EPOLL_INVALID: _bindgen_ty_25 =
    _bindgen_ty_25::RTE_EPOLL_INVALID;
pub const RTE_EPOLL_VALID: _bindgen_ty_25 = _bindgen_ty_25::RTE_EPOLL_VALID;
pub const RTE_EPOLL_EXEC: _bindgen_ty_25 = _bindgen_ty_25::RTE_EPOLL_EXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    RTE_EPOLL_INVALID = 0,
    RTE_EPOLL_VALID = 1,
    RTE_EPOLL_EXEC = 2,
}
/** interrupt epoll event obj, taken by epoll_event.ptr */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_epoll_event {
    /**< OUT: event status */
    pub status: u32,
    /**< OUT: event fd */
    pub fd: ::std::os::raw::c_int,
    /**< OUT: epoll instance the ev associated with */
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
#[test]
fn bindgen_test_layout_rte_epoll_event() {
    assert_eq!(::std::mem::size_of::<rte_epoll_event>() , 48usize);
    assert_eq! (::std::mem::align_of::<rte_epoll_event>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . status as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . fd as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . epfd as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_epoll_event ) ) . epdata as * const _
                as usize } , 16usize);
}
impl Clone for rte_epoll_event {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * It waits for events on the epoll instance.
 *
 * @param epfd
 *   Epoll instance fd on which the caller wait for events.
 * @param events
 *   Memory area contains the events that will be available for the caller.
 * @param maxevents
 *   Up to maxevents are returned, must greater than zero.
 * @param timeout
 *   Specifying a timeout of -1 causes a block indefinitely.
 *   Specifying a timeout equal to zero cause to return immediately.
 * @return
 *   - On success, returns the number of available event.
 *   - On failure, a negative value.
 */
    pub fn rte_epoll_wait(epfd: ::std::os::raw::c_int,
                          events: *mut rte_epoll_event,
                          maxevents: ::std::os::raw::c_int,
                          timeout: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It performs control operations on epoll instance referred by the epfd.
 * It requests that the operation op be performed for the target fd.
 *
 * @param epfd
 *   Epoll instance fd on which the caller perform control operations.
 * @param op
 *   The operation be performed for the target fd.
 * @param fd
 *   The target fd on which the control ops perform.
 * @param event
 *   Describes the object linked to the fd.
 *   Note: The caller must take care the object deletion after CTL_DEL.
 * @return
 *   - On success, zero.
 *   - On failure, a negative value.
 */
    pub fn rte_epoll_ctl(epfd: ::std::os::raw::c_int,
                         op: ::std::os::raw::c_int, fd: ::std::os::raw::c_int,
                         event: *mut rte_epoll_event)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * The function returns the per thread epoll instance.
 *
 * @return
 *   epfd the epoll instance referred to.
 */
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @param intr_handle
 *   Pointer to the interrupt handle.
 * @param epfd
 *   Epoll instance fd which the intr vector associated to.
 * @param op
 *   The operation be performed for the vector.
 *   Operation type of {ADD, DEL}.
 * @param vec
 *   RX intr vector number added to the epoll instance wait list.
 * @param data
 *   User raw data.
 * @return
 *   - On success, zero.
 *   - On failure, a negative value.
 */
    pub fn rte_intr_rx_ctl(intr_handle: *mut rte_intr_handle,
                           epfd: ::std::os::raw::c_int,
                           op: ::std::os::raw::c_int,
                           vec: ::std::os::raw::c_uint,
                           data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It enables the packet I/O interrupt event if it's necessary.
 * It creates event fd for each interrupt vector when MSIX is used,
 * otherwise it multiplexes a single event fd.
 *
 * @param intr_handle
 *   Pointer to the interrupt handle.
 * @param nb_efd
 *   Number of interrupt vector trying to enable.
 *   The value 0 is not allowed.
 * @return
 *   - On success, zero.
 *   - On failure, a negative value.
 */
    pub fn rte_intr_efd_enable(intr_handle: *mut rte_intr_handle, nb_efd: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It disables the packet I/O interrupt event.
 * It deletes registered eventfds and closes the open fds.
 *
 * @param intr_handle
 *   Pointer to the interrupt handle.
 */
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    /**
 * The packet I/O interrupt on datapath is enabled or not.
 *
 * @param intr_handle
 *   Pointer to the interrupt handle.
 */
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * The interrupt handle instance allows other causes or not.
 * Other causes stand for any none packet I/O interrupts.
 *
 * @param intr_handle
 *   Pointer to the interrupt handle.
 */
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * The multiple interrupt vector capability of interrupt handle instance.
 * It returns zero if no multiple interrupt vector support.
 *
 * @param intr_handle
 *   Pointer to the interrupt handle.
 */
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It registers the callback for the specific interrupt. Multiple
 * callbacks cal be registered at the same time.
 * @param intr_handle
 *  Pointer to the interrupt handle.
 * @param cb
 *  callback address.
 * @param cb_arg
 *  address of parameter for callback.
 *
 * @return
 *  - On success, zero.
 *  - On failure, a negative value.
 */
    pub fn rte_intr_callback_register(intr_handle: *mut rte_intr_handle,
                                      cb: rte_intr_callback_fn,
                                      cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It unregisters the callback according to the specified interrupt handle.
 *
 * @param intr_handle
 *  pointer to the interrupt handle.
 * @param cb
 *  callback address.
 * @param cb_arg
 *  address of parameter for callback, (void *)-1 means to remove all
 *  registered which has the same callback address.
 *
 * @return
 *  - On success, return the number of callback entities removed.
 *  - On failure, a negative value.
 */
    pub fn rte_intr_callback_unregister(intr_handle: *mut rte_intr_handle,
                                        cb: rte_intr_callback_fn,
                                        cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It enables the interrupt for the specified handle.
 *
 * @param intr_handle
 *  pointer to the interrupt handle.
 *
 * @return
 *  - On success, zero.
 *  - On failure, a negative value.
 */
    pub fn rte_intr_enable(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It disables the interrupt for the specified handle.
 *
 * @param intr_handle
 *  pointer to the interrupt handle.
 *
 * @return
 *  - On success, zero.
 *  - On failure, a negative value.
 */
    pub fn rte_intr_disable(intr_handle: *mut rte_intr_handle)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_device_list {
    pub tqh_first: *mut pci_device_list_rte_pci_device,
    pub tqh_last: *mut *mut pci_device_list_rte_pci_device,
}
/**
 * A structure describing a PCI device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_device_list_rte_pci_device {
    /**< Next probed PCI device. */
    pub next: pci_device_list_rte_pci_device__bindgen_ty_1,
    /**< Inherit core device */
    pub device: rte_device_list_rte_device,
    /**< PCI location. */
    pub addr: rte_pci_addr,
    /**< PCI ID. */
    pub id: rte_pci_id,
    pub mem_resource: [rte_mem_resource; 6usize],
    /**< Interrupt handle */
    pub intr_handle: rte_intr_handle,
    /**< Associated driver */
    pub driver: *mut pci_driver_list_rte_pci_driver,
    /**< sriov enable if not zero */
    pub max_vfs: u16,
    /**< Kernel driver passthrough */
    pub kdrv: rte_kernel_driver,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_device_list_rte_pci_device__bindgen_ty_1 {
    pub tqe_next: *mut pci_device_list_rte_pci_device,
    pub tqe_prev: *mut *mut pci_device_list_rte_pci_device,
}
#[test]
fn bindgen_test_layout_pci_device_list_rte_pci_device__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pci_device_list_rte_pci_device__bindgen_ty_1>()
               , 16usize);
    assert_eq! (::std::mem::align_of::<pci_device_list_rte_pci_device__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pci_device_list_rte_pci_device__bindgen_ty_1
                ) ) . tqe_next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pci_device_list_rte_pci_device__bindgen_ty_1
                ) ) . tqe_prev as * const _ as usize } , 8usize);
}
impl Clone for pci_device_list_rte_pci_device__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pci_device_list_rte_pci_device() {
    assert_eq!(::std::mem::size_of::<pci_device_list_rte_pci_device>() ,
               1936usize);
    assert_eq! (::std::mem::align_of::<pci_device_list_rte_pci_device>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) . next
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) .
                device as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) . addr
                as * const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) . id
                as * const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) .
                mem_resource as * const _ as usize } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) .
                intr_handle as * const _ as usize } , 224usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) .
                driver as * const _ as usize } , 1920usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) .
                max_vfs as * const _ as usize } , 1928usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list_rte_pci_device ) ) . kdrv
                as * const _ as usize } , 1932usize);
}
impl Clone for pci_device_list_rte_pci_device {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pci_device_list() {
    assert_eq!(::std::mem::size_of::<pci_device_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<pci_device_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list ) ) . tqh_first as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_device_list ) ) . tqh_last as * const
                _ as usize } , 8usize);
}
impl Clone for pci_device_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_driver_list {
    pub tqh_first: *mut pci_driver_list_rte_pci_driver,
    pub tqh_last: *mut *mut pci_driver_list_rte_pci_driver,
}
/**
 * A structure describing a PCI driver.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_driver_list_rte_pci_driver {
    /**< Next in list. */
    pub next: pci_driver_list_rte_pci_driver__bindgen_ty_1,
    /**< Inherit core driver. */
    pub driver: rte_driver_list_rte_driver,
    /**< Device Probe function. */
    pub probe: pci_probe_t,
    /**< Device Remove function. */
    pub remove: pci_remove_t,
    /**< ID table, NULL terminated. */
    pub id_table: *const rte_pci_id,
    /**< Flags contolling handling of device. */
    pub drv_flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_driver_list_rte_pci_driver__bindgen_ty_1 {
    pub tqe_next: *mut pci_driver_list_rte_pci_driver,
    pub tqe_prev: *mut *mut pci_driver_list_rte_pci_driver,
}
#[test]
fn bindgen_test_layout_pci_driver_list_rte_pci_driver__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pci_driver_list_rte_pci_driver__bindgen_ty_1>()
               , 16usize);
    assert_eq! (::std::mem::align_of::<pci_driver_list_rte_pci_driver__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pci_driver_list_rte_pci_driver__bindgen_ty_1
                ) ) . tqe_next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const pci_driver_list_rte_pci_driver__bindgen_ty_1
                ) ) . tqe_prev as * const _ as usize } , 8usize);
}
impl Clone for pci_driver_list_rte_pci_driver__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pci_driver_list_rte_pci_driver() {
    assert_eq!(::std::mem::size_of::<pci_driver_list_rte_pci_driver>() ,
               80usize);
    assert_eq! (::std::mem::align_of::<pci_driver_list_rte_pci_driver>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list_rte_pci_driver ) ) . next
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list_rte_pci_driver ) ) .
                driver as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list_rte_pci_driver ) ) .
                probe as * const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list_rte_pci_driver ) ) .
                remove as * const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list_rte_pci_driver ) ) .
                id_table as * const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list_rte_pci_driver ) ) .
                drv_flags as * const _ as usize } , 72usize);
}
impl Clone for pci_driver_list_rte_pci_driver {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pci_driver_list() {
    assert_eq!(::std::mem::size_of::<pci_driver_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<pci_driver_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list ) ) . tqh_first as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_driver_list ) ) . tqh_last as * const
                _ as usize } , 8usize);
}
impl Clone for pci_driver_list {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure describing an ID for a PCI driver. Each driver provides a
 * table of these IDs for each device that it supports.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_id {
    /**< Class ID (class, subclass, pi) or RTE_CLASS_ANY_ID. */
    pub class_id: u32,
    /**< Vendor ID or PCI_ANY_ID. */
    pub vendor_id: u16,
    /**< Device ID or PCI_ANY_ID. */
    pub device_id: u16,
    /**< Subsystem vendor ID or PCI_ANY_ID. */
    pub subsystem_vendor_id: u16,
    /**< Subsystem device ID or PCI_ANY_ID. */
    pub subsystem_device_id: u16,
}
#[test]
fn bindgen_test_layout_rte_pci_id() {
    assert_eq!(::std::mem::size_of::<rte_pci_id>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_pci_id>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . class_id as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . vendor_id as * const _
                as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . device_id as * const _
                as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . subsystem_vendor_id as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_id ) ) . subsystem_device_id as *
                const _ as usize } , 10usize);
}
impl Clone for rte_pci_id {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure describing the location of a PCI device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_addr {
    /**< Device domain */
    pub domain: u16,
    /**< Device bus */
    pub bus: u8,
    /**< Device ID */
    pub devid: u8,
    /**< Device function. */
    pub function: u8,
}
#[test]
fn bindgen_test_layout_rte_pci_addr() {
    assert_eq!(::std::mem::size_of::<rte_pci_addr>() , 6usize);
    assert_eq! (::std::mem::align_of::<rte_pci_addr>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . domain as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . bus as * const _ as
                usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . devid as * const _ as
                usize } , 3usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_addr ) ) . function as * const _
                as usize } , 4usize);
}
impl Clone for rte_pci_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_kernel_driver {
    RTE_KDRV_UNKNOWN = 0,
    RTE_KDRV_IGB_UIO = 1,
    RTE_KDRV_VFIO = 2,
    RTE_KDRV_UIO_GENERIC = 3,
    RTE_KDRV_NIC_UIO = 4,
    RTE_KDRV_NONE = 5,
}
/**
 * Initialisation function for the driver called during PCI probing.
 */
pub type pci_probe_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut pci_driver_list_rte_pci_driver,
                                               arg2:
                                                   *mut pci_device_list_rte_pci_device)
                              -> ::std::os::raw::c_int>;
/**
 * Uninitialisation function for the driver called during hotplugging.
 */
pub type pci_remove_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut pci_device_list_rte_pci_device)
                              -> ::std::os::raw::c_int>;
/**
 * A structure describing a PCI mapping.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_map {
    pub addr: *mut ::std::os::raw::c_void,
    pub path: *mut ::std::os::raw::c_char,
    pub offset: u64,
    pub size: u64,
    pub phaddr: u64,
}
#[test]
fn bindgen_test_layout_pci_map() {
    assert_eq!(::std::mem::size_of::<pci_map>() , 40usize);
    assert_eq! (::std::mem::align_of::<pci_map>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . addr as * const _ as usize
                } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . path as * const _ as usize
                } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . offset as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . size as * const _ as usize
                } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . phaddr as * const _ as
                usize } , 32usize);
}
impl Clone for pci_map {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Scan the content of the PCI bus, and the devices in the devices
 * list
 *
 * @return
 *  0 on success, negative on error
 */
    pub fn rte_eal_pci_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Probe the PCI bus for registered drivers.
 *
 * Scan the content of the PCI bus, and call the probe() function for
 * all registered drivers that have a matching entry in its id_table
 * for discovered devices.
 *
 * @return
 *   - 0 on success.
 *   - Negative on error.
 */
    pub fn rte_eal_pci_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Map the PCI device resources in user space virtual memory address
 *
 * Note that driver should not call this function when flag
 * RTE_PCI_DRV_NEED_MAPPING is set, as EAL will do that for
 * you when it's on.
 *
 * @param dev
 *   A pointer to a rte_pci_device structure describing the device
 *   to use
 *
 * @return
 *   0 on success, negative on error and positive if no driver
 *   is found for the device.
 */
    pub fn rte_eal_pci_map_device(dev: *mut pci_device_list_rte_pci_device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Unmap this device
 *
 * @param dev
 *   A pointer to a rte_pci_device structure describing the device
 *   to use
 */
    pub fn rte_eal_pci_unmap_device(dev: *mut pci_device_list_rte_pci_device);
}
extern "C" {
    /**
 * Probe the single PCI device.
 *
 * Scan the content of the PCI bus, and find the pci device specified by pci
 * address, then call the probe() function for registered driver that has a
 * matching entry in its id_table for discovered device.
 *
 * @param addr
 *	The PCI Bus-Device-Function address to probe.
 * @return
 *   - 0 on success.
 *   - Negative on error.
 */
    pub fn rte_eal_pci_probe_one(addr: *const rte_pci_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Close the single PCI device.
 *
 * Scan the content of the PCI bus, and find the pci device specified by pci
 * address, then call the remove() function for registered driver that has a
 * matching entry in its id_table for discovered device.
 *
 * @param addr
 *	The PCI Bus-Device-Function address to close.
 * @return
 *   - 0 on success.
 *   - Negative on error.
 */
    pub fn rte_eal_pci_detach(addr: *const rte_pci_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Dump the content of the PCI bus.
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_eal_pci_dump(f: *mut FILE);
}
extern "C" {
    /**
 * Register a PCI driver.
 *
 * @param driver
 *   A pointer to a rte_pci_driver structure describing the driver
 *   to be registered.
 */
    pub fn rte_eal_pci_register(driver: *mut pci_driver_list_rte_pci_driver);
}
extern "C" {
    /**
 * Unregister a PCI driver.
 *
 * @param driver
 *   A pointer to a rte_pci_driver structure describing the driver
 *   to be unregistered.
 */
    pub fn rte_eal_pci_unregister(driver:
                                      *mut pci_driver_list_rte_pci_driver);
}
extern "C" {
    /**
 * Read PCI config space.
 *
 * @param device
 *   A pointer to a rte_pci_device structure describing the device
 *   to use
 * @param buf
 *   A data buffer where the bytes should be read into
 * @param len
 *   The length of the data buffer.
 * @param offset
 *   The offset into PCI config space
 */
    pub fn rte_eal_pci_read_config(device:
                                       *const pci_device_list_rte_pci_device,
                                   buf: *mut ::std::os::raw::c_void,
                                   len: usize, offset: off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Write PCI config space.
 *
 * @param device
 *   A pointer to a rte_pci_device structure describing the device
 *   to use
 * @param buf
 *   A data buffer containing the bytes should be written
 * @param len
 *   The length of the data buffer.
 * @param offset
 *   The offset into PCI config space
 */
    pub fn rte_eal_pci_write_config(device:
                                        *const pci_device_list_rte_pci_device,
                                    buf: *const ::std::os::raw::c_void,
                                    len: usize, offset: off_t)
     -> ::std::os::raw::c_int;
}
/**
 * A structure used to access io resources for a pci device.
 * rte_pci_ioport is arch, os, driver specific, and should not be used outside
 * of pci ioport api.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pci_ioport {
    pub dev: *mut pci_device_list_rte_pci_device,
    pub base: u64,
    pub len: u64,
}
#[test]
fn bindgen_test_layout_rte_pci_ioport() {
    assert_eq!(::std::mem::size_of::<rte_pci_ioport>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_pci_ioport>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_ioport ) ) . dev as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_ioport ) ) . base as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pci_ioport ) ) . len as * const _ as
                usize } , 16usize);
}
impl Clone for rte_pci_ioport {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Initialize a rte_pci_ioport object for a pci device io resource.
 *
 * This object is then used to gain access to those io resources (see below).
 *
 * @param dev
 *   A pointer to a rte_pci_device structure describing the device
 *   to use.
 * @param bar
 *   Index of the io pci resource we want to access.
 * @param p
 *   The rte_pci_ioport object to be initialized.
 * @return
 *  0 on success, negative on error.
 */
    pub fn rte_eal_pci_ioport_map(dev: *mut pci_device_list_rte_pci_device,
                                  bar: ::std::os::raw::c_int,
                                  p: *mut rte_pci_ioport)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Release any resources used in a rte_pci_ioport object.
 *
 * @param p
 *   The rte_pci_ioport object to be uninitialized.
 * @return
 *  0 on success, negative on error.
 */
    pub fn rte_eal_pci_ioport_unmap(p: *mut rte_pci_ioport)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read from a io pci resource.
 *
 * @param p
 *   The rte_pci_ioport object from which we want to read.
 * @param data
 *   A data buffer where the bytes should be read into
 * @param len
 *   The length of the data buffer.
 * @param offset
 *   The offset into the pci io resource.
 */
    pub fn rte_eal_pci_ioport_read(p: *mut rte_pci_ioport,
                                   data: *mut ::std::os::raw::c_void,
                                   len: usize, offset: off_t);
}
extern "C" {
    /**
 * Write to a io pci resource.
 *
 * @param p
 *   The rte_pci_ioport object to which we want to write.
 * @param data
 *   A data buffer where the bytes should be read into
 * @param len
 *   The length of the data buffer.
 * @param offset
 *   The offset into the pci io resource.
 */
    pub fn rte_eal_pci_ioport_write(p: *mut rte_pci_ioport,
                                    data: *const ::std::os::raw::c_void,
                                    len: usize, offset: off_t);
}
#[repr(u32)]
/**
 * Type of generic device
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_devtype {
    RTE_DEVTYPE_WHITELISTED_PCI = 0,
    RTE_DEVTYPE_BLACKLISTED_PCI = 1,
    RTE_DEVTYPE_VIRTUAL = 2,
}
/** user device double-linked queue type definition */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_devargs_list {
    pub tqh_first: *mut rte_device_list_rte_device_rte_devargs,
    pub tqh_last: *mut *mut rte_device_list_rte_device_rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs_list() {
    assert_eq!(::std::mem::size_of::<rte_devargs_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_devargs_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs_list ) ) . tqh_first as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_devargs_list ) ) . tqh_last as *
                const _ as usize } , 8usize);
}
impl Clone for rte_devargs_list {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Parse a devargs string.
 *
 * For PCI devices, the format of arguments string is "PCI_ADDR" or
 * "PCI_ADDR,key=val,key2=val2,...". Examples: "08:00.1", "0000:5:00.0",
 * "04:00.0,arg=val".
 *
 * For virtual devices, the format of arguments string is "DRIVER_NAME*"
 * or "DRIVER_NAME*,key=val,key2=val2,...". Examples: "net_ring",
 * "net_ring0", "net_pmdAnything,arg=0:arg2=1".
 *
 * The function parses the arguments string to get driver name and driver
 * arguments.
 *
 * @param devargs_str
 *   The arguments as given by the user.
 * @param drvname
 *   The pointer to the string to store parsed driver name.
 * @param drvargs
 *   The pointer to the string to store parsed driver arguments.
 *
 * @return
 *   - 0 on success
 *   - A negative value on error
 */
    pub fn rte_eal_parse_devargs_str(devargs_str:
                                         *const ::std::os::raw::c_char,
                                     drvname:
                                         *mut *mut ::std::os::raw::c_char,
                                     drvargs:
                                         *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add a device to the user device list
 *
 * For PCI devices, the format of arguments string is "PCI_ADDR" or
 * "PCI_ADDR,key=val,key2=val2,...". Examples: "08:00.1", "0000:5:00.0",
 * "04:00.0,arg=val".
 *
 * For virtual devices, the format of arguments string is "DRIVER_NAME*"
 * or "DRIVER_NAME*,key=val,key2=val2,...". Examples: "net_ring",
 * "net_ring0", "net_pmdAnything,arg=0:arg2=1". The validity of the
 * driver name is not checked by this function, it is done when probing
 * the drivers.
 *
 * @param devtype
 *   The type of the device.
 * @param devargs_str
 *   The arguments as given by the user.
 *
 * @return
 *   - 0 on success
 *   - A negative value on error
 */
    pub fn rte_eal_devargs_add(devtype: rte_devtype,
                               devargs_str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Count the number of user devices of a specified type
 *
 * @param devtype
 *   The type of the devices to counted.
 *
 * @return
 *   The number of devices.
 */
    pub fn rte_eal_devargs_type_count(devtype: rte_devtype)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * This function dumps the list of user device and their arguments.
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_eal_devargs_dump(f: *mut FILE);
}
/** dummy structure type used by the rte_tailq APIs */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_entry {
    /**< Pointer entries for a tailq list */
    pub next: rte_tailq_entry__bindgen_ty_1,
    /**< Pointer to the data referenced by this tailq entry */
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_entry__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_entry,
    pub tqe_prev: *mut *mut rte_tailq_entry,
}
#[test]
fn bindgen_test_layout_rte_tailq_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tailq_entry__bindgen_ty_1>() ,
               16usize);
    assert_eq! (::std::mem::align_of::<rte_tailq_entry__bindgen_ty_1>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize);
}
impl Clone for rte_tailq_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tailq_entry() {
    assert_eq!(::std::mem::size_of::<rte_tailq_entry>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_tailq_entry>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry ) ) . next as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry ) ) . data as * const _
                as usize } , 16usize);
}
impl Clone for rte_tailq_entry {
    fn clone(&self) -> Self { *self }
}
/** dummy */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_entry_head {
    pub tqh_first: *mut rte_tailq_entry,
    pub tqh_last: *mut *mut rte_tailq_entry,
}
#[test]
fn bindgen_test_layout_rte_tailq_entry_head() {
    assert_eq!(::std::mem::size_of::<rte_tailq_entry_head>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_tailq_entry_head>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry_head ) ) . tqh_first as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_entry_head ) ) . tqh_last as *
                const _ as usize } , 8usize);
}
impl Clone for rte_tailq_entry_head {
    fn clone(&self) -> Self { *self }
}
/**
 * The structure defining a tailq header entry for storing
 * in the rte_config structure in shared memory. Each tailq
 * is identified by name.
 * Any library storing a set of objects e.g. rings, mempools, hash-tables,
 * is recommended to use an entry here, so as to make it easy for
 * a multi-process app to find already-created elements in shared memory.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_head {
    /**< NOTE: must be first element */
    pub tailq_head: rte_tailq_entry_head,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_rte_tailq_head() {
    assert_eq!(::std::mem::size_of::<rte_tailq_head>() , 48usize);
    assert_eq! (::std::mem::align_of::<rte_tailq_head>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_head ) ) . tailq_head as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_head ) ) . name as * const _ as
                usize } , 16usize);
}
impl Clone for rte_tailq_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_elem {
    /**
	 * Reference to head in shared mem, updated at init time by
	 * rte_eal_tailqs_init()
	 */
    pub head: *mut rte_tailq_head,
    pub next: rte_tailq_elem__bindgen_ty_1,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_tailq_elem__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_elem,
    pub tqe_prev: *mut *mut rte_tailq_elem,
}
#[test]
fn bindgen_test_layout_rte_tailq_elem__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_tailq_elem__bindgen_ty_1>() ,
               16usize);
    assert_eq! (::std::mem::align_of::<rte_tailq_elem__bindgen_ty_1>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize);
}
impl Clone for rte_tailq_elem__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_tailq_elem() {
    assert_eq!(::std::mem::size_of::<rte_tailq_elem>() , 56usize);
    assert_eq! (::std::mem::align_of::<rte_tailq_elem>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem ) ) . head as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem ) ) . next as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_tailq_elem ) ) . name as * const _ as
                usize } , 24usize);
}
impl Clone for rte_tailq_elem {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Dump tail queues to a file.
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_dump_tailq(f: *mut FILE);
}
extern "C" {
    /**
 * Lookup for a tail queue.
 *
 * Get a pointer to a tail queue header of a tail
 * queue identified by the name given as an argument.
 * Note: this function is not multi-thread safe, and should only be called from
 * a single thread at a time
 *
 * @param name
 *   The name of the queue.
 * @return
 *   A pointer to the tail queue head structure.
 */
    pub fn rte_eal_tailq_lookup(name: *const ::std::os::raw::c_char)
     -> *mut rte_tailq_head;
}
extern "C" {
    /**
 * Register a tail queue.
 *
 * Register a tail queue from shared memory.
 * This function is mainly used by EAL_REGISTER_TAILQ macro which is used to
 * register tailq from the different dpdk libraries. Since this macro is a
 * constructor, the function has no access to dpdk shared memory, so the
 * registered tailq can not be used before call to rte_eal_init() which calls
 * rte_eal_tailqs_init().
 *
 * @param t
 *   The tailq element which contains the name of the tailq you want to
 *   create (/retrieve when in secondary process).
 * @return
 *   0 on success or -1 in case of an error.
 */
    pub fn rte_eal_tailq_register(t: *mut rte_tailq_elem)
     -> ::std::os::raw::c_int;
}
#[repr(u64)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_page_sizes {
    RTE_PGSIZE_4K = 4096,
    RTE_PGSIZE_64K = 65536,
    RTE_PGSIZE_256K = 262144,
    RTE_PGSIZE_2M = 2097152,
    RTE_PGSIZE_16M = 16777216,
    RTE_PGSIZE_256M = 268435456,
    RTE_PGSIZE_512M = 536870912,
    RTE_PGSIZE_1G = 1073741824,
    RTE_PGSIZE_4G = 4294967296,
    RTE_PGSIZE_16G = 17179869184,
}
pub type phys_addr_t = u64;
/**
 * Physical memory segment descriptor.
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_memseg {
    /**< Start physical address. */
    pub phys_addr: phys_addr_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    /**< Length of the segment. */
    pub len: usize,
    /**< The pagesize of underlying memory */
    pub hugepage_sz: u64,
    /**< NUMA socket ID. */
    pub socket_id: i32,
    /**< Number of channels. */
    pub nchannel: u32,
    /**< Number of ranks. */
    pub nrank: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_memseg__bindgen_ty_1 {
    /**< Start virtual address. */
    pub addr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /**< Makes sure addr is always 64 bits */
    pub addr_64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_memseg__bindgen_ty_1>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_memseg__bindgen_ty_1>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg__bindgen_ty_1 ) ) . addr as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg__bindgen_ty_1 ) ) . addr_64 as
                * const _ as usize } , 0usize);
}
impl Clone for rte_memseg__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    assert_eq!(::std::mem::size_of::<rte_memseg>() , 44usize);
    assert_eq! (::std::mem::align_of::<rte_memseg>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . phys_addr as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . len as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . hugepage_sz as * const _
                as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . socket_id as * const _
                as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . nchannel as * const _ as
                usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memseg ) ) . nrank as * const _ as
                usize } , 40usize);
}
impl Clone for rte_memseg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Lock page in physical memory and prevent from swapping.
 *
 * @param virt
 *   The virtual address.
 * @return
 *   0 on success, negative on error.
 */
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get physical address of any mapped virtual address in the current process.
 * It is found by browsing the /proc/self/pagemap special file.
 * The page must be locked.
 *
 * @param virt
 *   The virtual address.
 * @return
 *   The physical address or RTE_BAD_PHYS_ADDR on error.
 */
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void)
     -> phys_addr_t;
}
extern "C" {
    /**
 * Get the layout of the available physical memory.
 *
 * It can be useful for an application to have the full physical
 * memory layout to decide the size of a memory zone to reserve. This
 * table is stored in rte_config (see rte_eal_get_configuration()).
 *
 * @return
 *  - On success, return a pointer to a read-only table of struct
 *    rte_physmem_desc elements, containing the layout of all
 *    addressable physical memory. The last element of the table
 *    contains a NULL address.
 *  - On error, return NULL. This should not happen since it is a fatal
 *    error that will probably cause the entire system to panic.
 */
    pub fn rte_eal_get_physmem_layout() -> *const rte_memseg;
}
extern "C" {
    /**
 * Dump the physical memory layout to a file.
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    /**
 * Get the total amount of available physical memory.
 *
 * @return
 *    The total amount of available physical memory in bytes.
 */
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    /**
 * Get the number of memory channels.
 *
 * @return
 *   The number of memory channels on the system. The value is 0 if unknown
 *   or not the same on all devices.
 */
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * Get the number of memory ranks.
 *
 * @return
 *   The number of memory ranks on the system. The value is 0 if unknown or
 *   not the same on all devices.
 */
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
/**
 * A structure describing a memzone, which is a contiguous portion of
 * physical memory identified by a name.
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_memzone {
    /**< Name of the memory zone. */
    pub name: [::std::os::raw::c_char; 32usize],
    /**< Start physical address. */
    pub phys_addr: phys_addr_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    /**< Length of the memzone. */
    pub len: usize,
    /**< The page size of underlying memory */
    pub hugepage_sz: u64,
    /**< NUMA socket ID. */
    pub socket_id: i32,
    /**< Characteristics of this memzone. */
    pub flags: u32,
    /**< Memseg it belongs. */
    pub memseg_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_memzone__bindgen_ty_1 {
    /**< Start virtual address. */
    pub addr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /**< Makes sure addr is always 64-bits */
    pub addr_64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_memzone__bindgen_ty_1>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_memzone__bindgen_ty_1>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone__bindgen_ty_1 ) ) . addr as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone__bindgen_ty_1 ) ) . addr_64
                as * const _ as usize } , 0usize);
}
impl Clone for rte_memzone__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    assert_eq!(::std::mem::size_of::<rte_memzone>() , 76usize);
    assert_eq! (::std::mem::align_of::<rte_memzone>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . name as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . phys_addr as * const _
                as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . len as * const _ as
                usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . hugepage_sz as * const
                _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . socket_id as * const _
                as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . flags as * const _ as
                usize } , 68usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_memzone ) ) . memseg_id as * const _
                as usize } , 72usize);
}
impl Clone for rte_memzone {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Reserve a portion of physical memory.
 *
 * This function reserves some memory and returns a pointer to a
 * correctly filled memzone descriptor. If the allocation cannot be
 * done, return NULL.
 *
 * @param name
 *   The name of the memzone. If it already exists, the function will
 *   fail and return NULL.
 * @param len
 *   The size of the memory to be reserved. If it
 *   is 0, the biggest contiguous zone will be reserved.
 * @param socket_id
 *   The socket identifier in the case of
 *   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   The flags parameter is used to request memzones to be
 *   taken from specifically sized hugepages.
 *   - RTE_MEMZONE_2MB - Reserved from 2MB pages
 *   - RTE_MEMZONE_1GB - Reserved from 1GB pages
 *   - RTE_MEMZONE_16MB - Reserved from 16MB pages
 *   - RTE_MEMZONE_16GB - Reserved from 16GB pages
 *   - RTE_MEMZONE_256KB - Reserved from 256KB pages
 *   - RTE_MEMZONE_256MB - Reserved from 256MB pages
 *   - RTE_MEMZONE_512MB - Reserved from 512MB pages
 *   - RTE_MEMZONE_4GB - Reserved from 4GB pages
 *   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
 *                                  the requested page size is unavailable.
 *                                  If this flag is not set, the function
 *                                  will return error on an unavailable size
 *                                  request.
 * @return
 *   A pointer to a correctly-filled read-only memzone descriptor, or NULL
 *   on error.
 *   On error case, rte_errno will be set appropriately:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 *    - EINVAL - invalid parameters
 */
    pub fn rte_memzone_reserve(name: *const ::std::os::raw::c_char,
                               len: usize, socket_id: ::std::os::raw::c_int,
                               flags: ::std::os::raw::c_uint)
     -> *const rte_memzone;
}
extern "C" {
    /**
 * Reserve a portion of physical memory with alignment on a specified
 * boundary.
 *
 * This function reserves some memory with alignment on a specified
 * boundary, and returns a pointer to a correctly filled memzone
 * descriptor. If the allocation cannot be done or if the alignment
 * is not a power of 2, returns NULL.
 *
 * @param name
 *   The name of the memzone. If it already exists, the function will
 *   fail and return NULL.
 * @param len
 *   The size of the memory to be reserved. If it
 *   is 0, the biggest contiguous zone will be reserved.
 * @param socket_id
 *   The socket identifier in the case of
 *   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   The flags parameter is used to request memzones to be
 *   taken from specifically sized hugepages.
 *   - RTE_MEMZONE_2MB - Reserved from 2MB pages
 *   - RTE_MEMZONE_1GB - Reserved from 1GB pages
 *   - RTE_MEMZONE_16MB - Reserved from 16MB pages
 *   - RTE_MEMZONE_16GB - Reserved from 16GB pages
 *   - RTE_MEMZONE_256KB - Reserved from 256KB pages
 *   - RTE_MEMZONE_256MB - Reserved from 256MB pages
 *   - RTE_MEMZONE_512MB - Reserved from 512MB pages
 *   - RTE_MEMZONE_4GB - Reserved from 4GB pages
 *   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
 *                                  the requested page size is unavailable.
 *                                  If this flag is not set, the function
 *                                  will return error on an unavailable size
 *                                  request.
 * @param align
 *   Alignment for resulting memzone. Must be a power of 2.
 * @return
 *   A pointer to a correctly-filled read-only memzone descriptor, or NULL
 *   on error.
 *   On error case, rte_errno will be set appropriately:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 *    - EINVAL - invalid parameters
 */
    pub fn rte_memzone_reserve_aligned(name: *const ::std::os::raw::c_char,
                                       len: usize,
                                       socket_id: ::std::os::raw::c_int,
                                       flags: ::std::os::raw::c_uint,
                                       align: ::std::os::raw::c_uint)
     -> *const rte_memzone;
}
extern "C" {
    /**
 * Reserve a portion of physical memory with specified alignment and
 * boundary.
 *
 * This function reserves some memory with specified alignment and
 * boundary, and returns a pointer to a correctly filled memzone
 * descriptor. If the allocation cannot be done or if the alignment
 * or boundary are not a power of 2, returns NULL.
 * Memory buffer is reserved in a way, that it wouldn't cross specified
 * boundary. That implies that requested length should be less or equal
 * then boundary.
 *
 * @param name
 *   The name of the memzone. If it already exists, the function will
 *   fail and return NULL.
 * @param len
 *   The size of the memory to be reserved. If it
 *   is 0, the biggest contiguous zone will be reserved.
 * @param socket_id
 *   The socket identifier in the case of
 *   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   The flags parameter is used to request memzones to be
 *   taken from specifically sized hugepages.
 *   - RTE_MEMZONE_2MB - Reserved from 2MB pages
 *   - RTE_MEMZONE_1GB - Reserved from 1GB pages
 *   - RTE_MEMZONE_16MB - Reserved from 16MB pages
 *   - RTE_MEMZONE_16GB - Reserved from 16GB pages
 *   - RTE_MEMZONE_256KB - Reserved from 256KB pages
 *   - RTE_MEMZONE_256MB - Reserved from 256MB pages
 *   - RTE_MEMZONE_512MB - Reserved from 512MB pages
 *   - RTE_MEMZONE_4GB - Reserved from 4GB pages
 *   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
 *                                  the requested page size is unavailable.
 *                                  If this flag is not set, the function
 *                                  will return error on an unavailable size
 *                                  request.
 * @param align
 *   Alignment for resulting memzone. Must be a power of 2.
 * @param bound
 *   Boundary for resulting memzone. Must be a power of 2 or zero.
 *   Zero value implies no boundary condition.
 * @return
 *   A pointer to a correctly-filled read-only memzone descriptor, or NULL
 *   on error.
 *   On error case, rte_errno will be set appropriately:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 *    - EINVAL - invalid parameters
 */
    pub fn rte_memzone_reserve_bounded(name: *const ::std::os::raw::c_char,
                                       len: usize,
                                       socket_id: ::std::os::raw::c_int,
                                       flags: ::std::os::raw::c_uint,
                                       align: ::std::os::raw::c_uint,
                                       bound: ::std::os::raw::c_uint)
     -> *const rte_memzone;
}
extern "C" {
    /**
 * Free a memzone.
 *
 * @param mz
 *   A pointer to the memzone
 * @return
 *  -EINVAL - invalid parameter.
 *  0 - success
 */
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Lookup for a memzone.
 *
 * Get a pointer to a descriptor of an already reserved memory
 * zone identified by the name given as an argument.
 *
 * @param name
 *   The name of the memzone.
 * @return
 *   A pointer to a read-only memzone descriptor.
 */
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char)
     -> *const rte_memzone;
}
extern "C" {
    /**
 * Dump all reserved memzones to a file.
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    /**
 * Walk list of all memzones
 *
 * @param func
 *   Iterator function
 * @param arg
 *   Argument passed to iterator
 */
    pub fn rte_memzone_walk(func:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const rte_memzone,
                                                                           arg:
                                                                               *mut ::std::os::raw::c_void)>,
                            arg: *mut ::std::os::raw::c_void);
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_27 {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_27() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_27>() , 128usize);
    assert_eq! (::std::mem::align_of::<_bindgen_ty_27>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_27 ) ) . __bits as * const _
                as usize } , 0usize);
}
impl Clone for _bindgen_ty_27 {
    fn clone(&self) -> Self { *self }
}
pub type cpu_set_t = _bindgen_ty_27;
#[repr(u32)]
/**
 * The lcore role (used in RTE or not).
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_lcore_role_t { ROLE_RTE = 0, ROLE_OFF = 1, }
#[repr(i32)]
/**
 * The type of process in a linuxapp, multi-process setup
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_proc_type_t {
    RTE_PROC_AUTO = -1,
    RTE_PROC_PRIMARY = 0,
    RTE_PROC_SECONDARY = 1,
    RTE_PROC_INVALID = 2,
}
/**
 * The global RTE configuration structure.
 */
#[repr(C, packed)]
pub struct rte_config {
    /**< Id of the master lcore */
    pub master_lcore: u32,
    /**< Number of available logical cores. */
    pub lcore_count: u32,
    /**< State of cores. */
    pub lcore_role: [rte_lcore_role_t; 128usize],
    /** Primary or secondary configuration */
    pub process_type: rte_proc_type_t,
    /**
	 * Pointer to memory configuration, which may be shared across multiple
	 * DPDK instances
	 */
    pub mem_config: *mut rte_config_rte_mem_config,
}
/**
 * the structure for the memory configuration for the RTE.
 * Used by the rte_config structure. It is separated out, as for multi-process
 * support, the memory details should be shared across instances
 */
#[repr(C, packed)]
pub struct rte_config_rte_mem_config {
    /**< Magic number - Sanity check. */
    pub magic: u32,
    /**< Number of channels (0 if unknown). */
    pub nchannel: u32,
    /**< Number of ranks (0 if unknown). */
    pub nrank: u32,
    /**< only used by memzone LIB for thread-safe. */
    pub mlock: rte_rwlock_t,
    /**< used for tailq operation for thread safe. */
    pub qlock: rte_rwlock_t,
    /**< only used by mempool LIB for thread-safe. */
    pub mplock: rte_rwlock_t,
    /**< Number of allocated memzones */
    pub memzone_cnt: u32,
    /**< Physmem descriptors. */
    pub memseg: [rte_memseg; 256usize],
    /**< Memzone descriptors. */
    pub memzone: [rte_memzone; 2560usize],
    /**< Tailqs for objects */
    pub tailq_head: [rte_tailq_head; 32usize],
    pub malloc_heaps: [malloc_heap; 8usize],
    pub mem_cfg_addr: u64,
}
#[test]
fn bindgen_test_layout_rte_config_rte_mem_config() {
    assert_eq!(::std::mem::size_of::<rte_config_rte_mem_config>() ,
               208420usize);
    assert_eq! (::std::mem::align_of::<rte_config_rte_mem_config>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . magic as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . nchannel
                as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . nrank as
                * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . mlock as
                * const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . qlock as
                * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . mplock as
                * const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) .
                memzone_cnt as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . memseg as
                * const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) . memzone
                as * const _ as usize } , 11292usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) .
                tailq_head as * const _ as usize } , 205852usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) .
                malloc_heaps as * const _ as usize } , 207388usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config_rte_mem_config ) ) .
                mem_cfg_addr as * const _ as usize } , 208412usize);
}
#[test]
fn bindgen_test_layout_rte_config() {
    assert_eq!(::std::mem::size_of::<rte_config>() , 532usize);
    assert_eq! (::std::mem::align_of::<rte_config>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . master_lcore as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . lcore_count as * const _
                as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . lcore_role as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . process_type as * const
                _ as usize } , 520usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_config ) ) . mem_config as * const _
                as usize } , 524usize);
}
extern "C" {
    /**
 * Get the global configuration structure.
 *
 * @return
 *   A pointer to the global configuration structure.
 */
    pub fn rte_eal_get_configuration() -> *mut rte_config;
}
extern "C" {
    /**
 * Get a lcore's role.
 *
 * @param lcore_id
 *   The identifier of the lcore.
 * @return
 *   The role of the lcore.
 */
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint)
     -> rte_lcore_role_t;
}
extern "C" {
    /**
 * Get the process type in a multi-process setup
 *
 * @return
 *   The process type
 */
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
extern "C" {
    /**
 * Request iopl privilege for all RPL.
 *
 * This function should be called by pmds which need access to ioports.

 * @return
 *   - On success, returns 0.
 *   - On failure, returns -1.
 */
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Initialize the Environment Abstraction Layer (EAL).
 *
 * This function is to be executed on the MASTER lcore only, as soon
 * as possible in the application's main() function.
 *
 * The function finishes the initialization process before main() is called.
 * It puts the SLAVE lcores in the WAIT state.
 *
 * When the multi-partition feature is supported, depending on the
 * configuration (if CONFIG_RTE_EAL_MAIN_PARTITION is disabled), this
 * function waits to ensure that the magic number is set before
 * returning. See also the rte_eal_get_configuration() function. Note:
 * This behavior may change in the future.
 *
 * @param argc
 *   The argc argument that was given to the main() function.
 * @param argv
 *   The argv argument that was given to the main() function.
 * @return
 *   - On success, the number of parsed arguments, which is greater or
 *     equal to zero. After the call to rte_eal_init(),
 *     all arguments argv[x] with x < ret may be modified and should
 *     not be accessed by the application.
 *   - On failure, a negative error value.
 */
    pub fn rte_eal_init(argc: ::std::os::raw::c_int,
                        argv: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Check if a primary process is currently alive
 *
 * This function returns true when a primary process is currently
 * active.
 *
 * @param config_file_path
 *   The config_file_path argument provided should point at the location
 *   that the primary process will create its config file. If NULL, the default
 *   config file path is used.
 *
 * @return
 *  - If alive, returns 1.
 *  - If dead, returns 0.
 */
    pub fn rte_eal_primary_proc_alive(config_file_path:
                                          *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/**
 * Usage function typedef used by the application usage function.
 *
 * Use this function typedef to define and call rte_set_applcation_usage_hook()
 * routine.
 */
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    /**
 * Add application usage routine callout from the eal_usage() routine.
 *
 * This function allows the application to include its usage message
 * in the EAL system usage message. The routine rte_set_application_usage_hook()
 * needs to be called before the rte_eal_init() routine in the application.
 *
 * This routine is optional for the application and will behave as if the set
 * routine was never called as the default behavior.
 *
 * @param usage_func
 *   The func argument is a function pointer to the application usage routine.
 *   Called function is defined using rte_usage_hook_t typedef, which is of
 *   the form void rte_usage_func(const char * prgname).
 *
 *   Calling this routine with a NULL value will reset the usage hook routine and
 *   return the current value, which could be NULL.
 * @return
 *   - Returns the current value of the rte_application_usage pointer to allow
 *     the caller to daisy chain the usage routines if needing more then one.
 */
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t)
     -> rte_usage_hook_t;
}
extern "C" {
    /**
 * Whether EAL is using huge pages (disabled by --no-huge option).
 * The no-huge mode cannot be used with UIO poll-mode drivers like igb/ixgbe.
 * It is useful for NIC drivers (e.g. librte_pmd_mlx4, librte_pmd_vmxnet3) or
 * crypto drivers (e.g. librte_crypto_nitrox) provided by third-parties such
 * as 6WIND.
 *
 * @return
 *   Nonzero if hugepages are enabled.
 */
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * A wrap API for syscall gettid.
 *
 * @return
 *   On success, returns the thread ID of calling process.
 *   It is always successful.
 */
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
#[repr(u32)]
/**
 * State of an lcore.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_lcore_state_t { WAIT = 0, RUNNING = 1, FINISHED = 2, }
/**
 * Definition of a remote launch function.
 */
pub type lcore_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /**
 * Launch a function on another lcore.
 *
 * To be executed on the MASTER lcore only.
 *
 * Sends a message to a slave lcore (identified by the slave_id) that
 * is in the WAIT state (this is true after the first call to
 * rte_eal_init()). This can be checked by first calling
 * rte_eal_wait_lcore(slave_id).
 *
 * When the remote lcore receives the message, it switches to
 * the RUNNING state, then calls the function f with argument arg. Once the
 * execution is done, the remote lcore switches to a FINISHED state and
 * the return value of f is stored in a local variable to be read using
 * rte_eal_wait_lcore().
 *
 * The MASTER lcore returns as soon as the message is sent and knows
 * nothing about the completion of f.
 *
 * Note: This function is not designed to offer optimum
 * performance. It is just a practical way to launch a function on
 * another lcore at initialization time.
 *
 * @param f
 *   The function to be called.
 * @param arg
 *   The argument for the function.
 * @param slave_id
 *   The identifier of the lcore on which the function should be executed.
 * @return
 *   - 0: Success. Execution of function f started on the remote lcore.
 *   - (-EBUSY): The remote lcore is not in a WAIT state.
 */
    pub fn rte_eal_remote_launch(f: lcore_function_t,
                                 arg: *mut ::std::os::raw::c_void,
                                 slave_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/**
 * This enum indicates whether the master core must execute the handler
 * launched on all logical cores.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_rmt_call_master_t { SKIP_MASTER = 0, CALL_MASTER = 1, }
extern "C" {
    /**
 * Launch a function on all lcores.
 *
 * Check that each SLAVE lcore is in a WAIT state, then call
 * rte_eal_remote_launch() for each lcore.
 *
 * @param f
 *   The function to be called.
 * @param arg
 *   The argument for the function.
 * @param call_master
 *   If call_master set to SKIP_MASTER, the MASTER lcore does not call
 *   the function. If call_master is set to CALL_MASTER, the function
 *   is also called on master before returning. In any case, the master
 *   lcore returns as soon as it finished its job and knows nothing
 *   about the completion of f on the other lcores.
 * @return
 *   - 0: Success. Execution of function f started on all remote lcores.
 *   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this
 *     case, no message is sent to any of the lcores.
 */
    pub fn rte_eal_mp_remote_launch(f: lcore_function_t,
                                    arg: *mut ::std::os::raw::c_void,
                                    call_master: rte_rmt_call_master_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the state of the lcore identified by slave_id.
 *
 * To be executed on the MASTER lcore only.
 *
 * @param slave_id
 *   The identifier of the lcore.
 * @return
 *   The state of the lcore.
 */
    pub fn rte_eal_get_lcore_state(slave_id: ::std::os::raw::c_uint)
     -> rte_lcore_state_t;
}
extern "C" {
    /**
 * Wait until an lcore finishes its job.
 *
 * To be executed on the MASTER lcore only.
 *
 * If the slave lcore identified by the slave_id is in a FINISHED state,
 * switch to the WAIT state. If the lcore is in RUNNING state, wait until
 * the lcore finishes its job and moves to the FINISHED state.
 *
 * @param slave_id
 *   The identifier of the lcore.
 * @return
 *   - 0: If the lcore identified by the slave_id is in a WAIT state.
 *   - The value that was returned by the previous remote launch
 *     function call if the lcore identified by the slave_id was in a
 *     FINISHED or RUNNING state. In this case, it changes the state
 *     of the lcore to WAIT.
 */
    pub fn rte_eal_wait_lcore(slave_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Wait until all lcores finish their jobs.
 *
 * To be executed on the MASTER lcore only. Issue an
 * rte_eal_wait_lcore() for every lcore. The return values are
 * ignored.
 *
 * After a call to rte_eal_mp_wait_lcore(), the caller can assume
 * that all slave lcores are in a WAIT state.
 */
    pub fn rte_eal_mp_wait_lcore();
}
pub type rte_cpuset_t = cpu_set_t;
/**
 * Structure storing internal configuration (per-lcore)
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcore_config {
    /**< true if lcore was detected */
    pub detected: ::std::os::raw::c_uint,
    /**< pthread identifier */
    pub thread_id: pthread_t,
    /**< communication pipe with master */
    pub pipe_master2slave: [::std::os::raw::c_int; 2usize],
    /**< communication pipe with master */
    pub pipe_slave2master: [::std::os::raw::c_int; 2usize],
    /**< function to call */
    pub f: lcore_function_t,
    /**< argument of function */
    pub arg: *mut ::std::os::raw::c_void,
    /**< return value of function */
    pub ret: ::std::os::raw::c_int,
    /**< lcore state */
    pub state: rte_lcore_state_t,
    /**< physical socket id for this lcore */
    pub socket_id: ::std::os::raw::c_uint,
    /**< core number on socket for this lcore */
    pub core_id: ::std::os::raw::c_uint,
    /**< relative index, starting from 0 */
    pub core_index: ::std::os::raw::c_int,
    /**< cpu set which the lcore affinity to */
    pub cpuset: rte_cpuset_t,
}
#[test]
fn bindgen_test_layout_lcore_config() {
    assert_eq!(::std::mem::size_of::<lcore_config>() , 200usize);
    assert_eq! (::std::mem::align_of::<lcore_config>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . detected as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . thread_id as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . pipe_master2slave as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . pipe_slave2master as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . f as * const _ as
                usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . arg as * const _ as
                usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . ret as * const _ as
                usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . state as * const _ as
                usize } , 52usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . socket_id as * const _
                as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . core_id as * const _
                as usize } , 60usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . core_index as * const
                _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcore_config ) ) . cpuset as * const _ as
                usize } , 72usize);
}
impl Clone for lcore_config {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "lcore_config"]
    pub static mut lcore_config: [lcore_config; 128usize];
}
extern "C" {
    /**
 * Return the ID of the physical socket of the logical core we are
 * running on.
 * @return
 *   the ID of current lcoreid's physical socket
 */
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * Set core affinity of the current thread.
 * Support both EAL and non-EAL thread and update TLS.
 *
 * @param cpusetp
 *   Point to cpu_set_t for setting current thread affinity.
 * @return
 *   On success, return 0; otherwise return -1;
 */
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get core affinity of the current thread.
 *
 * @param cpusetp
 *   Point to cpu_set_t for getting current thread cpu affinity.
 *   It presumes input is not NULL, otherwise it causes panic.
 *
 */
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
extern "C" {
    /**
 * Set thread names.
 *
 * @note It fails with glibc < 2.12.
 *
 * @param id
 *   Thread id.
 * @param name
 *   Thread name to set.
 * @return
 *   On success, return 0; otherwise return a negative value.
 */
    pub fn rte_thread_setname(id: pthread_t,
                              name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/**
 * The rte_spinlock_t type.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_39 {
    /**< lock status 0 = unlocked, 1 = locked */
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_39() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_39>() , 4usize);
    assert_eq! (::std::mem::align_of::<_bindgen_ty_39>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_39 ) ) . locked as * const _
                as usize } , 0usize);
}
impl Clone for _bindgen_ty_39 {
    fn clone(&self) -> Self { *self }
}
pub type rte_spinlock_t = _bindgen_ty_39;
/**
 * The rte_spinlock_recursive_t type.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_40 {
    /**< the actual spinlock */
    pub sl: rte_spinlock_t,
    /**< core id using lock, -1 for unused */
    pub user: ::std::os::raw::c_int,
    /**< count of time this lock has been called */
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_40() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_40>() , 12usize);
    assert_eq! (::std::mem::align_of::<_bindgen_ty_40>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_40 ) ) . sl as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_40 ) ) . user as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_40 ) ) . count as * const _
                as usize } , 8usize);
}
impl Clone for _bindgen_ty_40 {
    fn clone(&self) -> Self { *self }
}
pub type rte_spinlock_recursive_t = _bindgen_ty_40;
/**
 * Structure to hold malloc heap
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_heap {
    pub lock: rte_spinlock_t,
    pub free_head: [malloc_heap__bindgen_ty_1; 13usize],
    pub alloc_count: ::std::os::raw::c_uint,
    pub total_size: usize,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_heap__bindgen_ty_1 {
    pub lh_first: *mut malloc_heap__bindgen_ty_1_malloc_elem,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_heap__bindgen_ty_1_malloc_elem([u8; 0]);
#[test]
fn bindgen_test_layout_malloc_heap__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<malloc_heap__bindgen_ty_1>() , 8usize);
    assert_eq! (::std::mem::align_of::<malloc_heap__bindgen_ty_1>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap__bindgen_ty_1 ) ) . lh_first
                as * const _ as usize } , 0usize);
}
impl Clone for malloc_heap__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_malloc_heap() {
    assert_eq!(::std::mem::size_of::<malloc_heap>() , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . lock as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . free_head as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . alloc_count as * const
                _ as usize } , 112usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_heap ) ) . total_size as * const _
                as usize } , 120usize);
}
impl Clone for malloc_heap {
    fn clone(&self) -> Self { *self }
}
/**
 * The rte_rwlock_t type.
 *
 * cnt is -1 when write lock is held, and > 0 when read locks are held.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_41 {
    /**< -1 when W lock held, > 0 when R locks held. */
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_41() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_41>() , 4usize);
    assert_eq! (::std::mem::align_of::<_bindgen_ty_41>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_41 ) ) . cnt as * const _ as
                usize } , 0usize);
}
impl Clone for _bindgen_ty_41 {
    fn clone(&self) -> Self { *self }
}
pub type rte_rwlock_t = _bindgen_ty_41;
extern "C" {
    /**
 * Function which returns a printable string describing a particular
 * error code. For non-RTE-specific error codes, this function returns
 * the value from the libc strerror function.
 *
 * @param errnum
 *   The error number to be looked up - generally the value of rte_errno
 * @return
 *   A pointer to a thread-local string containing the text describing
 *   the error.
 */
    pub fn rte_strerror(errnum: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
pub const RTE_MIN_ERRNO: _bindgen_ty_42 = _bindgen_ty_42::RTE_MIN_ERRNO;
pub const E_RTE_SECONDARY: _bindgen_ty_42 = _bindgen_ty_42::E_RTE_SECONDARY;
pub const E_RTE_NO_CONFIG: _bindgen_ty_42 = _bindgen_ty_42::E_RTE_NO_CONFIG;
pub const RTE_MAX_ERRNO: _bindgen_ty_42 = _bindgen_ty_42::RTE_MAX_ERRNO;
#[repr(u32)]
/** Error types */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_42 {
    RTE_MIN_ERRNO = 1000,
    E_RTE_SECONDARY = 1001,
    E_RTE_NO_CONFIG = 1002,
    RTE_MAX_ERRNO = 1003,
}
extern "C" {
    /**
* Dump out memory in a special hex dump format.
*
* @param f
*		A pointer to a file for output
* @param title
*		If not NULL this string is printed as a header to the output.
* @param buf
*		This is the buffer address to print out.
* @param len
*		The number of bytes to dump out
* @return
*		None.
*/
    pub fn rte_hexdump(f: *mut FILE, title: *const ::std::os::raw::c_char,
                       buf: *const ::std::os::raw::c_void,
                       len: ::std::os::raw::c_uint);
}
extern "C" {
    /**
* Dump out memory in a hex format with colons between bytes.
*
* @param f
*		A pointer to a file for output
* @param title
*		If not NULL this string is printed as a header to the output.
* @param buf
*		This is the buffer address to print out.
* @param len
*		The number of bytes to dump out
* @return
*		None.
*/
    pub fn rte_memdump(f: *mut FILE, title: *const ::std::os::raw::c_char,
                       buf: *const ::std::os::raw::c_void,
                       len: ::std::os::raw::c_uint);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_keepalive_state {
    RTE_KA_STATE_UNUSED = 0,
    RTE_KA_STATE_ALIVE = 1,
    RTE_KA_STATE_MISSING = 4,
    RTE_KA_STATE_DEAD = 2,
    RTE_KA_STATE_GONE = 3,
    RTE_KA_STATE_DOZING = 5,
    RTE_KA_STATE_SLEEP = 6,
}
/**
 * Keepalive failure callback.
 *
 *  Receives a data pointer passed to rte_keepalive_create() and the id of the
 *  failed core.
 *  @param data Data pointer passed to rte_keepalive_create()
 *  @param id_core ID of the core that has failed
 */
pub type rte_keepalive_failure_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               id_core:
                                                   ::std::os::raw::c_int)>;
/**
 * Keepalive relay callback.
 *
 *  Receives a data pointer passed to rte_keepalive_register_relay_callback(),
 *  the id of the core for which state is to be forwarded, and details of the
 *  current core state.
 *  @param data Data pointer passed to rte_keepalive_register_relay_callback()
 *  @param id_core ID of the core for which state is being reported
 *  @param core_state The current state of the core
 *  @param Timestamp of when core was last seen alive
 */
pub type rte_keepalive_relay_callback_t =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               id_core: ::std::os::raw::c_int,
                                               core_state:
                                                   rte_keepalive_state,
                                               last_seen: u64)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_keepalive([u8; 0]);
extern "C" {
    /**
 * Initialise keepalive sub-system.
 * @param callback
 *   Function called upon detection of a dead core.
 * @param data
 *   Data pointer to be passed to function callback.
 * @return
 *   Keepalive structure success, NULL on failure.
 */
    #[link_name = "_Z20rte_keepalive_createPFvPviES_"]
    pub fn rte_keepalive_create(callback: rte_keepalive_failure_callback_t,
                                data: *mut ::std::os::raw::c_void)
     -> *mut rte_keepalive;
}
extern "C" {
    /**
 * Checks & handles keepalive state of monitored cores.
 * @param *ptr_timer Triggering timer (unused)
 * @param *ptr_data  Data pointer (keepalive structure)
 */
    #[link_name = "_Z28rte_keepalive_dispatch_pingsPvS_"]
    pub fn rte_keepalive_dispatch_pings(ptr_timer:
                                            *mut ::std::os::raw::c_void,
                                        ptr_data:
                                            *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * Registers a core for keepalive checks.
 * @param *keepcfg
 *   Keepalive structure pointer
 * @param id_core
 *   ID number of core to register.
 */
    #[link_name = "_Z27rte_keepalive_register_coreP13rte_keepalivei"]
    pub fn rte_keepalive_register_core(keepcfg: *mut rte_keepalive,
                                       id_core: ::std::os::raw::c_int);
}
extern "C" {
    /**
 * Per-core keepalive check.
 * @param *keepcfg
 *   Keepalive structure pointer
 *
 * This function needs to be called from within the main process loop of
 * the LCore to be checked.
 */
    #[link_name = "_Z24rte_keepalive_mark_aliveP13rte_keepalive"]
    pub fn rte_keepalive_mark_alive(keepcfg: *mut rte_keepalive);
}
extern "C" {
    /**
 * Per-core sleep-time indication.
 * @param *keepcfg
 *   Keepalive structure pointer
 *
 * If CPU idling is enabled, this function needs to be called from within
 * the main process loop of the LCore going to sleep, in order to avoid
 * the LCore being mis-detected as dead.
 */
    #[link_name = "_Z24rte_keepalive_mark_sleepP13rte_keepalive"]
    pub fn rte_keepalive_mark_sleep(keepcfg: *mut rte_keepalive);
}
extern "C" {
    /**
 * Registers a 'live core' callback.
 *
 * The complement of the 'dead core' callback. This is called when a
 * core is known to be alive, and is intended for cases when an app
 * needs to know 'liveness' beyond just knowing when a core has died.
 *
 * @param *keepcfg
 *   Keepalive structure pointer
 * @param callback
 *   Function called upon detection of a dead core.
 * @param data
 *   Data pointer to be passed to function callback.
 */
    #[link_name =
          "_Z37rte_keepalive_register_relay_callbackP13rte_keepalivePFvPvi19rte_keepalive_statemES1_"]
    pub fn rte_keepalive_register_relay_callback(keepcfg: *mut rte_keepalive,
                                                 callback:
                                                     rte_keepalive_relay_callback_t,
                                                 data:
                                                     *mut ::std::os::raw::c_void);
}
/**
 *  Structure to hold heap statistics obtained from rte_malloc_get_socket_stats function.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_malloc_socket_stats {
    /**< Total bytes on heap */
    pub heap_totalsz_bytes: usize,
    /**< Total free bytes on heap */
    pub heap_freesz_bytes: usize,
    /**< Size in bytes of largest free block */
    pub greatest_free_size: usize,
    /**< Number of free elements on heap */
    pub free_count: ::std::os::raw::c_uint,
    /**< Number of allocated elements on heap */
    pub alloc_count: ::std::os::raw::c_uint,
    /**< Total allocated bytes on heap */
    pub heap_allocsz_bytes: usize,
}
#[test]
fn bindgen_test_layout_rte_malloc_socket_stats() {
    assert_eq!(::std::mem::size_of::<rte_malloc_socket_stats>() , 40usize);
    assert_eq! (::std::mem::align_of::<rte_malloc_socket_stats>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                heap_totalsz_bytes as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                heap_freesz_bytes as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                greatest_free_size as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) . free_count
                as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) . alloc_count
                as * const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_malloc_socket_stats ) ) .
                heap_allocsz_bytes as * const _ as usize } , 32usize);
}
impl Clone for rte_malloc_socket_stats {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * This function allocates memory from the huge-page area of memory. The memory
 * is not cleared. In NUMA systems, the memory allocated resides on the same
 * NUMA socket as the core that calls this function.
 *
 * @param type
 *   A string identifying the type of allocated objects (useful for debug
 *   purposes, such as identifying the cause of a memory leak). Can be NULL.
 * @param size
 *   Size (in bytes) to be allocated.
 * @param align
 *   If 0, the return is a pointer that is suitably aligned for any kind of
 *   variable (in the same manner as malloc()).
 *   Otherwise, the return is a pointer that is a multiple of *align*. In
 *   this case, it must be a power of two. (Minimum alignment is the
 *   cacheline size, i.e. 64-bytes)
 * @return
 *   - NULL on error. Not enough memory, or invalid arguments (size is 0,
 *     align is not a power of two).
 *   - Otherwise, the pointer to the allocated object.
 */
    pub fn rte_malloc(type_: *const ::std::os::raw::c_char, size: usize,
                      align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Allocate zero'ed memory from the heap.
 *
 * Equivalent to rte_malloc() except that the memory zone is
 * initialised with zeros. In NUMA systems, the memory allocated resides on the
 * same NUMA socket as the core that calls this function.
 *
 * @param type
 *   A string identifying the type of allocated objects (useful for debug
 *   purposes, such as identifying the cause of a memory leak). Can be NULL.
 * @param size
 *   Size (in bytes) to be allocated.
 * @param align
 *   If 0, the return is a pointer that is suitably aligned for any kind of
 *   variable (in the same manner as malloc()).
 *   Otherwise, the return is a pointer that is a multiple of *align*. In
 *   this case, it must obviously be a power of two. (Minimum alignment is the
 *   cacheline size, i.e. 64-bytes)
 * @return
 *   - NULL on error. Not enough memory, or invalid arguments (size is 0,
 *     align is not a power of two).
 *   - Otherwise, the pointer to the allocated object.
 */
    pub fn rte_zmalloc(type_: *const ::std::os::raw::c_char, size: usize,
                       align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Replacement function for calloc(), using huge-page memory. Memory area is
 * initialised with zeros. In NUMA systems, the memory allocated resides on the
 * same NUMA socket as the core that calls this function.
 *
 * @param type
 *   A string identifying the type of allocated objects (useful for debug
 *   purposes, such as identifying the cause of a memory leak). Can be NULL.
 * @param num
 *   Number of elements to be allocated.
 * @param size
 *   Size (in bytes) of a single element.
 * @param align
 *   If 0, the return is a pointer that is suitably aligned for any kind of
 *   variable (in the same manner as malloc()).
 *   Otherwise, the return is a pointer that is a multiple of *align*. In
 *   this case, it must obviously be a power of two. (Minimum alignment is the
 *   cacheline size, i.e. 64-bytes)
 * @return
 *   - NULL on error. Not enough memory, or invalid arguments (size is 0,
 *     align is not a power of two).
 *   - Otherwise, the pointer to the allocated object.
 */
    pub fn rte_calloc(type_: *const ::std::os::raw::c_char, num: usize,
                      size: usize, align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Replacement function for realloc(), using huge-page memory. Reserved area
 * memory is resized, preserving contents. In NUMA systems, the new area
 * resides on the same NUMA socket as the old area.
 *
 * @param ptr
 *   Pointer to already allocated memory
 * @param size
 *   Size (in bytes) of new area. If this is 0, memory is freed.
 * @param align
 *   If 0, the return is a pointer that is suitably aligned for any kind of
 *   variable (in the same manner as malloc()).
 *   Otherwise, the return is a pointer that is a multiple of *align*. In
 *   this case, it must obviously be a power of two. (Minimum alignment is the
 *   cacheline size, i.e. 64-bytes)
 * @return
 *   - NULL on error. Not enough memory, or invalid arguments (size is 0,
 *     align is not a power of two).
 *   - Otherwise, the pointer to the reallocated memory.
 */
    pub fn rte_realloc(ptr: *mut ::std::os::raw::c_void, size: usize,
                       align: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * This function allocates memory from the huge-page area of memory. The memory
 * is not cleared.
 *
 * @param type
 *   A string identifying the type of allocated objects (useful for debug
 *   purposes, such as identifying the cause of a memory leak). Can be NULL.
 * @param size
 *   Size (in bytes) to be allocated.
 * @param align
 *   If 0, the return is a pointer that is suitably aligned for any kind of
 *   variable (in the same manner as malloc()).
 *   Otherwise, the return is a pointer that is a multiple of *align*. In
 *   this case, it must be a power of two. (Minimum alignment is the
 *   cacheline size, i.e. 64-bytes)
 * @param socket
 *   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
 *   will behave the same as rte_malloc().
 * @return
 *   - NULL on error. Not enough memory, or invalid arguments (size is 0,
 *     align is not a power of two).
 *   - Otherwise, the pointer to the allocated object.
 */
    pub fn rte_malloc_socket(type_: *const ::std::os::raw::c_char,
                             size: usize, align: ::std::os::raw::c_uint,
                             socket: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Allocate zero'ed memory from the heap.
 *
 * Equivalent to rte_malloc() except that the memory zone is
 * initialised with zeros.
 *
 * @param type
 *   A string identifying the type of allocated objects (useful for debug
 *   purposes, such as identifying the cause of a memory leak). Can be NULL.
 * @param size
 *   Size (in bytes) to be allocated.
 * @param align
 *   If 0, the return is a pointer that is suitably aligned for any kind of
 *   variable (in the same manner as malloc()).
 *   Otherwise, the return is a pointer that is a multiple of *align*. In
 *   this case, it must obviously be a power of two. (Minimum alignment is the
 *   cacheline size, i.e. 64-bytes)
 * @param socket
 *   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
 *   will behave the same as rte_zmalloc().
 * @return
 *   - NULL on error. Not enough memory, or invalid arguments (size is 0,
 *     align is not a power of two).
 *   - Otherwise, the pointer to the allocated object.
 */
    pub fn rte_zmalloc_socket(type_: *const ::std::os::raw::c_char,
                              size: usize, align: ::std::os::raw::c_uint,
                              socket: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Replacement function for calloc(), using huge-page memory. Memory area is
 * initialised with zeros.
 *
 * @param type
 *   A string identifying the type of allocated objects (useful for debug
 *   purposes, such as identifying the cause of a memory leak). Can be NULL.
 * @param num
 *   Number of elements to be allocated.
 * @param size
 *   Size (in bytes) of a single element.
 * @param align
 *   If 0, the return is a pointer that is suitably aligned for any kind of
 *   variable (in the same manner as malloc()).
 *   Otherwise, the return is a pointer that is a multiple of *align*. In
 *   this case, it must obviously be a power of two. (Minimum alignment is the
 *   cacheline size, i.e. 64-bytes)
 * @param socket
 *   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
 *   will behave the same as rte_calloc().
 * @return
 *   - NULL on error. Not enough memory, or invalid arguments (size is 0,
 *     align is not a power of two).
 *   - Otherwise, the pointer to the allocated object.
 */
    pub fn rte_calloc_socket(type_: *const ::std::os::raw::c_char, num: usize,
                             size: usize, align: ::std::os::raw::c_uint,
                             socket: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Frees the memory space pointed to by the provided pointer.
 *
 * This pointer must have been returned by a previous call to
 * rte_malloc(), rte_zmalloc(), rte_calloc() or rte_realloc(). The behaviour of
 * rte_free() is undefined if the pointer does not match this requirement.
 *
 * If the pointer is NULL, the function does nothing.
 *
 * @param ptr
 *   The pointer to memory to be freed.
 */
    pub fn rte_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * If malloc debug is enabled, check a memory block for header
 * and trailer markers to indicate that all is well with the block.
 * If size is non-null, also return the size of the block.
 *
 * @param ptr
 *   pointer to the start of a data block, must have been returned
 *   by a previous call to rte_malloc(), rte_zmalloc(), rte_calloc()
 *   or rte_realloc()
 * @param size
 *   if non-null, and memory block pointer is valid, returns the size
 *   of the memory block
 * @return
 *   -1 on error, invalid pointer passed or header and trailer markers
 *   are missing or corrupted
 *   0 on success
 */
    pub fn rte_malloc_validate(ptr: *const ::std::os::raw::c_void,
                               size: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get heap statistics for the specified heap.
 *
 * @param socket
 *   An unsigned integer specifying the socket to get heap statistics for
 * @param socket_stats
 *   A structure which provides memory to store statistics
 * @return
 *   Null on error
 *   Pointer to structure storing statistics on success
 */
    pub fn rte_malloc_get_socket_stats(socket: ::std::os::raw::c_int,
                                       socket_stats:
                                           *mut rte_malloc_socket_stats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Dump statistics.
 *
 * Dump for the specified type to a file. If the type argument is
 * NULL, all memory types will be dumped.
 *
 * @param f
 *   A pointer to a file for output
 * @param type
 *   A string identifying the type of objects to dump, or NULL
 *   to dump all objects.
 */
    pub fn rte_malloc_dump_stats(f: *mut FILE,
                                 type_: *const ::std::os::raw::c_char);
}
extern "C" {
    /**
 * Set the maximum amount of allocated memory for this type.
 *
 * This is not yet implemented
 *
 * @param type
 *   A string identifying the type of allocated objects.
 * @param max
 *   The maximum amount of allocated bytes for this type.
 * @return
 *   - 0: Success.
 *   - (-1): Error.
 */
    pub fn rte_malloc_set_limit(type_: *const ::std::os::raw::c_char,
                                max: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Return the physical address of a virtual address obtained through
 * rte_malloc
 *
 * @param addr
 *   Adress obtained from a previous rte_malloc call
 * @return
 *   NULL on error
 *   otherwise return physical address of the buffer
 */
    pub fn rte_malloc_virt2phy(addr: *const ::std::os::raw::c_void)
     -> phys_addr_t;
}
pub type xmm_t = __m128i;
#[repr(C)]
#[derive(Copy)]
pub struct rte_xmm {
    pub x: __BindgenUnionField<xmm_t>,
    pub u8: __BindgenUnionField<[u8; 16usize]>,
    pub u16: __BindgenUnionField<[u16; 8usize]>,
    pub u32: __BindgenUnionField<[u32; 4usize]>,
    pub u64: __BindgenUnionField<[u64; 2usize]>,
    pub pd: __BindgenUnionField<[f64; 2usize]>,
    pub bindgen_union_field: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_xmm() {
    assert_eq!(::std::mem::size_of::<rte_xmm>() , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . x as * const _ as usize } ,
                0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u8 as * const _ as usize }
                , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u16 as * const _ as usize }
                , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u32 as * const _ as usize }
                , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . u64 as * const _ as usize }
                , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_xmm ) ) . pd as * const _ as usize }
                , 0usize);
}
impl Clone for rte_xmm {
    fn clone(&self) -> Self { *self }
}
pub type rte_xmm_t = rte_xmm;
extern "C" {
    /**
 * Takes string "string" parameter and splits it at character "delim"
 * up to maxtokens-1 times - to give "maxtokens" resulting tokens. Like
 * strtok or strsep functions, this modifies its input string, by replacing
 * instances of "delim" with '\\0'. All resultant tokens are returned in the
 * "tokens" array which must have enough entries to hold "maxtokens".
 *
 * @param string
 *   The input string to be split into tokens
 *
 * @param stringlen
 *   The max length of the input buffer
 *
 * @param tokens
 *   The array to hold the pointers to the tokens in the string
 *
 * @param maxtokens
 *   The number of elements in the tokens array. At most, maxtokens-1 splits
 *   of the string will be done.
 *
 * @param delim
 *   The character on which the split of the data will be done
 *
 * @return
 *   The number of tokens in the tokens array.
 */
    pub fn rte_strsplit(string: *mut ::std::os::raw::c_char,
                        stringlen: ::std::os::raw::c_int,
                        tokens: *mut *mut ::std::os::raw::c_char,
                        maxtokens: ::std::os::raw::c_int,
                        delim: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/**
 * Timer type: Periodic or single (one-shot).
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_timer_type { SINGLE = 0, PERIODICAL = 1, }
/**
 * Timer status: A union of the state (stopped, pending, running,
 * config) and an owner (the id of the lcore that owns the timer).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_timer_status {
    pub __bindgen_anon_1: __BindgenUnionField<rte_timer_status__bindgen_ty_1>,
    /**< To atomic-set status + owner. */
    pub u32: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_timer_status__bindgen_ty_1 {
    /**< Stop, pending, running, config. */
    pub state: u16,
    /**< The lcore that owns the timer. */
    pub owner: i16,
}
#[test]
fn bindgen_test_layout_rte_timer_status__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_timer_status__bindgen_ty_1>() ,
               4usize);
    assert_eq! (::std::mem::align_of::<rte_timer_status__bindgen_ty_1>() ,
                2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer_status__bindgen_ty_1 ) ) .
                state as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer_status__bindgen_ty_1 ) ) .
                owner as * const _ as usize } , 2usize);
}
impl Clone for rte_timer_status__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_timer_status() {
    assert_eq!(::std::mem::size_of::<rte_timer_status>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_timer_status>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer_status ) ) . u32 as * const _
                as usize } , 0usize);
}
impl Clone for rte_timer_status {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure describing a timer in RTE.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_timer {
    /**< Time when timer expire. */
    pub expire: u64,
    pub sl_next: [*mut rte_timer; 10usize],
    /**< Status of timer. */
    pub status: rte_timer_status,
    /**< Period of timer (0 if not periodic). */
    pub period: u64,
    /**< Callback function. */
    pub f: rte_timer_cb_t,
    /**< Argument to callback function. */
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_timer() {
    assert_eq!(::std::mem::size_of::<rte_timer>() , 120usize);
    assert_eq! (::std::mem::align_of::<rte_timer>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . expire as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . sl_next as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . status as * const _ as
                usize } , 88usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . period as * const _ as
                usize } , 96usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . f as * const _ as usize }
                , 104usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_timer ) ) . arg as * const _ as usize
                } , 112usize);
}
impl Clone for rte_timer {
    fn clone(&self) -> Self { *self }
}
/**
 * Callback function type for timer expiry.
 */
pub type rte_timer_cb_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_timer,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /**
 * Initialize the timer library.
 *
 * Initializes internal variables (list, locks and so on) for the RTE
 * timer library.
 */
    pub fn rte_timer_subsystem_init();
}
extern "C" {
    /**
 * Initialize a timer handle.
 *
 * The rte_timer_init() function initializes the timer handle *tim*
 * for use. No operations can be performed on a timer before it is
 * initialized.
 *
 * @param tim
 *   The timer to initialize.
 */
    pub fn rte_timer_init(tim: *mut rte_timer);
}
extern "C" {
    /**
 * Reset and start the timer associated with the timer handle.
 *
 * The rte_timer_reset() function resets and starts the timer
 * associated with the timer handle *tim*. When the timer expires after
 * *ticks* HPET cycles, the function specified by *fct* will be called
 * with the argument *arg* on core *tim_lcore*.
 *
 * If the timer associated with the timer handle is already running
 * (in the RUNNING state), the function will fail. The user has to check
 * the return value of the function to see if there is a chance that the
 * timer is in the RUNNING state.
 *
 * If the timer is being configured on another core (the CONFIG state),
 * it will also fail.
 *
 * If the timer is pending or stopped, it will be rescheduled with the
 * new parameters.
 *
 * @param tim
 *   The timer handle.
 * @param ticks
 *   The number of cycles (see rte_get_hpet_hz()) before the callback
 *   function is called.
 * @param type
 *   The type can be either:
 *   - PERIODICAL: The timer is automatically reloaded after execution
 *     (returns to the PENDING state)
 *   - SINGLE: The timer is one-shot, that is, the timer goes to a
 *     STOPPED state after execution.
 * @param tim_lcore
 *   The ID of the lcore where the timer callback function has to be
 *   executed. If tim_lcore is LCORE_ID_ANY, the timer library will
 *   launch it on a different core for each call (round-robin).
 * @param fct
 *   The callback function of the timer.
 * @param arg
 *   The user argument of the callback function.
 * @return
 *   - 0: Success; the timer is scheduled.
 *   - (-1): Timer is in the RUNNING or CONFIG state.
 */
    pub fn rte_timer_reset(tim: *mut rte_timer, ticks: u64,
                           type_: rte_timer_type,
                           tim_lcore: ::std::os::raw::c_uint,
                           fct: rte_timer_cb_t,
                           arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Loop until rte_timer_reset() succeeds.
 *
 * Reset and start the timer associated with the timer handle. Always
 * succeed. See rte_timer_reset() for details.
 *
 * @param tim
 *   The timer handle.
 * @param ticks
 *   The number of cycles (see rte_get_hpet_hz()) before the callback
 *   function is called.
 * @param type
 *   The type can be either:
 *   - PERIODICAL: The timer is automatically reloaded after execution
 *     (returns to the PENDING state)
 *   - SINGLE: The timer is one-shot, that is, the timer goes to a
 *     STOPPED state after execution.
 * @param tim_lcore
 *   The ID of the lcore where the timer callback function has to be
 *   executed. If tim_lcore is LCORE_ID_ANY, the timer library will
 *   launch it on a different core for each call (round-robin).
 * @param fct
 *   The callback function of the timer.
 * @param arg
 *   The user argument of the callback function.
 */
    pub fn rte_timer_reset_sync(tim: *mut rte_timer, ticks: u64,
                                type_: rte_timer_type,
                                tim_lcore: ::std::os::raw::c_uint,
                                fct: rte_timer_cb_t,
                                arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * Stop a timer.
 *
 * The rte_timer_stop() function stops the timer associated with the
 * timer handle *tim*. It may fail if the timer is currently running or
 * being configured.
 *
 * If the timer is pending or stopped (for instance, already expired),
 * the function will succeed. The timer handle tim must have been
 * initialized using rte_timer_init(), otherwise, undefined behavior
 * will occur.
 *
 * This function can be called safely from a timer callback. If it
 * succeeds, the timer is not referenced anymore by the timer library
 * and the timer structure can be freed (even in the callback
 * function).
 *
 * @param tim
 *   The timer handle.
 * @return
 *   - 0: Success; the timer is stopped.
 *   - (-1): The timer is in the RUNNING or CONFIG state.
 */
    pub fn rte_timer_stop(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Loop until rte_timer_stop() succeeds.
 *
 * After a call to this function, the timer identified by *tim* is
 * stopped. See rte_timer_stop() for details.
 *
 * @param tim
 *   The timer handle.
 */
    pub fn rte_timer_stop_sync(tim: *mut rte_timer);
}
extern "C" {
    /**
 * Test if a timer is pending.
 *
 * The rte_timer_pending() function tests the PENDING status
 * of the timer handle *tim*. A PENDING timer is one that has been
 * scheduled and whose function has not yet been called.
 *
 * @param tim
 *   The timer handle.
 * @return
 *   - 0: The timer is not pending.
 *   - 1: The timer is pending.
 */
    pub fn rte_timer_pending(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Manage the timer list and execute callback functions.
 *
 * This function must be called periodically from EAL lcores
 * main_loop(). It browses the list of pending timers and runs all
 * timers that are expired.
 *
 * The precision of the timer depends on the call frequency of this
 * function. However, the more often the function is called, the more
 * CPU resources it will use.
 */
    pub fn rte_timer_manage();
}
extern "C" {
    /**
 * Dump statistics about timers.
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_timer_dump_stats(f: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_field_types {
    pub u8: __BindgenUnionField<u8>,
    pub u16: __BindgenUnionField<u16>,
    pub u32: __BindgenUnionField<u32>,
    pub u64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_acl_field_types() {
    assert_eq!(::std::mem::size_of::<rte_acl_field_types>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_acl_field_types>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u8 as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u16 as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u32 as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_types ) ) . u64 as * const
                _ as usize } , 0usize);
}
impl Clone for rte_acl_field_types {
    fn clone(&self) -> Self { *self }
}
pub const RTE_ACL_FIELD_TYPE_MASK: _bindgen_ty_43 =
    _bindgen_ty_43::RTE_ACL_FIELD_TYPE_MASK;
pub const RTE_ACL_FIELD_TYPE_RANGE: _bindgen_ty_43 =
    _bindgen_ty_43::RTE_ACL_FIELD_TYPE_RANGE;
pub const RTE_ACL_FIELD_TYPE_BITMASK: _bindgen_ty_43 =
    _bindgen_ty_43::RTE_ACL_FIELD_TYPE_BITMASK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_43 {
    RTE_ACL_FIELD_TYPE_MASK = 0,
    RTE_ACL_FIELD_TYPE_RANGE = 1,
    RTE_ACL_FIELD_TYPE_BITMASK = 2,
}
/**
 * ACL Field definition.
 * Each field in the ACL rule has an associate definition.
 * It defines the type of field, its size, its offset in the input buffer,
 * the field index, and the input index.
 * For performance reasons, the inner loop of the search function is unrolled
 * to process four input bytes at a time. This requires the input to be grouped
 * into sets of 4 consecutive bytes. The loop processes the first input byte as
 * part of the setup and then subsequent bytes must be in groups of 4
 * consecutive bytes.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_field_def {
    /**< type - RTE_ACL_FIELD_TYPE_*. */
    pub type_: u8,
    /**< size of field 1,2,4, or 8. */
    pub size: u8,
    /**< index of field inside the rule. */
    pub field_index: u8,
    /**< 0-N input index. */
    pub input_index: u8,
    /**< offset to start of field. */
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_rte_acl_field_def() {
    assert_eq!(::std::mem::size_of::<rte_acl_field_def>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_acl_field_def>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . type_ as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . size as * const _
                as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . field_index as *
                const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . input_index as *
                const _ as usize } , 3usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field_def ) ) . offset as * const
                _ as usize } , 4usize);
}
impl Clone for rte_acl_field_def {
    fn clone(&self) -> Self { *self }
}
/**
 * ACL build configuration.
 * Defines the fields of an ACL trie and number of categories to build with.
 */
#[repr(C)]
pub struct rte_acl_config {
    /**< Number of categories to build with. */
    pub num_categories: u32,
    /**< Number of field definitions. */
    pub num_fields: u32,
    pub defs: [rte_acl_field_def; 64usize],
    pub max_size: usize,
}
#[test]
fn bindgen_test_layout_rte_acl_config() {
    assert_eq!(::std::mem::size_of::<rte_acl_config>() , 528usize);
    assert_eq! (::std::mem::align_of::<rte_acl_config>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . num_categories as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . num_fields as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . defs as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_config ) ) . max_size as * const
                _ as usize } , 520usize);
}
/**
 * Defines the value of a field for a rule.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_field {
    pub value: rte_acl_field_types,
    pub mask_range: rte_acl_field_types,
}
#[test]
fn bindgen_test_layout_rte_acl_field() {
    assert_eq!(::std::mem::size_of::<rte_acl_field>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_acl_field>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field ) ) . value as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_field ) ) . mask_range as * const
                _ as usize } , 8usize);
}
impl Clone for rte_acl_field {
    fn clone(&self) -> Self { *self }
}
pub const RTE_ACL_TYPE_SHIFT: _bindgen_ty_44 =
    _bindgen_ty_44::RTE_ACL_TYPE_SHIFT;
pub const RTE_ACL_MAX_INDEX: _bindgen_ty_44 =
    _bindgen_ty_44::RTE_ACL_MAX_INDEX;
pub const RTE_ACL_MAX_PRIORITY: _bindgen_ty_44 =
    _bindgen_ty_44::RTE_ACL_MAX_INDEX;
pub const RTE_ACL_MIN_PRIORITY: _bindgen_ty_44 =
    _bindgen_ty_44::RTE_ACL_MIN_PRIORITY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_44 {
    RTE_ACL_TYPE_SHIFT = 29,
    RTE_ACL_MAX_INDEX = 536870911,
    RTE_ACL_MIN_PRIORITY = 0,
}
/**
 * Miscellaneous data for ACL rule.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_rule_data {
    /**< Mask of categories for that rule. */
    pub category_mask: u32,
    /**< Priority for that rule. */
    pub priority: i32,
    /**< Associated with the rule user data. */
    pub userdata: u32,
}
#[test]
fn bindgen_test_layout_rte_acl_rule_data() {
    assert_eq!(::std::mem::size_of::<rte_acl_rule_data>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_acl_rule_data>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_rule_data ) ) . category_mask as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_rule_data ) ) . priority as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_rule_data ) ) . userdata as *
                const _ as usize } , 8usize);
}
impl Clone for rte_acl_rule_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_rule {
    pub data: rte_acl_rule_data,
    pub field: __IncompleteArrayField<rte_acl_field>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_acl_rule() {
    assert_eq!(::std::mem::size_of::<rte_acl_rule>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_acl_rule>() , 8usize);
}
impl Clone for rte_acl_rule {
    fn clone(&self) -> Self { *self }
}
/**
 * Parameters used when creating the ACL context.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_acl_param {
    /**< Name of the ACL context. */
    pub name: *const ::std::os::raw::c_char,
    /**< Socket ID to allocate memory for. */
    pub socket_id: ::std::os::raw::c_int,
    /**< Size of each rule. */
    pub rule_size: u32,
    /**< Maximum number of rules. */
    pub max_rule_num: u32,
}
#[test]
fn bindgen_test_layout_rte_acl_param() {
    assert_eq!(::std::mem::size_of::<rte_acl_param>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_acl_param>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . name as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . socket_id as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . rule_size as * const
                _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_acl_param ) ) . max_rule_num as *
                const _ as usize } , 16usize);
}
impl Clone for rte_acl_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_acl_ctx([u8; 0]);
extern "C" {
    /**
 * Create a new ACL context.
 *
 * @param param
 *   Parameters used to create and initialise the ACL context.
 * @return
 *   Pointer to ACL context structure that is used in future ACL
 *   operations, or NULL on error, with error code set in rte_errno.
 *   Possible rte_errno errors include:
 *   - EINVAL - invalid parameter passed to function
 */
    pub fn rte_acl_create(param: *const rte_acl_param) -> *mut rte_acl_ctx;
}
extern "C" {
    /**
 * Find an existing ACL context object and return a pointer to it.
 *
 * @param name
 *   Name of the ACL context as passed to rte_acl_create()
 * @return
 *   Pointer to ACL context or NULL if object not found
 *   with rte_errno set appropriately. Possible rte_errno values include:
 *    - ENOENT - value not available for return
 */
    pub fn rte_acl_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_acl_ctx;
}
extern "C" {
    /**
 * De-allocate all memory used by ACL context.
 *
 * @param ctx
 *   ACL context to free
 */
    pub fn rte_acl_free(ctx: *mut rte_acl_ctx);
}
extern "C" {
    /**
 * Add rules to an existing ACL context.
 * This function is not multi-thread safe.
 *
 * @param ctx
 *   ACL context to add patterns to.
 * @param rules
 *   Array of rules to add to the ACL context.
 *   Note that all fields in rte_acl_rule structures are expected
 *   to be in host byte order.
 *   Each rule expected to be in the same format and not exceed size
 *   specified at ACL context creation time.
 * @param num
 *   Number of elements in the input array of rules.
 * @return
 *   - -ENOMEM if there is no space in the ACL context for these rules.
 *   - -EINVAL if the parameters are invalid.
 *   - Zero if operation completed successfully.
 */
    pub fn rte_acl_add_rules(ctx: *mut rte_acl_ctx,
                             rules: *const rte_acl_rule, num: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete all rules from the ACL context.
 * This function is not multi-thread safe.
 * Note that internal run-time structures are not affected.
 *
 * @param ctx
 *   ACL context to delete rules from.
 */
    pub fn rte_acl_reset_rules(ctx: *mut rte_acl_ctx);
}
extern "C" {
    /**
 * Analyze set of rules and build required internal run-time structures.
 * This function is not multi-thread safe.
 *
 * @param ctx
 *   ACL context to build.
 * @param cfg
 *   Pointer to struct rte_acl_config - defines build parameters.
 * @return
 *   - -ENOMEM if couldn't allocate enough memory.
 *   - -EINVAL if the parameters are invalid.
 *   - Negative error code if operation failed.
 *   - Zero if operation completed successfully.
 */
    pub fn rte_acl_build(ctx: *mut rte_acl_ctx, cfg: *const rte_acl_config)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete all rules from the ACL context and
 * destroy all internal run-time structures.
 * This function is not multi-thread safe.
 *
 * @param ctx
 *   ACL context to reset.
 */
    pub fn rte_acl_reset(ctx: *mut rte_acl_ctx);
}
#[repr(u32)]
/**
 *  Available implementations of ACL classify.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_acl_classify_alg {
    RTE_ACL_CLASSIFY_DEFAULT = 0,
    RTE_ACL_CLASSIFY_SCALAR = 1,
    RTE_ACL_CLASSIFY_SSE = 2,
    RTE_ACL_CLASSIFY_AVX2 = 3,
    RTE_ACL_CLASSIFY_NEON = 4,
    RTE_ACL_CLASSIFY_ALTIVEC = 5,
    RTE_ACL_CLASSIFY_NUM = 6,
}
extern "C" {
    /**
 * Perform search for a matching ACL rule for each input data buffer.
 * Each input data buffer can have up to *categories* matches.
 * That implies that results array should be big enough to hold
 * (categories * num) elements.
 * Also categories parameter should be either one or multiple of
 * RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES.
 * If more than one rule is applicable for given input buffer and
 * given category, then rule with highest priority will be returned as a match.
 * Note, that it is a caller's responsibility to ensure that input parameters
 * are valid and point to correct memory locations.
 *
 * @param ctx
 *   ACL context to search with.
 * @param data
 *   Array of pointers to input data buffers to perform search.
 *   Note that all fields in input data buffers supposed to be in network
 *   byte order (MSB).
 * @param results
 *   Array of search results, *categories* results per each input data buffer.
 * @param num
 *   Number of elements in the input data buffers array.
 * @param categories
 *   Number of maximum possible matches for each input buffer, one possible
 *   match per category.
 * @return
 *   zero on successful completion.
 *   -EINVAL for incorrect arguments.
 */
    pub fn rte_acl_classify(ctx: *const rte_acl_ctx, data: *mut *const u8,
                            results: *mut u32, num: u32, categories: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Perform search using specified algorithm for a matching ACL rule for
 * each input data buffer.
 * Each input data buffer can have up to *categories* matches.
 * That implies that results array should be big enough to hold
 * (categories * num) elements.
 * Also categories parameter should be either one or multiple of
 * RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES.
 * If more than one rule is applicable for given input buffer and
 * given category, then rule with highest priority will be returned as a match.
 * Note, that it is a caller's responsibility to ensure that input parameters
 * are valid and point to correct memory locations.
 *
 * @param ctx
 *   ACL context to search with.
 * @param data
 *   Array of pointers to input data buffers to perform search.
 *   Note that all fields in input data buffers supposed to be in network
 *   byte order (MSB).
 * @param results
 *   Array of search results, *categories* results per each input data buffer.
 * @param num
 *   Number of elements in the input data buffers array.
 * @param categories
 *   Number of maximum possible matches for each input buffer, one possible
 *   match per category.
 * @param alg
 *   Algorithm to be used for the search.
 *   It is the caller responsibility to ensure that the value refers to the
 *   existing algorithm, and that it could be run on the given CPU.
 * @return
 *   zero on successful completion.
 *   -EINVAL for incorrect arguments.
 */
    pub fn rte_acl_classify_alg(ctx: *const rte_acl_ctx, data: *mut *const u8,
                                results: *mut u32, num: u32, categories: u32,
                                alg: rte_acl_classify_alg)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_acl_set_ctx_classify(ctx: *mut rte_acl_ctx,
                                    alg: rte_acl_classify_alg)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Dump an ACL context structure to the console.
 *
 * @param ctx
 *   ACL context to dump.
 */
    pub fn rte_acl_dump(ctx: *const rte_acl_ctx);
}
extern "C" {
    /**
 * Dump all ACL context structures to the console.
 */
    pub fn rte_acl_list_dump();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_ring_queue_behavior {
    RTE_RING_QUEUE_FIXED = 0,
    RTE_RING_QUEUE_VARIABLE = 1,
}
/**
 * An RTE ring structure.
 *
 * The producer and the consumer have a head and a tail index. The particularity
 * of these index is that they are not between 0 and size(ring). These indexes
 * are between 0 and 2^32, and we mask their value when we access the ring[]
 * field. Thanks to this assumption, we can do subtractions between 2 index
 * values in a modulo-32bit base: that's why the overflow of the indexes is not
 * a problem.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ring {
    /**< Name of the ring. */
    pub name: [::std::os::raw::c_char; 32usize],
    /**< Flags supplied at creation. */
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    pub prod: rte_ring_prod,
    pub cons: rte_ring_cons,
    /**< Memory space of ring starts here.
	                                     * not volatile so need to be careful
	                                     * about compiler re-ordering */
    pub ring: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
    pub __bindgen_padding_0: [u32; 9usize],
}
/** Ring producer status. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ring_prod {
    /**< Maximum items before EDQUOT. */
    pub watermark: u32,
    /**< True, if single producer. */
    pub sp_enqueue: u32,
    /**< Size of ring. */
    pub size: u32,
    /**< Mask (size-1) of ring. */
    pub mask: u32,
    /**< Producer head. */
    pub head: u32,
    /**< Producer tail. */
    pub tail: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_prod() {
    assert_eq!(::std::mem::size_of::<rte_ring_prod>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_ring_prod>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_prod ) ) . watermark as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_prod ) ) . sp_enqueue as * const
                _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_prod ) ) . size as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_prod ) ) . mask as * const _ as
                usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_prod ) ) . head as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_prod ) ) . tail as * const _ as
                usize } , 20usize);
}
impl Clone for rte_ring_prod {
    fn clone(&self) -> Self { *self }
}
/** Ring consumer status. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ring_cons {
    /**< True, if single consumer. */
    pub sc_dequeue: u32,
    /**< Size of the ring. */
    pub size: u32,
    /**< Mask (size-1) of ring. */
    pub mask: u32,
    /**< Consumer head. */
    pub head: u32,
    /**< Consumer tail. */
    pub tail: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_cons() {
    assert_eq!(::std::mem::size_of::<rte_ring_cons>() , 20usize);
    assert_eq! (::std::mem::align_of::<rte_ring_cons>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_cons ) ) . sc_dequeue as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_cons ) ) . size as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_cons ) ) . mask as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_cons ) ) . head as * const _ as
                usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ring_cons ) ) . tail as * const _ as
                usize } , 16usize);
}
impl Clone for rte_ring_cons {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_ring() {
    assert_eq!(::std::mem::size_of::<rte_ring>() , 128usize);
}
impl Clone for rte_ring {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Calculate the memory size needed for a ring
 *
 * This function returns the number of bytes needed for a ring, given
 * the number of elements in it. This value is the sum of the size of
 * the structure rte_ring and the size of the memory needed by the
 * objects pointers. The value is aligned to a cache line size.
 *
 * @param count
 *   The number of elements in the ring (must be a power of 2).
 * @return
 *   - The memory size needed for the ring on success.
 *   - -EINVAL if count is not a power of 2.
 */
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
extern "C" {
    /**
 * Initialize a ring structure.
 *
 * Initialize a ring structure in memory pointed by "r". The size of the
 * memory area must be large enough to store the ring structure and the
 * object table. It is advised to use rte_ring_get_memsize() to get the
 * appropriate size.
 *
 * The ring size is set to *count*, which must be a power of two. Water
 * marking is disabled by default. The real usable ring size is
 * *count-1* instead of *count* to differentiate a free ring from an
 * empty ring.
 *
 * The ring is not added in RTE_TAILQ_RING global list. Indeed, the
 * memory given by the caller may not be shareable among dpdk
 * processes.
 *
 * @param r
 *   The pointer to the ring structure followed by the objects table.
 * @param name
 *   The name of the ring.
 * @param count
 *   The number of elements in the ring (must be a power of 2).
 * @param flags
 *   An OR of the following:
 *    - RING_F_SP_ENQ: If this flag is set, the default behavior when
 *      using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
 *      is "single-producer". Otherwise, it is "multi-producers".
 *    - RING_F_SC_DEQ: If this flag is set, the default behavior when
 *      using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
 *      is "single-consumer". Otherwise, it is "multi-consumers".
 * @return
 *   0 on success, or a negative value on error.
 */
    pub fn rte_ring_init(r: *mut rte_ring,
                         name: *const ::std::os::raw::c_char,
                         count: ::std::os::raw::c_uint,
                         flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Create a new ring named *name* in memory.
 *
 * This function uses ``memzone_reserve()`` to allocate memory. Then it
 * calls rte_ring_init() to initialize an empty ring.
 *
 * The new ring size is set to *count*, which must be a power of
 * two. Water marking is disabled by default. The real usable ring size
 * is *count-1* instead of *count* to differentiate a free ring from an
 * empty ring.
 *
 * The ring is added in RTE_TAILQ_RING list.
 *
 * @param name
 *   The name of the ring.
 * @param count
 *   The size of the ring (must be a power of 2).
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   An OR of the following:
 *    - RING_F_SP_ENQ: If this flag is set, the default behavior when
 *      using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
 *      is "single-producer". Otherwise, it is "multi-producers".
 *    - RING_F_SC_DEQ: If this flag is set, the default behavior when
 *      using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
 *      is "single-consumer". Otherwise, it is "multi-consumers".
 * @return
 *   On success, the pointer to the new allocated ring. NULL on error with
 *    rte_errno set appropriately. Possible errno values include:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - EINVAL - count provided is not a power of 2
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */
    pub fn rte_ring_create(name: *const ::std::os::raw::c_char,
                           count: ::std::os::raw::c_uint,
                           socket_id: ::std::os::raw::c_int,
                           flags: ::std::os::raw::c_uint) -> *mut rte_ring;
}
extern "C" {
    /**
 * De-allocate all memory used by the ring.
 *
 * @param r
 *   Ring to free
 */
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    /**
 * Change the high water mark.
 *
 * If *count* is 0, water marking is disabled. Otherwise, it is set to the
 * *count* value. The *count* value must be greater than 0 and less
 * than the ring size.
 *
 * This function can be called at any time (not necessarily at
 * initialization).
 *
 * @param r
 *   A pointer to the ring structure.
 * @param count
 *   The new water mark value.
 * @return
 *   - 0: Success; water mark changed.
 *   - -EINVAL: Invalid water mark value.
 */
    pub fn rte_ring_set_water_mark(r: *mut rte_ring,
                                   count: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Dump the status of the ring to a file.
 *
 * @param f
 *   A pointer to a file for output
 * @param r
 *   A pointer to the ring structure.
 */
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    /**
 * Dump the status of all rings on the console
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    /**
 * Search a ring from its name
 *
 * @param name
 *   The name of the ring.
 * @return
 *   The pointer to the ring matching the name, or NULL if not found,
 *   with rte_errno set appropriately. Possible rte_errno values include:
 *    - ENOENT - required entry not available to return.
 */
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char)
     -> *mut rte_ring;
}
/**
 * A structure that stores a per-core object cache.
 */
#[repr(C)]
pub struct rte_mempool_cache {
    /**< Size of the cache */
    pub size: u32,
    /**< Threshold before we flush excess elements */
    pub flushthresh: u32,
    /**< Current cache count */
    pub len: u32,
    /**< Cache objects */
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
    pub __bindgen_padding_0: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    assert_eq!(::std::mem::size_of::<rte_mempool_cache>() , 12352usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . size as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . flushthresh as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . len as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_cache ) ) . objs as * const _
                as usize } , 16usize);
}
/**
 * A structure that stores the size of mempool elements.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objsz {
    /**< Size of an element. */
    pub elt_size: u32,
    /**< Size of header (before elt). */
    pub header_size: u32,
    /**< Size of trailer (after elt). */
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objsz>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_objsz>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . elt_size as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . header_size as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . trailer_size as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objsz ) ) . total_size as *
                const _ as usize } , 12usize);
}
impl Clone for rte_mempool_objsz {
    fn clone(&self) -> Self { *self }
}
/**
 * Mempool object header structure
 *
 * Each object stored in mempools are prefixed by this header structure,
 * it allows to retrieve the mempool pointer from the object and to
 * iterate on all objects attached to a mempool. When debug is enabled,
 * a cookie is also added in this structure preventing corruptions and
 * double-frees.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr {
    /**< Next in list. */
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    /**< The mempool owning the object. */
    pub mp: *mut rte_mempool_objhdr_rte_mempool,
    /**< Physical address of the object. */
    pub physaddr: phys_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>() ,
               8usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize);
}
impl Clone for rte_mempool_objhdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/**
 * The RTE mempool structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr_rte_mempool {
    /**< Name of mempool. */
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool_objhdr_rte_mempool__bindgen_ty_1,
    /**< optional args for ops alloc. */
    pub pool_config: *mut ::std::os::raw::c_void,
    /**< Memzone where pool is alloc'd. */
    pub mz: *const rte_memzone,
    /**< Flags of the mempool. */
    pub flags: ::std::os::raw::c_int,
    /**< Socket id passed at create. */
    pub socket_id: ::std::os::raw::c_int,
    /**< Max size of the mempool. */
    pub size: u32,
    pub cache_size: u32,
    /**< Size of an element. */
    pub elt_size: u32,
    /**< Size of header (before elt). */
    pub header_size: u32,
    /**< Size of trailer (after elt). */
    pub trailer_size: u32,
    /**< Size of private data. */
    pub private_data_size: ::std::os::raw::c_uint,
    /**
	 * Index into rte_mempool_ops_table array of mempool ops
	 * structs, which contain callback function pointers.
	 * We're using an index here rather than pointers to the callbacks
	 * to facilitate any secondary processes that may want to use
	 * this mempool.
	 */
    pub ops_index: i32,
    /**< Per-lcore local cache */
    pub local_cache: *mut rte_mempool_cache,
    /**< Number of populated objects. */
    pub populated_size: u32,
    /**< List of objects in pool */
    pub elt_list: rte_mempool_objhdr_list,
    /**< Number of memory chunks */
    pub nb_mem_chunks: u32,
    /**< List of memory chunks */
    pub mem_list: rte_mempool_memhdr_list,
    pub __bindgen_padding_0: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr_rte_mempool__bindgen_ty_1 {
    /**< Ring or pool to store objects. */
    pub pool_data: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /**< External mempool identifier. */
    pub pool_id: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_rte_mempool__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr_rte_mempool__bindgen_ty_1>()
               , 8usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_objhdr_rte_mempool__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_objhdr_rte_mempool__bindgen_ty_1
                ) ) . pool_data as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_objhdr_rte_mempool__bindgen_ty_1
                ) ) . pool_id as * const _ as usize } , 0usize);
}
impl Clone for rte_mempool_objhdr_rte_mempool__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_rte_mempool() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr_rte_mempool>() ,
               192usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) . name
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                pool_config as * const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) . mz
                as * const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                flags as * const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                socket_id as * const _ as usize } , 60usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) . size
                as * const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                cache_size as * const _ as usize } , 68usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                elt_size as * const _ as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                header_size as * const _ as usize } , 76usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                trailer_size as * const _ as usize } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                private_data_size as * const _ as usize } , 84usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                ops_index as * const _ as usize } , 88usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                local_cache as * const _ as usize } , 96usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                populated_size as * const _ as usize } , 104usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                elt_list as * const _ as usize } , 112usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                nb_mem_chunks as * const _ as usize } , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_rte_mempool ) ) .
                mem_list as * const _ as usize } , 136usize);
}
impl Clone for rte_mempool_objhdr_rte_mempool {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_objhdr>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr ) ) . next as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr ) ) . mp as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr ) ) . physaddr as *
                const _ as usize } , 16usize);
}
impl Clone for rte_mempool_objhdr {
    fn clone(&self) -> Self { *self }
}
/**
 * A list of object headers type
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    assert_eq!(::std::mem::size_of::<rte_mempool_objhdr_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_objhdr_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_list ) ) . stqh_first
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_objhdr_list ) ) . stqh_last
                as * const _ as usize } , 8usize);
}
impl Clone for rte_mempool_objhdr_list {
    fn clone(&self) -> Self { *self }
}
/**
 * A list of memory where objects are stored
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr_list_rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr_list_rte_mempool_memhdr,
}
/**
 * Mempool objects memory header structure
 *
 * The memory chunks where objects are stored. Each chunk is virtually
 * and physically contiguous.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_memhdr_list_rte_mempool_memhdr {
    /**< Next in list. */
    pub next: rte_mempool_memhdr_list_rte_mempool_memhdr__bindgen_ty_1,
    /**< The mempool owning the chunk */
    pub mp: *mut rte_mempool_objhdr_rte_mempool,
    /**< Virtual address of the chunk */
    pub addr: *mut ::std::os::raw::c_void,
    /**< Physical address of the chunk */
    pub phys_addr: phys_addr_t,
    /**< length of the chunk */
    pub len: usize,
    /**< Free callback */
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    /**< Argument passed to the free callback */
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_memhdr_list_rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr_list_rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list_rte_mempool_memhdr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mempool_memhdr_list_rte_mempool_memhdr__bindgen_ty_1>()
               , 8usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_memhdr_list_rte_mempool_memhdr__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_mempool_memhdr_list_rte_mempool_memhdr__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize);
}
impl Clone for rte_mempool_memhdr_list_rte_mempool_memhdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list_rte_mempool_memhdr() {
    assert_eq!(::std::mem::size_of::<rte_mempool_memhdr_list_rte_mempool_memhdr>()
               , 56usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_memhdr_list_rte_mempool_memhdr>()
                , 8usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_memhdr_list_rte_mempool_memhdr )
                ) . next as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_memhdr_list_rte_mempool_memhdr )
                ) . mp as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_memhdr_list_rte_mempool_memhdr )
                ) . addr as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_memhdr_list_rte_mempool_memhdr )
                ) . phys_addr as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_memhdr_list_rte_mempool_memhdr )
                ) . len as * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_memhdr_list_rte_mempool_memhdr )
                ) . free_cb as * const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_mempool_memhdr_list_rte_mempool_memhdr )
                ) . opaque as * const _ as usize } , 48usize);
}
impl Clone for rte_mempool_memhdr_list_rte_mempool_memhdr {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    assert_eq!(::std::mem::size_of::<rte_mempool_memhdr_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_mempool_memhdr_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr_list ) ) . stqh_first
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_memhdr_list ) ) . stqh_last
                as * const _ as usize } , 8usize);
}
impl Clone for rte_mempool_memhdr_list {
    fn clone(&self) -> Self { *self }
}
/**
 * Callback used to free a memory chunk
 */
pub type rte_mempool_memchunk_free_cb_t =
    ::std::option::Option<unsafe extern "C" fn(memhdr:
                                                   *mut rte_mempool_memhdr_list_rte_mempool_memhdr,
                                               opaque:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr([u8; 0]);
extern "C" {
    /**
 * @internal Check and update cookies or panic.
 *
 * @param mp
 *   Pointer to the memory pool.
 * @param obj_table_const
 *   Pointer to a table of void * pointers (objects).
 * @param n
 *   Index of object in object table.
 * @param free
 *   - 0: object is supposed to be allocated, mark it as free
 *   - 1: object is supposed to be free, mark it as allocated
 *   - 2: just check that cookie is valid (free or allocated)
 */
    pub fn rte_mempool_check_cookies(mp:
                                         *const rte_mempool_objhdr_rte_mempool,
                                     obj_table_const:
                                         *const *const ::std::os::raw::c_void,
                                     n: ::std::os::raw::c_uint,
                                     free: ::std::os::raw::c_int);
}
/**
 * Prototype for implementation specific data provisioning function.
 *
 * The function should provide the implementation specific memory for
 * for use by the other mempool ops functions in a given mempool ops struct.
 * E.g. the default ops provides an instance of the rte_ring for this purpose.
 * it will most likely point to a different type of data structure, and
 * will be transparent to the application programmer.
 * This function should set mp->pool_data.
 */
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp:
                                                   *mut rte_mempool_objhdr_rte_mempool)
                              -> ::std::os::raw::c_int>;
/**
 * Free the opaque private data pointed to by mp->pool_data pointer.
 */
pub type rte_mempool_free_t =
    ::std::option::Option<unsafe extern "C" fn(mp:
                                                   *mut rte_mempool_objhdr_rte_mempool)>;
/**
 * Enqueue an object into the external pool.
 */
pub type rte_mempool_enqueue_t =
    ::std::option::Option<unsafe extern "C" fn(mp:
                                                   *mut rte_mempool_objhdr_rte_mempool,
                                               obj_table:
                                                   *const *const ::std::os::raw::c_void,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
/**
 * Dequeue an object from the external pool.
 */
pub type rte_mempool_dequeue_t =
    ::std::option::Option<unsafe extern "C" fn(mp:
                                                   *mut rte_mempool_objhdr_rte_mempool,
                                               obj_table:
                                                   *mut *mut ::std::os::raw::c_void,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
/**
 * Return the number of available objects in the external pool.
 */
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp:
                                                   *const rte_mempool_objhdr_rte_mempool)
                              -> ::std::os::raw::c_uint>;
/** Structure defining mempool operations structure */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_ops {
    /**< Name of mempool ops struct. */
    pub name: [::std::os::raw::c_char; 32usize],
    /**< Allocate private data. */
    pub alloc: rte_mempool_alloc_t,
    /**< Free the external pool. */
    pub free: rte_mempool_free_t,
    /**< Enqueue an object. */
    pub enqueue: rte_mempool_enqueue_t,
    /**< Dequeue an object. */
    pub dequeue: rte_mempool_dequeue_t,
    /**< Get qty of available objs. */
    pub get_count: rte_mempool_get_count,
    pub __bindgen_padding_0: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(::std::mem::size_of::<rte_mempool_ops>() , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . name as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . alloc as * const _
                as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . free as * const _
                as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . enqueue as * const
                _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . dequeue as * const
                _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops ) ) . get_count as *
                const _ as usize } , 64usize);
}
impl Clone for rte_mempool_ops {
    fn clone(&self) -> Self { *self }
}
/**
 * Structure storing the table of registered ops structs, each of which contain
 * the function pointers for the mempool ops functions.
 * Each process has its own storage for this ops struct array so that
 * the mempools can be shared across primary and secondary processes.
 * The indices used to access the array are valid across processes, whereas
 * any function pointers stored directly in the mempool struct would not be.
 * This results in us simply having "ops_index" in the mempool struct.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mempool_ops_table {
    /**< Spinlock for add/delete. */
    pub sl: rte_spinlock_t,
    /**< Number of used ops structs in the table. */
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    /**
	 * Storage for all possible ops structs.
	 */
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(::std::mem::size_of::<rte_mempool_ops_table>() , 2112usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops_table ) ) . sl as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops_table ) ) . num_ops as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mempool_ops_table ) ) . ops as *
                const _ as usize } , 64usize);
}
impl Clone for rte_mempool_ops_table {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * @internal Wrapper for mempool_ops alloc callback.
 *
 * @param mp
 *   Pointer to the memory pool.
 * @return
 *   - 0: Success; successfully allocated mempool pool_data.
 *   - <0: Error; code of alloc function.
 */
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @internal wrapper for mempool_ops get_count callback.
 *
 * @param mp
 *   Pointer to the memory pool.
 * @return
 *   The number of available objects in the external pool.
 */
    pub fn rte_mempool_ops_get_count(mp:
                                         *const rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @internal wrapper for mempool_ops free callback.
 *
 * @param mp
 *   Pointer to the memory pool.
 */
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool_objhdr_rte_mempool);
}
extern "C" {
    /**
 * Set the ops of a mempool.
 *
 * This can only be done on a mempool that is not populated, i.e. just after
 * a call to rte_mempool_create_empty().
 *
 * @param mp
 *   Pointer to the memory pool.
 * @param name
 *   Name of the ops structure to use for this mempool.
 * @param pool_config
 *   Opaque data that can be passed by the application to the ops functions.
 * @return
 *   - 0: Success; the mempool is now using the requested ops functions.
 *   - -EINVAL - Invalid ops struct name provided.
 *   - -EEXIST - mempool already has an ops struct assigned.
 */
    pub fn rte_mempool_set_ops_byname(mp: *mut rte_mempool_objhdr_rte_mempool,
                                      name: *const ::std::os::raw::c_char,
                                      pool_config:
                                          *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Register mempool operations.
 *
 * @param ops
 *   Pointer to an ops structure to register.
 * @return
 *   - >=0: Success; return the index of the ops struct in the table.
 *   - -EINVAL - some missing callbacks while registering ops struct.
 *   - -ENOSPC - the maximum number of ops structs has been reached.
 */
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops)
     -> ::std::os::raw::c_int;
}
/**
 * An object callback function for mempool.
 *
 * Used by rte_mempool_create() and rte_mempool_obj_iter().
 */
pub type rte_mempool_obj_cb_t =
    ::std::option::Option<unsafe extern "C" fn(mp:
                                                   *mut rte_mempool_objhdr_rte_mempool,
                                               opaque:
                                                   *mut ::std::os::raw::c_void,
                                               obj:
                                                   *mut ::std::os::raw::c_void,
                                               obj_idx:
                                                   ::std::os::raw::c_uint)>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
/**
 * A memory callback function for mempool.
 *
 * Used by rte_mempool_mem_iter().
 */
pub type rte_mempool_mem_cb_t =
    ::std::option::Option<unsafe extern "C" fn(mp:
                                                   *mut rte_mempool_objhdr_rte_mempool,
                                               opaque:
                                                   *mut ::std::os::raw::c_void,
                                               memhdr:
                                                   *mut rte_mempool_memhdr_list_rte_mempool_memhdr,
                                               mem_idx:
                                                   ::std::os::raw::c_uint)>;
/**
 * A mempool constructor callback function.
 *
 * Arguments are the mempool and the opaque pointer given by the user in
 * rte_mempool_create().
 */
pub type rte_mempool_ctor_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut rte_mempool_objhdr_rte_mempool,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /**
 * Create a new mempool named *name* in memory.
 *
 * This function uses ``rte_memzone_reserve()`` to allocate memory. The
 * pool contains n elements of elt_size. Its size is set to n.
 *
 * @param name
 *   The name of the mempool.
 * @param n
 *   The number of elements in the mempool. The optimum size (in terms of
 *   memory usage) for a mempool is when n is a power of two minus one:
 *   n = (2^q - 1).
 * @param elt_size
 *   The size of each element.
 * @param cache_size
 *   If cache_size is non-zero, the rte_mempool library will try to
 *   limit the accesses to the common lockless pool, by maintaining a
 *   per-lcore object cache. This argument must be lower or equal to
 *   CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose
 *   cache_size to have "n modulo cache_size == 0": if this is
 *   not the case, some elements will always stay in the pool and will
 *   never be used. The access to the per-lcore table is of course
 *   faster than the multi-producer/consumer pool. The cache can be
 *   disabled if the cache_size argument is set to 0; it can be useful to
 *   avoid losing objects in cache. Note that even if not used, the
 *   memory space for cache is always reserved in a mempool structure,
 *   except if CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE is set to 0.
 * @param private_data_size
 *   The size of the private data appended after the mempool
 *   structure. This is useful for storing some private data after the
 *   mempool structure, as is done for rte_mbuf_pool for example.
 * @param mp_init
 *   A function pointer that is called for initialization of the pool,
 *   before object initialization. The user can initialize the private
 *   data in this function if needed. This parameter can be NULL if
 *   not needed.
 * @param mp_init_arg
 *   An opaque pointer to data that can be used in the mempool
 *   constructor function.
 * @param obj_init
 *   A function pointer that is called for each object at
 *   initialization of the pool. The user can set some meta data in
 *   objects if needed. This parameter can be NULL if not needed.
 *   The obj_init() function takes the mempool pointer, the init_arg,
 *   the object pointer and the object number as parameters.
 * @param obj_init_arg
 *   An opaque pointer to data that can be used as an argument for
 *   each call to the object constructor function.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in the case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   The *flags* arguments is an OR of following flags:
 *   - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread
 *     between channels in RAM: the pool allocator will add padding
 *     between objects depending on the hardware configuration. See
 *     Memory alignment constraints for details. If this flag is set,
 *     the allocator will just align them to a cache line.
 *   - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are
 *     cache-aligned. This flag removes this constraint, and no
 *     padding will be present between objects. This flag implies
 *     MEMPOOL_F_NO_SPREAD.
 *   - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior
 *     when using rte_mempool_put() or rte_mempool_put_bulk() is
 *     "single-producer". Otherwise, it is "multi-producers".
 *   - MEMPOOL_F_SC_GET: If this flag is set, the default behavior
 *     when using rte_mempool_get() or rte_mempool_get_bulk() is
 *     "single-consumer". Otherwise, it is "multi-consumers".
 *   - MEMPOOL_F_NO_PHYS_CONTIG: If set, allocated objects won't
 *     necessarilly be contiguous in physical memory.
 * @return
 *   The pointer to the new allocated mempool, on success. NULL on error
 *   with rte_errno set appropriately. Possible rte_errno values include:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - EINVAL - cache size provided is too large
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */
    pub fn rte_mempool_create(name: *const ::std::os::raw::c_char,
                              n: ::std::os::raw::c_uint,
                              elt_size: ::std::os::raw::c_uint,
                              cache_size: ::std::os::raw::c_uint,
                              private_data_size: ::std::os::raw::c_uint,
                              mp_init: rte_mempool_ctor_t,
                              mp_init_arg: *mut ::std::os::raw::c_void,
                              obj_init: rte_mempool_obj_cb_t,
                              obj_init_arg: *mut ::std::os::raw::c_void,
                              socket_id: ::std::os::raw::c_int,
                              flags: ::std::os::raw::c_uint)
     -> *mut rte_mempool_objhdr_rte_mempool;
}
extern "C" {
    /**
 * Create a new mempool named *name* in memory.
 *
 * The pool contains n elements of elt_size. Its size is set to n.
 * This function uses ``memzone_reserve()`` to allocate the mempool header
 * (and the objects if vaddr is NULL).
 * Depending on the input parameters, mempool elements can be either allocated
 * together with the mempool header, or an externally provided memory buffer
 * could be used to store mempool objects. In later case, that external
 * memory buffer can consist of set of disjoint physical pages.
 *
 * @param name
 *   The name of the mempool.
 * @param n
 *   The number of elements in the mempool. The optimum size (in terms of
 *   memory usage) for a mempool is when n is a power of two minus one:
 *   n = (2^q - 1).
 * @param elt_size
 *   The size of each element.
 * @param cache_size
 *   Size of the cache. See rte_mempool_create() for details.
 * @param private_data_size
 *   The size of the private data appended after the mempool
 *   structure. This is useful for storing some private data after the
 *   mempool structure, as is done for rte_mbuf_pool for example.
 * @param mp_init
 *   A function pointer that is called for initialization of the pool,
 *   before object initialization. The user can initialize the private
 *   data in this function if needed. This parameter can be NULL if
 *   not needed.
 * @param mp_init_arg
 *   An opaque pointer to data that can be used in the mempool
 *   constructor function.
 * @param obj_init
 *   A function called for each object at initialization of the pool.
 *   See rte_mempool_create() for details.
 * @param obj_init_arg
 *   An opaque pointer passed to the object constructor function.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in the case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   Flags controlling the behavior of the mempool. See
 *   rte_mempool_create() for details.
 * @param vaddr
 *   Virtual address of the externally allocated memory buffer.
 *   Will be used to store mempool objects.
 * @param paddr
 *   Array of physical addresses of the pages that comprises given memory
 *   buffer.
 * @param pg_num
 *   Number of elements in the paddr array.
 * @param pg_shift
 *   LOG2 of the physical pages size.
 * @return
 *   The pointer to the new allocated mempool, on success. NULL on error
 *   with rte_errno set appropriately. See rte_mempool_create() for details.
 */
    pub fn rte_mempool_xmem_create(name: *const ::std::os::raw::c_char,
                                   n: ::std::os::raw::c_uint,
                                   elt_size: ::std::os::raw::c_uint,
                                   cache_size: ::std::os::raw::c_uint,
                                   private_data_size: ::std::os::raw::c_uint,
                                   mp_init: rte_mempool_ctor_t,
                                   mp_init_arg: *mut ::std::os::raw::c_void,
                                   obj_init: rte_mempool_obj_cb_t,
                                   obj_init_arg: *mut ::std::os::raw::c_void,
                                   socket_id: ::std::os::raw::c_int,
                                   flags: ::std::os::raw::c_uint,
                                   vaddr: *mut ::std::os::raw::c_void,
                                   paddr: *mut phys_addr_t, pg_num: u32,
                                   pg_shift: u32)
     -> *mut rte_mempool_objhdr_rte_mempool;
}
extern "C" {
    /**
 * Create an empty mempool
 *
 * The mempool is allocated and initialized, but it is not populated: no
 * memory is allocated for the mempool elements. The user has to call
 * rte_mempool_populate_*() to add memory chunks to the pool. Once
 * populated, the user may also want to initialize each object with
 * rte_mempool_obj_iter().
 *
 * @param name
 *   The name of the mempool.
 * @param n
 *   The maximum number of elements that can be added in the mempool.
 *   The optimum size (in terms of memory usage) for a mempool is when n
 *   is a power of two minus one: n = (2^q - 1).
 * @param elt_size
 *   The size of each element.
 * @param cache_size
 *   Size of the cache. See rte_mempool_create() for details.
 * @param private_data_size
 *   The size of the private data appended after the mempool
 *   structure. This is useful for storing some private data after the
 *   mempool structure, as is done for rte_mbuf_pool for example.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in the case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   Flags controlling the behavior of the mempool. See
 *   rte_mempool_create() for details.
 * @return
 *   The pointer to the new allocated mempool, on success. NULL on error
 *   with rte_errno set appropriately. See rte_mempool_create() for details.
 */
    pub fn rte_mempool_create_empty(name: *const ::std::os::raw::c_char,
                                    n: ::std::os::raw::c_uint,
                                    elt_size: ::std::os::raw::c_uint,
                                    cache_size: ::std::os::raw::c_uint,
                                    private_data_size: ::std::os::raw::c_uint,
                                    socket_id: ::std::os::raw::c_int,
                                    flags: ::std::os::raw::c_uint)
     -> *mut rte_mempool_objhdr_rte_mempool;
}
extern "C" {
    /**
 * Free a mempool
 *
 * Unlink the mempool from global list, free the memory chunks, and all
 * memory referenced by the mempool. The objects must not be used by
 * other cores as they will be freed.
 *
 * @param mp
 *   A pointer to the mempool structure.
 */
    pub fn rte_mempool_free(mp: *mut rte_mempool_objhdr_rte_mempool);
}
extern "C" {
    /**
 * Add physically contiguous memory for objects in the pool at init
 *
 * Add a virtually and physically contiguous memory chunk in the pool
 * where objects can be instanciated.
 *
 * If the given physical address is unknown (paddr = RTE_BAD_PHYS_ADDR),
 * the chunk doesn't need to be physically contiguous (only virtually),
 * and allocated objects may span two pages.
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @param vaddr
 *   The virtual address of memory that should be used to store objects.
 * @param paddr
 *   The physical address
 * @param len
 *   The length of memory in bytes.
 * @param free_cb
 *   The callback used to free this chunk when destroying the mempool.
 * @param opaque
 *   An opaque argument passed to free_cb.
 * @return
 *   The number of objects added on success.
 *   On error, the chunk is not added in the memory list of the
 *   mempool and a negative errno is returned.
 */
    pub fn rte_mempool_populate_phys(mp: *mut rte_mempool_objhdr_rte_mempool,
                                     vaddr: *mut ::std::os::raw::c_char,
                                     paddr: phys_addr_t, len: usize,
                                     free_cb: rte_mempool_memchunk_free_cb_t,
                                     opaque: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add physical memory for objects in the pool at init
 *
 * Add a virtually contiguous memory chunk in the pool where objects can
 * be instanciated. The physical addresses corresponding to the virtual
 * area are described in paddr[], pg_num, pg_shift.
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @param vaddr
 *   The virtual address of memory that should be used to store objects.
 * @param paddr
 *   An array of physical addresses of each page composing the virtual
 *   area.
 * @param pg_num
 *   Number of elements in the paddr array.
 * @param pg_shift
 *   LOG2 of the physical pages size.
 * @param free_cb
 *   The callback used to free this chunk when destroying the mempool.
 * @param opaque
 *   An opaque argument passed to free_cb.
 * @return
 *   The number of objects added on success.
 *   On error, the chunks are not added in the memory list of the
 *   mempool and a negative errno is returned.
 */
    pub fn rte_mempool_populate_phys_tab(mp:
                                             *mut rte_mempool_objhdr_rte_mempool,
                                         vaddr: *mut ::std::os::raw::c_char,
                                         paddr: *mut phys_addr_t, pg_num: u32,
                                         pg_shift: u32,
                                         free_cb:
                                             rte_mempool_memchunk_free_cb_t,
                                         opaque: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add virtually contiguous memory for objects in the pool at init
 *
 * Add a virtually contiguous memory chunk in the pool where objects can
 * be instanciated.
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @param addr
 *   The virtual address of memory that should be used to store objects.
 *   Must be page-aligned.
 * @param len
 *   The length of memory in bytes. Must be page-aligned.
 * @param pg_sz
 *   The size of memory pages in this virtual area.
 * @param free_cb
 *   The callback used to free this chunk when destroying the mempool.
 * @param opaque
 *   An opaque argument passed to free_cb.
 * @return
 *   The number of objects added on success.
 *   On error, the chunk is not added in the memory list of the
 *   mempool and a negative errno is returned.
 */
    pub fn rte_mempool_populate_virt(mp: *mut rte_mempool_objhdr_rte_mempool,
                                     addr: *mut ::std::os::raw::c_char,
                                     len: usize, pg_sz: usize,
                                     free_cb: rte_mempool_memchunk_free_cb_t,
                                     opaque: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add memory for objects in the pool at init
 *
 * This is the default function used by rte_mempool_create() to populate
 * the mempool. It adds memory allocated using rte_memzone_reserve().
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @return
 *   The number of objects added on success.
 *   On error, the chunk is not added in the memory list of the
 *   mempool and a negative errno is returned.
 */
    pub fn rte_mempool_populate_default(mp:
                                            *mut rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add memory from anonymous mapping for objects in the pool at init
 *
 * This function mmap an anonymous memory zone that is locked in
 * memory to store the objects of the mempool.
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @return
 *   The number of objects added on success.
 *   On error, the chunk is not added in the memory list of the
 *   mempool and a negative errno is returned.
 */
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Call a function for each mempool element
 *
 * Iterate across all objects attached to a rte_mempool and call the
 * callback function on it.
 *
 * @param mp
 *   A pointer to an initialized mempool.
 * @param obj_cb
 *   A function pointer that is called for each object.
 * @param obj_cb_arg
 *   An opaque pointer passed to the callback function.
 * @return
 *   Number of objects iterated.
 */
    pub fn rte_mempool_obj_iter(mp: *mut rte_mempool_objhdr_rte_mempool,
                                obj_cb: rte_mempool_obj_cb_t,
                                obj_cb_arg: *mut ::std::os::raw::c_void)
     -> u32;
}
extern "C" {
    /**
 * Call a function for each mempool memory chunk
 *
 * Iterate across all memory chunks attached to a rte_mempool and call
 * the callback function on it.
 *
 * @param mp
 *   A pointer to an initialized mempool.
 * @param mem_cb
 *   A function pointer that is called for each memory chunk.
 * @param mem_cb_arg
 *   An opaque pointer passed to the callback function.
 * @return
 *   Number of memory chunks iterated.
 */
    pub fn rte_mempool_mem_iter(mp: *mut rte_mempool_objhdr_rte_mempool,
                                mem_cb: rte_mempool_mem_cb_t,
                                mem_cb_arg: *mut ::std::os::raw::c_void)
     -> u32;
}
extern "C" {
    /**
 * Dump the status of the mempool to a file.
 *
 * @param f
 *   A pointer to a file for output
 * @param mp
 *   A pointer to the mempool structure.
 */
    pub fn rte_mempool_dump(f: *mut FILE,
                            mp: *mut rte_mempool_objhdr_rte_mempool);
}
extern "C" {
    /**
 * Create a user-owned mempool cache.
 *
 * This can be used by non-EAL threads to enable caching when they
 * interact with a mempool.
 *
 * @param size
 *   The size of the mempool cache. See rte_mempool_create()'s cache_size
 *   parameter description for more information. The same limits and
 *   considerations apply here too.
 * @param socket_id
 *   The socket identifier in the case of NUMA. The value can be
 *   SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone.
 */
    pub fn rte_mempool_cache_create(size: u32,
                                    socket_id: ::std::os::raw::c_int)
     -> *mut rte_mempool_cache;
}
extern "C" {
    /**
 * Free a user-owned mempool cache.
 *
 * @param cache
 *   A pointer to the mempool cache.
 */
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    /**
 * Return the number of entries in the mempool.
 *
 * When cache is enabled, this function has to browse the length of
 * all lcores, so it should not be used in a data path, but only for
 * debug purposes. User-owned mempool caches are not accounted for.
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @return
 *   The number of entries in the mempool.
 */
    pub fn rte_mempool_avail_count(mp: *const rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @deprecated
 * Return the number of entries in the mempool.
 *
 * When cache is enabled, this function has to browse the length of
 * all lcores, so it should not be used in a data path, but only for
 * debug purposes.
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @return
 *   The number of entries in the mempool.
 */
    pub fn rte_mempool_count(mp: *const rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * Return the number of elements which have been allocated from the mempool
 *
 * When cache is enabled, this function has to browse the length of
 * all lcores, so it should not be used in a data path, but only for
 * debug purposes.
 *
 * @param mp
 *   A pointer to the mempool structure.
 * @return
 *   The number of free entries in the mempool.
 */
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * Check the consistency of mempool objects.
 *
 * Verify the coherency of fields in the mempool structure. Also check
 * that the cookies of mempool objects (even the ones that are not
 * present in pool) have a correct value. If not, a panic will occur.
 *
 * @param mp
 *   A pointer to the mempool structure.
 */
    pub fn rte_mempool_audit(mp: *mut rte_mempool_objhdr_rte_mempool);
}
extern "C" {
    /**
 * Dump the status of all mempools on the console
 *
 * @param f
 *   A pointer to a file for output
 */
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    /**
 * Search a mempool from its name
 *
 * @param name
 *   The name of the mempool.
 * @return
 *   The pointer to the mempool matching the name, or NULL if not found.
 *   NULL on error
 *   with rte_errno set appropriately. Possible rte_errno values include:
 *    - ENOENT - required entry not available to return.
 *
 */
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char)
     -> *mut rte_mempool_objhdr_rte_mempool;
}
extern "C" {
    /**
 * Get the header, trailer and total size of a mempool element.
 *
 * Given a desired size of the mempool element and mempool flags,
 * calculates header, trailer, body and total sizes of the mempool object.
 *
 * @param elt_size
 *   The size of each element, without header and trailer.
 * @param flags
 *   The flags used for the mempool creation.
 *   Consult rte_mempool_create() for more information about possible values.
 *   The size of each element.
 * @param sz
 *   The calculated detailed size the mempool object. May be NULL.
 * @return
 *   Total size of the mempool object.
 */
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32,
                                     sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    /**
 * Get the size of memory required to store mempool elements.
 *
 * Calculate the maximum amount of memory required to store given number
 * of objects. Assume that the memory buffer will be aligned at page
 * boundary.
 *
 * Note that if object size is bigger then page size, then it assumes
 * that pages are grouped in subsets of physically continuous pages big
 * enough to store at least one object.
 *
 * @param elt_num
 *   Number of elements.
 * @param total_elt_sz
 *   The size of each element, including header and trailer, as returned
 *   by rte_mempool_calc_obj_size().
 * @param pg_shift
 *   LOG2 of the physical pages size. If set to 0, ignore page boundaries.
 * @return
 *   Required memory size aligned at page boundary.
 */
    pub fn rte_mempool_xmem_size(elt_num: u32, total_elt_sz: usize,
                                 pg_shift: u32) -> usize;
}
extern "C" {
    /**
 * Get the size of memory required to store mempool elements.
 *
 * Calculate how much memory would be actually required with the given
 * memory footprint to store required number of objects.
 *
 * @param vaddr
 *   Virtual address of the externally allocated memory buffer.
 *   Will be used to store mempool objects.
 * @param elt_num
 *   Number of elements.
 * @param total_elt_sz
 *   The size of each element, including header and trailer, as returned
 *   by rte_mempool_calc_obj_size().
 * @param paddr
 *   Array of physical addresses of the pages that comprises given memory
 *   buffer.
 * @param pg_num
 *   Number of elements in the paddr array.
 * @param pg_shift
 *   LOG2 of the physical pages size.
 * @return
 *   On success, the number of bytes needed to store given number of
 *   objects, aligned to the given page size. If the provided memory
 *   buffer is too small, return a negative value whose absolute value
 *   is the actual number of elements that can be stored in that buffer.
 */
    pub fn rte_mempool_xmem_usage(vaddr: *mut ::std::os::raw::c_void,
                                  elt_num: u32, total_elt_sz: usize,
                                  paddr: *mut phys_addr_t, pg_num: u32,
                                  pg_shift: u32) -> isize;
}
extern "C" {
    /**
 * Walk list of all memory pools
 *
 * @param func
 *   Iterator function
 * @param arg
 *   Argument passed to iterator
 */
    pub fn rte_mempool_walk(func:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut rte_mempool_objhdr_rte_mempool,
                                                                           arg:
                                                                               *mut ::std::os::raw::c_void)>,
                            arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * Get the name of the l2 packet type
 *
 * @param ptype
 *   The packet type value.
 * @return
 *   A non-null string describing the packet type.
 */
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Get the name of the l3 packet type
 *
 * @param ptype
 *   The packet type value.
 * @return
 *   A non-null string describing the packet type.
 */
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Get the name of the l4 packet type
 *
 * @param ptype
 *   The packet type value.
 * @return
 *   A non-null string describing the packet type.
 */
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Get the name of the tunnel packet type
 *
 * @param ptype
 *   The packet type value.
 * @return
 *   A non-null string describing the packet type.
 */
    pub fn rte_get_ptype_tunnel_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Get the name of the inner_l2 packet type
 *
 * @param ptype
 *   The packet type value.
 * @return
 *   A non-null string describing the packet type.
 */
    pub fn rte_get_ptype_inner_l2_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Get the name of the inner_l3 packet type
 *
 * @param ptype
 *   The packet type value.
 * @return
 *   A non-null string describing the packet type.
 */
    pub fn rte_get_ptype_inner_l3_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Get the name of the inner_l4 packet type
 *
 * @param ptype
 *   The packet type value.
 * @return
 *   A non-null string describing the packet type.
 */
    pub fn rte_get_ptype_inner_l4_name(ptype: u32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Write the packet type name into the buffer
 *
 * @param ptype
 *   The packet type value.
 * @param buf
 *   The buffer where the string is written.
 * @param buflen
 *   The length of the buffer.
 * @return
 *   - 0 on success
 *   - (-1) if the buffer is too small
 */
    pub fn rte_get_ptype_name(ptype: u32, buf: *mut ::std::os::raw::c_char,
                              buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the name of a RX offload flag
 *
 * @param mask
 *   The mask describing the flag.
 * @return
 *   The name of this flag, or NULL if it's not a valid RX flag.
 */
    pub fn rte_get_rx_ol_flag_name(mask: u64)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Dump the list of RX offload flags in a buffer
 *
 * @param mask
 *   The mask describing the RX flags.
 * @param buf
 *   The output buffer.
 * @param buflen
 *   The length of the buffer.
 * @return
 *   0 on success, (-1) on error.
 */
    pub fn rte_get_rx_ol_flag_list(mask: u64,
                                   buf: *mut ::std::os::raw::c_char,
                                   buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the name of a TX offload flag
 *
 * @param mask
 *   The mask describing the flag. Usually only one bit must be set.
 *   Several bits can be given if they belong to the same mask.
 *   Ex: PKT_TX_L4_MASK.
 * @return
 *   The name of this flag, or NULL if it's not a valid TX flag.
 */
    pub fn rte_get_tx_ol_flag_name(mask: u64)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Dump the list of TX offload flags in a buffer
 *
 * @param mask
 *   The mask describing the TX flags.
 * @param buf
 *   The output buffer.
 * @param buflen
 *   The length of the buffer.
 * @return
 *   0 on success, (-1) on error.
 */
    pub fn rte_get_tx_ol_flag_list(mask: u64,
                                   buf: *mut ::std::os::raw::c_char,
                                   buflen: usize) -> ::std::os::raw::c_int;
}
pub type MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type MARKER8 = [u8; 0usize];
/**
 * The generic rte_mbuf, containing a packet mbuf.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf {
    pub cacheline0: MARKER,
    /**< Virtual address of segment buffer. */
    pub buf_addr: *mut ::std::os::raw::c_void,
    /**< Physical address of segment buffer. */
    pub buf_physaddr: phys_addr_t,
    /**< Length of segment buffer. */
    pub buf_len: u16,
    pub rearm_data: MARKER8,
    pub data_off: u16,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    /**< Number of segments. */
    pub nb_segs: u8,
    /**< Input port. */
    pub port: u8,
    /**< Offload features. */
    pub ol_flags: u64,
    pub rx_descriptor_fields1: MARKER,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    /**< Total pkt len: sum of all segments. */
    pub pkt_len: u32,
    /**< Amount of data in segment buffer. */
    pub data_len: u16,
    /** VLAN TCI (CPU order), valid if PKT_RX_VLAN_STRIPPED is set. */
    pub vlan_tci: u16,
    /**< hash information */
    pub hash: rte_mbuf__bindgen_ty_3,
    /**< Sequence number. See also rte_reorder_insert() */
    pub seqn: u32,
    /** Outer VLAN TCI (CPU order), valid if PKT_RX_QINQ_STRIPPED is set. */
    pub vlan_tci_outer: u16,
    pub cacheline1: MARKER,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_4,
    /**< Pool from which mbuf was allocated. */
    pub pool: *mut rte_mempool_objhdr_rte_mempool,
    /**< Next segment of scattered packet. */
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_4: rte_mbuf__bindgen_ty_5,
    /** Size of the application private data. In case of an indirect
	 * mbuf, it stores the direct mbuf private data size. */
    pub priv_size: u16,
    /** Timesync flags for use with IEEE1588. */
    pub timesync: u16,
    pub __bindgen_padding_0: [u32; 7usize],
}
/**
	 * 16-bit Reference counter.
	 * It should only be accessed using the following functions:
	 * rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and
	 * rte_mbuf_refcnt_set(). The functionality of these functions (atomic,
	 * or non-atomic) is controlled by the CONFIG_RTE_MBUF_REFCNT_ATOMIC
	 * config option.
	 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_1 {
    /**< Atomically accessed refcnt */
    pub refcnt_atomic: __BindgenUnionField<rte_atomic16_t>,
    /**< Non-atomically accessed refcnt */
    pub refcnt: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_1>() , 2usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_1>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_1 ) ) .
                refcnt_atomic as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_1 ) ) . refcnt as *
                const _ as usize } , 0usize);
}
impl Clone for rte_mbuf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_2 {
    /**< L2/L3/L4 and tunnel information. */
    pub packet_type: __BindgenUnionField<u32>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>() ,
               4usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>()
                , 4usize);
}
impl Clone for rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (15usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u32) {
        self._bitfield_1 &= !(15usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (15usize as u32);
    }
    #[inline]
    pub fn l3_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (240usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u32) {
        self._bitfield_1 &= !(240usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (240usize as u32);
    }
    #[inline]
    pub fn l4_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3840usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u32) {
        self._bitfield_1 &= !(3840usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (3840usize as u32);
    }
    #[inline]
    pub fn tun_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (61440usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u32) {
        self._bitfield_1 &= !(61440usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (61440usize as u32);
    }
    #[inline]
    pub fn inner_l2_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (983040usize as u32))
                                       >> 16u32) as u32)
        }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u32) {
        self._bitfield_1 &= !(983040usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (983040usize as u32);
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (15728640usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u32) {
        self._bitfield_1 &= !(15728640usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (15728640usize as u32);
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (251658240usize as u32)) >> 24u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u32) {
        self._bitfield_1 &= !(251658240usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (251658240usize as u32);
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_2>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_2>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_2 ) ) . packet_type
                as * const _ as usize } , 0usize);
}
impl Clone for rte_mbuf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3 {
    /**< RSS hash result if RSS enabled */
    pub rss: __BindgenUnionField<u32>,
    /**< Filter identifier if FDIR enabled */
    pub fdir: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_1>,
    /**< Hierarchical scheduler */
    pub sched: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_2>,
    /**< User defined tags. See rte_distributor_process() */
    pub usr: __BindgenUnionField<u32>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub lo: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 2usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . hash as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . id as * const _ as usize } , 2usize);
}
impl Clone for
 rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
                , 4usize);
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ) . lo as
                * const _ as usize } , 0usize);
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>() ,
               8usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>()
                , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3__bindgen_ty_1 ) )
                . hi as * const _ as usize } , 4usize);
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_2 {
    pub lo: u32,
    pub hi: u32,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>() ,
               8usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>()
                , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) )
                . lo as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3__bindgen_ty_2 ) )
                . hi as * const _ as usize } , 4usize);
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_3>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_3>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . rss as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . fdir as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . sched as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_3 ) ) . usr as *
                const _ as usize } , 0usize);
}
impl Clone for rte_mbuf__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_4 {
    /**< Can be used for external metadata */
    pub userdata: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /**< Allow 8-byte userdata on 32-bit */
    pub udata64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_4>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_4>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_4 ) ) . userdata as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_4 ) ) . udata64 as *
                const _ as usize } , 0usize);
}
impl Clone for rte_mbuf__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_5 {
    /**< combined for easy fetch */
    pub tx_offload: __BindgenUnionField<u64>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_5__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>() ,
               8usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>()
                , 8usize);
}
impl Clone for rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (127usize as u64)) >>
                                       0u32) as u64)
        }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        self._bitfield_1 &= !(127usize as u64);
        self._bitfield_1 |= ((val as u64 as u64) << 0u32) & (127usize as u64);
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65408usize as u64)) >>
                                       7u32) as u64)
        }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        self._bitfield_1 &= !(65408usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 7u32) & (65408usize as u64);
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16711680usize as u64))
                                       >> 16u32) as u64)
        }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        self._bitfield_1 &= !(16711680usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 16u32) & (16711680usize as u64);
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1099494850560usize as u64)) >> 24u32)
                                      as u64)
        }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        self._bitfield_1 &= !(1099494850560usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 24u32) & (1099494850560usize as u64);
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (561850441793536usize as u64)) >>
                                       40u32) as u64)
        }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        self._bitfield_1 &= !(561850441793536usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 40u32) & (561850441793536usize as u64);
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (71494644084506624usize as u64)) >>
                                       49u32) as u64)
        }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        self._bitfield_1 &= !(71494644084506624usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 49u32) & (71494644084506624usize as u64);
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<rte_mbuf__bindgen_ty_5>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_mbuf__bindgen_ty_5>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf__bindgen_ty_5 ) ) . tx_offload
                as * const _ as usize } , 0usize);
}
impl Clone for rte_mbuf__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    assert_eq!(::std::mem::size_of::<rte_mbuf>() , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . cacheline0 as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . buf_addr as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . buf_physaddr as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . buf_len as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . rearm_data as * const _ as
                usize } , 18usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . data_off as * const _ as
                usize } , 18usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . nb_segs as * const _ as
                usize } , 22usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . port as * const _ as usize
                } , 23usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . ol_flags as * const _ as
                usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . rx_descriptor_fields1 as *
                const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . pkt_len as * const _ as
                usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . data_len as * const _ as
                usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . vlan_tci as * const _ as
                usize } , 42usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . hash as * const _ as usize
                } , 44usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . seqn as * const _ as usize
                } , 52usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . vlan_tci_outer as * const
                _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . cacheline1 as * const _ as
                usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . pool as * const _ as usize
                } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . next as * const _ as usize
                } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . priv_size as * const _ as
                usize } , 96usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_mbuf ) ) . timesync as * const _ as
                usize } , 98usize);
}
impl Clone for rte_mbuf {
    fn clone(&self) -> Self { *self }
}
/**
 * Private data in case of pktmbuf pool.
 *
 * A structure that contains some pktmbuf_pool-specific data that are
 * appended after the mempool structure (in private data).
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pktmbuf_pool_private {
    /**< Size of data space in each mbuf. */
    pub mbuf_data_room_size: u16,
    /**< Size of private area in each mbuf. */
    pub mbuf_priv_size: u16,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_pool_private() {
    assert_eq!(::std::mem::size_of::<rte_pktmbuf_pool_private>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_pktmbuf_pool_private>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pktmbuf_pool_private ) ) .
                mbuf_data_room_size as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pktmbuf_pool_private ) ) .
                mbuf_priv_size as * const _ as usize } , 2usize);
}
impl Clone for rte_pktmbuf_pool_private {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Sanity checks on an mbuf.
 *
 * Check the consistency of the given mbuf. The function will cause a
 * panic if corruption is detected.
 *
 * @param m
 *   The mbuf to be checked.
 * @param is_header
 *   True if the mbuf is a packet header, false if it is a sub-segment
 *   of a packet (in this case, some fields like nb_segs are not checked)
 */
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf,
                                 is_header: ::std::os::raw::c_int);
}
extern "C" {
    /**
 * The control mbuf constructor.
 *
 * This function initializes some fields in an mbuf structure that are
 * not modified by the user once created (mbuf type, origin pool, buffer
 * start address, and so on). This function is given as a callback function
 * to rte_mempool_create() at pool creation time.
 *
 * @param mp
 *   The mempool from which the mbuf is allocated.
 * @param opaque_arg
 *   A pointer that can be used by the user to retrieve useful information
 *   for mbuf initialization. This pointer comes from the ``init_arg``
 *   parameter of rte_mempool_create().
 * @param m
 *   The mbuf to initialize.
 * @param i
 *   The index of the mbuf in the pool table.
 */
    pub fn rte_ctrlmbuf_init(mp: *mut rte_mempool_objhdr_rte_mempool,
                             opaque_arg: *mut ::std::os::raw::c_void,
                             m: *mut ::std::os::raw::c_void,
                             i: ::std::os::raw::c_uint);
}
extern "C" {
    /**
 * The packet mbuf constructor.
 *
 * This function initializes some fields in the mbuf structure that are
 * not modified by the user once created (origin pool, buffer start
 * address, and so on). This function is given as a callback function to
 * rte_mempool_create() at pool creation time.
 *
 * @param mp
 *   The mempool from which mbufs originate.
 * @param opaque_arg
 *   A pointer that can be used by the user to retrieve useful information
 *   for mbuf initialization. This pointer comes from the ``init_arg``
 *   parameter of rte_mempool_create().
 * @param m
 *   The mbuf to initialize.
 * @param i
 *   The index of the mbuf in the pool table.
 */
    pub fn rte_pktmbuf_init(mp: *mut rte_mempool_objhdr_rte_mempool,
                            opaque_arg: *mut ::std::os::raw::c_void,
                            m: *mut ::std::os::raw::c_void,
                            i: ::std::os::raw::c_uint);
}
extern "C" {
    /**
 * A  packet mbuf pool constructor.
 *
 * This function initializes the mempool private data in the case of a
 * pktmbuf pool. This private data is needed by the driver. The
 * function is given as a callback function to rte_mempool_create() at
 * pool creation. It can be extended by the user, for example, to
 * provide another packet size.
 *
 * @param mp
 *   The mempool from which mbufs originate.
 * @param opaque_arg
 *   A pointer that can be used by the user to retrieve useful information
 *   for mbuf initialization. This pointer comes from the ``init_arg``
 *   parameter of rte_mempool_create().
 */
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool_objhdr_rte_mempool,
                                 opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * Create a mbuf pool.
 *
 * This function creates and initializes a packet mbuf pool. It is
 * a wrapper to rte_mempool_create() with the proper packet constructor
 * and mempool constructor.
 *
 * @param name
 *   The name of the mbuf pool.
 * @param n
 *   The number of elements in the mbuf pool. The optimum size (in terms
 *   of memory usage) for a mempool is when n is a power of two minus one:
 *   n = (2^q - 1).
 * @param cache_size
 *   Size of the per-core object cache. See rte_mempool_create() for
 *   details.
 * @param priv_size
 *   Size of application private are between the rte_mbuf structure
 *   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.
 * @param data_room_size
 *   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.
 * @param socket_id
 *   The socket identifier where the memory should be allocated. The
 *   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the
 *   reserved zone.
 * @return
 *   The pointer to the new allocated mempool, on success. NULL on error
 *   with rte_errno set appropriately. Possible rte_errno values include:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - EINVAL - cache size provided is too large, or priv_size is not aligned.
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */
    pub fn rte_pktmbuf_pool_create(name: *const ::std::os::raw::c_char,
                                   n: ::std::os::raw::c_uint,
                                   cache_size: ::std::os::raw::c_uint,
                                   priv_size: u16, data_room_size: u16,
                                   socket_id: ::std::os::raw::c_int)
     -> *mut rte_mempool_objhdr_rte_mempool;
}
extern "C" {
    /**
 * Dump an mbuf structure to a file.
 *
 * Dump all fields for the given packet mbuf and all its associated
 * segments (in the case of a chained buffer).
 *
 * @param f
 *   A pointer to a file for output
 * @param m
 *   The packet mbuf.
 * @param dump_len
 *   If dump_len != 0, also dump the "dump_len" first data bytes of
 *   the packet.
 */
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf,
                            dump_len: ::std::os::raw::c_uint);
}
/**
 * Ethernet address:
 * A universally administered address is uniquely assigned to a device by its
 * manufacturer. The first three octets (in transmission order) contain the
 * Organizationally Unique Identifier (OUI). The following three (MAC-48 and
 * EUI-48) octets are assigned by that organization with the only constraint
 * of uniqueness.
 * A locally administered address is assigned to a device by a network
 * administrator and does not contain OUIs.
 * See http://standards.ieee.org/regauth/groupmac/tutorial.html
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ether_addr {
    /**< Addr bytes in tx order */
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(::std::mem::size_of::<ether_addr>() , 6usize);
    assert_eq! (::std::mem::align_of::<ether_addr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_addr ) ) . addr_bytes as * const _
                as usize } , 0usize);
}
impl Clone for ether_addr {
    fn clone(&self) -> Self { *self }
}
/**
 * Ethernet header: Contains the destination address, source address
 * and frame type.
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ether_hdr {
    /**< Destination address. */
    pub d_addr: ether_addr,
    /**< Source address. */
    pub s_addr: ether_addr,
    /**< Frame type. */
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_ether_hdr() {
    assert_eq!(::std::mem::size_of::<ether_hdr>() , 14usize);
    assert_eq! (::std::mem::align_of::<ether_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_hdr ) ) . d_addr as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_hdr ) ) . s_addr as * const _ as
                usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_hdr ) ) . ether_type as * const _
                as usize } , 12usize);
}
impl Clone for ether_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * Ethernet VLAN Header.
 * Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type
 * of the encapsulated frame.
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct vlan_hdr {
    /**< Priority (3) + CFI (1) + Identifier Code (12) */
    pub vlan_tci: u16,
    /**< Ethernet type of encapsulated frame. */
    pub eth_proto: u16,
}
#[test]
fn bindgen_test_layout_vlan_hdr() {
    assert_eq!(::std::mem::size_of::<vlan_hdr>() , 4usize);
    assert_eq! (::std::mem::align_of::<vlan_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const vlan_hdr ) ) . vlan_tci as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const vlan_hdr ) ) . eth_proto as * const _ as
                usize } , 2usize);
}
impl Clone for vlan_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * VXLAN protocol header.
 * Contains the 8-bit flag, 24-bit VXLAN Network Identifier and
 * Reserved fields (24 bits and 8 bits)
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct vxlan_hdr {
    /**< flag (8) + Reserved (24). */
    pub vx_flags: u32,
    /**< VNI (24) + Reserved (8). */
    pub vx_vni: u32,
}
#[test]
fn bindgen_test_layout_vxlan_hdr() {
    assert_eq!(::std::mem::size_of::<vxlan_hdr>() , 8usize);
    assert_eq! (::std::mem::align_of::<vxlan_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const vxlan_hdr ) ) . vx_flags as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const vxlan_hdr ) ) . vx_vni as * const _ as
                usize } , 4usize);
}
impl Clone for vxlan_hdr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Create a bonded rte_eth_dev device
 *
 * @param name			Name of new link bonding device.
 * @param mode			Mode to initialize bonding device in.
 * @param socket_id		Socket Id on which to allocate eth_dev resources.
 *
 * @return
 *	Port Id of created rte_eth_dev on success, negative value otherwise
 */
    pub fn rte_eth_bond_create(name: *const ::std::os::raw::c_char, mode: u8,
                               socket_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Free a bonded rte_eth_dev device
 *
 * @param name			Name of the link bonding device.
 *
 * @return
 *	0 on success, negative value otherwise
 */
    pub fn rte_eth_bond_free(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add a rte_eth_dev device as a slave to the bonded device
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param slave_port_id		Port ID of slave device.
 *
 * @return
 *	0 on success, negative value otherwise
 */
    pub fn rte_eth_bond_slave_add(bonded_port_id: u8, slave_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Remove a slave rte_eth_dev device from the bonded device
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param slave_port_id		Port ID of slave device.
 *
 * @return
 *	0 on success, negative value otherwise
 */
    pub fn rte_eth_bond_slave_remove(bonded_port_id: u8, slave_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set link bonding mode of bonded device
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param mode				Bonding mode to set
 *
 * @return
 *	0 on success, negative value otherwise
 */
    pub fn rte_eth_bond_mode_set(bonded_port_id: u8, mode: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get link bonding mode of bonded device
 *
 * @param bonded_port_id	Port ID of bonded device.
 *
 * @return
 *	link bonding mode on success, negative value otherwise
 */
    pub fn rte_eth_bond_mode_get(bonded_port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set slave rte_eth_dev as primary slave of bonded device
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param slave_port_id		Port ID of slave device.
 *
 * @return
 *	0 on success, negative value otherwise
 */
    pub fn rte_eth_bond_primary_set(bonded_port_id: u8, slave_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get primary slave of bonded device
 *
 * @param bonded_port_id	Port ID of bonded device.
 *
 * @return
 *	Port Id of primary slave on success, -1 on failure
 */
    pub fn rte_eth_bond_primary_get(bonded_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Populate an array with list of the slaves port id's of the bonded device
 *
 * @param bonded_port_id	Port ID of bonded eth_dev to interrogate
 * @param slaves			Array to be populated with the current active slaves
 * @param len				Length of slaves array
 *
 * @return
 *	Number of slaves associated with bonded device on success,
 *	negative value otherwise
 */
    pub fn rte_eth_bond_slaves_get(bonded_port_id: u8, slaves: *mut u8,
                                   len: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Populate an array with list of the active slaves port id's of the bonded
 * device.
 *
 * @param bonded_port_id	Port ID of bonded eth_dev to interrogate
 * @param slaves			Array to be populated with the current active slaves
 * @param len				Length of slaves array
 *
 * @return
 *	Number of active slaves associated with bonded device on success,
 *	negative value otherwise
 */
    pub fn rte_eth_bond_active_slaves_get(bonded_port_id: u8, slaves: *mut u8,
                                          len: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set explicit MAC address to use on bonded device and it's slaves.
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param mac_addr			MAC Address to use on bonded device overriding
 *							slaves MAC addresses
 *
 * @return
 *	0 on success, negative value otherwise
 */
    pub fn rte_eth_bond_mac_address_set(bonded_port_id: u8,
                                        mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Reset bonded device to use MAC from primary slave on bonded device and it's
 * slaves.
 *
 * @param bonded_port_id	Port ID of bonded device.
 *
 * @return
 *	0 on success, negative value otherwise
 */
    pub fn rte_eth_bond_mac_address_reset(bonded_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the transmit policy for bonded device to use when it is operating in
 * balance mode, this parameter is otherwise ignored in other modes of
 * operation.
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param policy			Balance mode transmission policy.
 *
 * @return
 *	0 on success, negative value otherwise.
 */
    pub fn rte_eth_bond_xmit_policy_set(bonded_port_id: u8, policy: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the transmit policy set on bonded device for balance mode operation
 *
 * @param bonded_port_id	Port ID of bonded device.
 *
 * @return
 *	Balance transmit policy on success, negative value otherwise.
 */
    pub fn rte_eth_bond_xmit_policy_get(bonded_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the link monitoring frequency (in ms) for monitoring the link status of
 * slave devices
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param internal_ms		Monitoring interval in milliseconds
 *
 * @return
 *	0 on success, negative value otherwise.
 */
    pub fn rte_eth_bond_link_monitoring_set(bonded_port_id: u8,
                                            internal_ms: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the current link monitoring frequency (in ms) for monitoring of the link
 * status of slave devices
 *
 * @param bonded_port_id	Port ID of bonded device.
 *
 * @return
 *	Monitoring interval on success, negative value otherwise.
 */
    pub fn rte_eth_bond_link_monitoring_get(bonded_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the period in milliseconds for delaying the disabling of a bonded link
 * when the link down status has been detected
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param delay_ms			Delay period in milliseconds.
 *
 * @return
 *  0 on success, negative value otherwise.
 */
    pub fn rte_eth_bond_link_down_prop_delay_set(bonded_port_id: u8,
                                                 delay_ms: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the period in milliseconds set for delaying the disabling of a bonded
 * link when the link down status has been detected
 *
 * @param bonded_port_id	Port ID of bonded device.
 *
 * @return
 *  Delay period on success, negative value otherwise.
 */
    pub fn rte_eth_bond_link_down_prop_delay_get(bonded_port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the period in milliseconds for delaying the enabling of a bonded link
 * when the link up status has been detected
 *
 * @param bonded_port_id	Port ID of bonded device.
 * @param delay_ms			Delay period in milliseconds.
 *
 * @return
 *  0 on success, negative value otherwise.
 */
    pub fn rte_eth_bond_link_up_prop_delay_set(bonded_port_id: u8,
                                               delay_ms: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get the period in milliseconds set for delaying the enabling of a bonded
 * link when the link up status has been detected
 *
 * @param bonded_port_id	Port ID of bonded device.
 *
 * @return
 *  Delay period on success, negative value otherwise.
 */
    pub fn rte_eth_bond_link_up_prop_delay_get(bonded_port_id: u8)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_cfgfile([u8; 0]);
/** Configuration file entry */
#[repr(C)]
pub struct rte_cfgfile_entry {
    /**< Name */
    pub name: [::std::os::raw::c_char; 64usize],
    /**< Value */
    pub value: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_rte_cfgfile_entry() {
    assert_eq!(::std::mem::size_of::<rte_cfgfile_entry>() , 320usize);
    assert_eq! (::std::mem::align_of::<rte_cfgfile_entry>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cfgfile_entry ) ) . name as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_cfgfile_entry ) ) . value as * const
                _ as usize } , 64usize);
}
extern "C" {
    /**
* Open config file
*
* @param filename
*   Config file name
* @param flags
*   Config file flags, Reserved for future use. Must be set to 0.
* @return
*   Handle to configuration file on success, NULL otherwise
*/
    pub fn rte_cfgfile_load(filename: *const ::std::os::raw::c_char,
                            flags: ::std::os::raw::c_int) -> *mut rte_cfgfile;
}
extern "C" {
    /**
* Get number of sections in config file
*
* @param cfg
*   Config file
* @param sec_name
*   Section name
* @param length
*   Maximum section name length
* @return
*   Number of sections
*/
    pub fn rte_cfgfile_num_sections(cfg: *mut rte_cfgfile,
                                    sec_name: *const ::std::os::raw::c_char,
                                    length: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Get name of all config file sections.
*
* Fills in the array sections with the name of all the sections in the file
* (up to the number of max_sections sections).
*
* @param cfg
*   Config file
* @param sections
*   Array containing section names after successful invocation. Each element
*   of this array should be preallocated by the user with at least
*   CFG_NAME_LEN characters.
* @param max_sections
*   Maximum number of section names to be stored in sections array
* @return
*   Number of populated sections names
*/
    pub fn rte_cfgfile_sections(cfg: *mut rte_cfgfile,
                                sections: *mut *mut ::std::os::raw::c_char,
                                max_sections: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Check if given section exists in config file
*
* @param cfg
*   Config file
* @param sectionname
*   Section name
* @return
*   TRUE (value different than 0) if section exists, FALSE (value 0) otherwise
*/
    pub fn rte_cfgfile_has_section(cfg: *mut rte_cfgfile,
                                   sectionname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Get number of entries in given config file section
*
* If multiple sections have the given name this function operates on the
* first one.
*
* @param cfg
*   Config file
* @param sectionname
*   Section name
* @return
*   Number of entries in section on success, -1 otherwise
*/
    pub fn rte_cfgfile_section_num_entries(cfg: *mut rte_cfgfile,
                                           sectionname:
                                               *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Get section entries as key-value pairs
*
* If multiple sections have the given name this function operates on the
* first one.
*
* @param cfg
*   Config file
* @param sectionname
*   Section name
* @param entries
*   Pre-allocated array of at least max_entries entries where the section
*   entries are stored as key-value pair after successful invocation
* @param max_entries
*   Maximum number of section entries to be stored in entries array
* @return
*   Number of entries populated on success, -1 otherwise
*/
    pub fn rte_cfgfile_section_entries(cfg: *mut rte_cfgfile,
                                       sectionname:
                                           *const ::std::os::raw::c_char,
                                       entries: *mut rte_cfgfile_entry,
                                       max_entries: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Get section entries as key-value pairs
*
* The index of a section is the same as the index of its name in the
* result of rte_cfgfile_sections. This API can be used when there are
* multiple sections with the same name.
*
* @param cfg
*   Config file
* @param index
*   Section index
* @param sectionname
*   Pre-allocated string of at least CFG_NAME_LEN characters where the
*   section name is stored after successful invocation.
* @param entries
*   Pre-allocated array of at least max_entries entries where the section
*   entries are stored as key-value pair after successful invocation
* @param max_entries
*   Maximum number of section entries to be stored in entries array
* @return
*   Number of entries populated on success, -1 otherwise
*/
    pub fn rte_cfgfile_section_entries_by_index(cfg: *mut rte_cfgfile,
                                                index: ::std::os::raw::c_int,
                                                sectionname:
                                                    *mut ::std::os::raw::c_char,
                                                entries:
                                                    *mut rte_cfgfile_entry,
                                                max_entries:
                                                    ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Get value of the named entry in named config file section
*
* If multiple sections have the given name this function operates on the
* first one.
*
* @param cfg
*   Config file
* @param sectionname
*   Section name
* @param entryname
*   Entry name
* @return
*   Entry value on success, NULL otherwise
*/
    pub fn rte_cfgfile_get_entry(cfg: *mut rte_cfgfile,
                                 sectionname: *const ::std::os::raw::c_char,
                                 entryname: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
* Check if given entry exists in named config file section
*
* If multiple sections have the given name this function operates on the
* first one.
*
* @param cfg
*   Config file
* @param sectionname
*   Section name
* @param entryname
*   Entry name
* @return
*   TRUE (value different than 0) if entry exists, FALSE (value 0) otherwise
*/
    pub fn rte_cfgfile_has_entry(cfg: *mut rte_cfgfile,
                                 sectionname: *const ::std::os::raw::c_char,
                                 entryname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Close config file
*
* @param cfg
*   Config file
* @return
*   0 on success, -1 otherwise
*/
    pub fn rte_cfgfile_close(cfg: *mut rte_cfgfile) -> ::std::os::raw::c_int;
}
/**
 * Stores a pointer to the ops struct, and the offset: the place to
 * write the parsed result in the destination structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_hdr {
    pub ops: *mut cmdline_token_hdr_cmdline_token_ops,
    pub offset: ::std::os::raw::c_uint,
}
/**
 * A token is defined by this structure.
 *
 * parse() takes the token as first argument, then the source buffer
 * starting at the token we want to parse. The 3rd arg is a pointer
 * where we store the parsed data (as binary). It returns the number of
 * parsed chars on success and a negative value on error.
 *
 * complete_get_nb() returns the number of possible values for this
 * token if completion is possible. If it is NULL or if it returns 0,
 * no completion is possible.
 *
 * complete_get_elt() copy in dstbuf (the size is specified in the
 * parameter) the i-th possible completion for this token.  returns 0
 * on success or and a negative value on error.
 *
 * get_help() fills the dstbuf with the help for the token. It returns
 * -1 on error and 0 on success.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_hdr_cmdline_token_ops {
    /** parse(token ptr, buf, res pts, buf len) */
    pub parse: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut cmdline_parse_token_hdr_t,
                                                          arg2:
                                                              *const ::std::os::raw::c_char,
                                                          arg3:
                                                              *mut ::std::os::raw::c_void,
                                                          arg4:
                                                              ::std::os::raw::c_uint)
                                         -> ::std::os::raw::c_int>,
    /** return the num of possible choices for this token */
    pub complete_get_nb: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut cmdline_parse_token_hdr_t)
                                                   -> ::std::os::raw::c_int>,
    /** return the elt x for this token (token, idx, dstbuf, size) */
    pub complete_get_elt: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut cmdline_parse_token_hdr_t,
                                                                     arg2:
                                                                         ::std::os::raw::c_int,
                                                                     arg3:
                                                                         *mut ::std::os::raw::c_char,
                                                                     arg4:
                                                                         ::std::os::raw::c_uint)
                                                    -> ::std::os::raw::c_int>,
    /** get help for this token (token, dstbuf, size) */
    pub get_help: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut cmdline_parse_token_hdr_t,
                                                             arg2:
                                                                 *mut ::std::os::raw::c_char,
                                                             arg3:
                                                                 ::std::os::raw::c_uint)
                                            -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_cmdline_token_hdr_cmdline_token_ops() {
    assert_eq!(::std::mem::size_of::<cmdline_token_hdr_cmdline_token_ops>() ,
               32usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_hdr_cmdline_token_ops>()
                , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr_cmdline_token_ops ) ) .
                parse as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr_cmdline_token_ops ) ) .
                complete_get_nb as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr_cmdline_token_ops ) ) .
                complete_get_elt as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr_cmdline_token_ops ) ) .
                get_help as * const _ as usize } , 24usize);
}
impl Clone for cmdline_token_hdr_cmdline_token_ops {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_cmdline_token_hdr() {
    assert_eq!(::std::mem::size_of::<cmdline_token_hdr>() , 16usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_hdr>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr ) ) . ops as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_hdr ) ) . offset as * const
                _ as usize } , 8usize);
}
impl Clone for cmdline_token_hdr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_hdr_t = cmdline_token_hdr;
#[repr(C)]
pub struct cmdline {
    pub s_in: ::std::os::raw::c_int,
    pub s_out: ::std::os::raw::c_int,
    pub ctx: *mut cmdline_parse_ctx_t,
    pub rdl: rdline,
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub oldterm: termios,
}
#[test]
fn bindgen_test_layout_cmdline() {
    assert_eq!(::std::mem::size_of::<cmdline>() , 10024usize);
    assert_eq! (::std::mem::align_of::<cmdline>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . s_in as * const _ as usize
                } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . s_out as * const _ as usize
                } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . ctx as * const _ as usize }
                , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . rdl as * const _ as usize }
                , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . prompt as * const _ as
                usize } , 9928usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline ) ) . oldterm as * const _ as
                usize } , 9960usize);
}
/**
 * Store a instruction, which is a pointer to a callback function and
 * its parameter that is called when the instruction is parsed, a help
 * string, and a list of token composing this instruction.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_inst {
    pub f: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                          *mut ::std::os::raw::c_void,
                                                      arg2: *mut cmdline,
                                                      arg3:
                                                          *mut ::std::os::raw::c_void)>,
    pub data: *mut ::std::os::raw::c_void,
    pub help_str: *const ::std::os::raw::c_char,
    pub tokens: __IncompleteArrayField<*mut cmdline_parse_token_hdr_t>,
}
#[test]
fn bindgen_test_layout_cmdline_inst() {
    assert_eq!(::std::mem::size_of::<cmdline_inst>() , 24usize);
    assert_eq! (::std::mem::align_of::<cmdline_inst>() , 8usize);
}
impl Clone for cmdline_inst {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_inst_t = cmdline_inst;
/**
 * A context is identified by its name, and contains a list of
 * instruction
 *
 */
pub type cmdline_parse_ctx_t = *mut cmdline_parse_inst_t;
extern "C" {
    /**
 * Try to parse a buffer according to the specified context. The
 * argument buf must ends with "\n\0". The function returns
 * CMDLINE_PARSE_AMBIGUOUS, CMDLINE_PARSE_NOMATCH or
 * CMDLINE_PARSE_BAD_ARGS on error. Else it calls the associated
 * function (defined in the context) and returns 0
 * (CMDLINE_PARSE_SUCCESS).
 */
    pub fn cmdline_parse(cl: *mut cmdline, buf: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * complete() must be called with *state==0 (try to complete) or
 * with *state==-1 (just display choices), then called without
 * modifying *state until it returns CMDLINE_PARSE_COMPLETED_BUFFER or
 * CMDLINE_PARSE_COMPLETED_BUFFER.
 *
 * It returns < 0 on error.
 *
 * Else it returns:
 *   - CMDLINE_PARSE_COMPLETED_BUFFER on completion (one possible
 *     choice). In this case, the chars are appended in dst buffer.
 *   - CMDLINE_PARSE_COMPLETE_AGAIN if there is several possible
 *     choices. In this case, you must call the function again,
 *     keeping the value of state intact.
 *   - CMDLINE_PARSE_COMPLETED_BUFFER when the iteration is
 *     finished. The dst is not valid for this last call.
 *
 * The returned dst buf ends with \0.
 */
    pub fn cmdline_complete(cl: *mut cmdline,
                            buf: *const ::std::os::raw::c_char,
                            state: *mut ::std::os::raw::c_int,
                            dst: *mut ::std::os::raw::c_char,
                            size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendoftoken(c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendofcommand(c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_etheraddr {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_etheraddr() {
    assert_eq!(::std::mem::size_of::<cmdline_token_etheraddr>() , 16usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_etheraddr>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_etheraddr ) ) . hdr as *
                const _ as usize } , 0usize);
}
impl Clone for cmdline_token_etheraddr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_etheraddr_t = cmdline_token_etheraddr;
extern "C" {
    #[link_name = "cmdline_token_etheraddr_ops"]
    pub static mut cmdline_token_etheraddr_ops:
               cmdline_token_hdr_cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_etheraddr(tk: *mut cmdline_parse_token_hdr_t,
                                   srcbuf: *const ::std::os::raw::c_char,
                                   res: *mut ::std::os::raw::c_void,
                                   ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_etheraddr(tk: *mut cmdline_parse_token_hdr_t,
                                      dstbuf: *mut ::std::os::raw::c_char,
                                      size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::std::mem::size_of::<in_addr>() , 4usize);
    assert_eq! (::std::mem::align_of::<in_addr>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_addr ) ) . s_addr as * const _ as
                usize } , 0usize);
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<in6_addr__bindgen_ty_1>() , 16usize);
    assert_eq! (::std::mem::align_of::<in6_addr__bindgen_ty_1>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr8
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr16
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr32
                as * const _ as usize } , 0usize);
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::std::mem::size_of::<in6_addr>() , 16usize);
    assert_eq! (::std::mem::align_of::<in6_addr>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr ) ) . __in6_u as * const _ as
                usize } , 0usize);
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_ipaddr {
    pub family: u8,
    pub addr: cmdline_ipaddr__bindgen_ty_1,
    pub prefixlen: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_ipaddr__bindgen_ty_1 {
    pub ipv4: __BindgenUnionField<in_addr>,
    pub ipv6: __BindgenUnionField<in6_addr>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cmdline_ipaddr__bindgen_ty_1>() ,
               16usize);
    assert_eq! (::std::mem::align_of::<cmdline_ipaddr__bindgen_ty_1>() ,
                4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr__bindgen_ty_1 ) ) . ipv4
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr__bindgen_ty_1 ) ) . ipv6
                as * const _ as usize } , 0usize);
}
impl Clone for cmdline_ipaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr() {
    assert_eq!(::std::mem::size_of::<cmdline_ipaddr>() , 24usize);
    assert_eq! (::std::mem::align_of::<cmdline_ipaddr>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr ) ) . family as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr ) ) . addr as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_ipaddr ) ) . prefixlen as * const
                _ as usize } , 20usize);
}
impl Clone for cmdline_ipaddr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_ipaddr_t = cmdline_ipaddr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_ipaddr_data {
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr_data() {
    assert_eq!(::std::mem::size_of::<cmdline_token_ipaddr_data>() , 1usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_ipaddr_data>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ipaddr_data ) ) . flags as
                * const _ as usize } , 0usize);
}
impl Clone for cmdline_token_ipaddr_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_ipaddr {
    pub hdr: cmdline_token_hdr,
    pub ipaddr_data: cmdline_token_ipaddr_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr() {
    assert_eq!(::std::mem::size_of::<cmdline_token_ipaddr>() , 24usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_ipaddr>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ipaddr ) ) . hdr as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_ipaddr ) ) . ipaddr_data as
                * const _ as usize } , 16usize);
}
impl Clone for cmdline_token_ipaddr {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_ipaddr_t = cmdline_token_ipaddr;
extern "C" {
    #[link_name = "cmdline_token_ipaddr_ops"]
    pub static mut cmdline_token_ipaddr_ops:
               cmdline_token_hdr_cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_ipaddr(tk: *mut cmdline_parse_token_hdr_t,
                                srcbuf: *const ::std::os::raw::c_char,
                                res: *mut ::std::os::raw::c_void,
                                ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_ipaddr(tk: *mut cmdline_parse_token_hdr_t,
                                   dstbuf: *mut ::std::os::raw::c_char,
                                   size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cmdline_numtype {
    UINT8 = 0,
    UINT16 = 1,
    UINT32 = 2,
    UINT64 = 3,
    INT8 = 4,
    INT16 = 5,
    INT32 = 6,
    INT64 = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_num_data {
    pub type_: cmdline_numtype,
}
#[test]
fn bindgen_test_layout_cmdline_token_num_data() {
    assert_eq!(::std::mem::size_of::<cmdline_token_num_data>() , 4usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_num_data>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_num_data ) ) . type_ as *
                const _ as usize } , 0usize);
}
impl Clone for cmdline_token_num_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_num {
    pub hdr: cmdline_token_hdr,
    pub num_data: cmdline_token_num_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_num() {
    assert_eq!(::std::mem::size_of::<cmdline_token_num>() , 24usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_num>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_num ) ) . hdr as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_num ) ) . num_data as *
                const _ as usize } , 16usize);
}
impl Clone for cmdline_token_num {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_num_t = cmdline_token_num;
extern "C" {
    #[link_name = "cmdline_token_num_ops"]
    pub static mut cmdline_token_num_ops: cmdline_token_hdr_cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_num(tk: *mut cmdline_parse_token_hdr_t,
                             srcbuf: *const ::std::os::raw::c_char,
                             res: *mut ::std::os::raw::c_void,
                             ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_num(tk: *mut cmdline_parse_token_hdr_t,
                                dstbuf: *mut ::std::os::raw::c_char,
                                size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_portlist {
    pub map: u32,
}
#[test]
fn bindgen_test_layout_cmdline_portlist() {
    assert_eq!(::std::mem::size_of::<cmdline_portlist>() , 4usize);
    assert_eq! (::std::mem::align_of::<cmdline_portlist>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_portlist ) ) . map as * const _
                as usize } , 0usize);
}
impl Clone for cmdline_portlist {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_portlist_t = cmdline_portlist;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_portlist {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_portlist() {
    assert_eq!(::std::mem::size_of::<cmdline_token_portlist>() , 16usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_portlist>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_portlist ) ) . hdr as *
                const _ as usize } , 0usize);
}
impl Clone for cmdline_token_portlist {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_portlist_t = cmdline_token_portlist;
extern "C" {
    #[link_name = "cmdline_token_portlist_ops"]
    pub static mut cmdline_token_portlist_ops:
               cmdline_token_hdr_cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_portlist(tk: *mut cmdline_parse_token_hdr_t,
                                  srcbuf: *const ::std::os::raw::c_char,
                                  res: *mut ::std::os::raw::c_void,
                                  ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_portlist(tk: *mut cmdline_parse_token_hdr_t,
                                     dstbuf: *mut ::std::os::raw::c_char,
                                     size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type cmdline_fixed_string_t = [::std::os::raw::c_char; 128usize];
pub type cmdline_multi_string_t = [::std::os::raw::c_char; 4096usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_string_data {
    pub str: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cmdline_token_string_data() {
    assert_eq!(::std::mem::size_of::<cmdline_token_string_data>() , 8usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_string_data>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_string_data ) ) . str as *
                const _ as usize } , 0usize);
}
impl Clone for cmdline_token_string_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_token_string {
    pub hdr: cmdline_token_hdr,
    pub string_data: cmdline_token_string_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_string() {
    assert_eq!(::std::mem::size_of::<cmdline_token_string>() , 24usize);
    assert_eq! (::std::mem::align_of::<cmdline_token_string>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_string ) ) . hdr as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_token_string ) ) . string_data as
                * const _ as usize } , 16usize);
}
impl Clone for cmdline_token_string {
    fn clone(&self) -> Self { *self }
}
pub type cmdline_parse_token_string_t = cmdline_token_string;
extern "C" {
    #[link_name = "cmdline_token_string_ops"]
    pub static mut cmdline_token_string_ops:
               cmdline_token_hdr_cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_string(tk: *mut cmdline_parse_token_hdr_t,
                                srcbuf: *const ::std::os::raw::c_char,
                                res: *mut ::std::os::raw::c_void,
                                ressize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_nb_string(tk: *mut cmdline_parse_token_hdr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_elt_string(tk: *mut cmdline_parse_token_hdr_t,
                                           idx: ::std::os::raw::c_int,
                                           dstbuf:
                                               *mut ::std::os::raw::c_char,
                                           size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_string(tk: *mut cmdline_parse_token_hdr_t,
                                   dstbuf: *mut ::std::os::raw::c_char,
                                   size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_uint;
pub type tcflag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(::std::mem::size_of::<termios>() , 60usize);
    assert_eq! (::std::mem::align_of::<termios>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_iflag as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_oflag as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_cflag as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_lflag as * const _ as
                usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_line as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_cc as * const _ as usize
                } , 17usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_ispeed as * const _ as
                usize } , 52usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const termios ) ) . c_ospeed as * const _ as
                usize } , 56usize);
}
impl Clone for termios {
    fn clone(&self) -> Self { *self }
}
/**
 * This structure is the header of a cirbuf type.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cirbuf {
    /**< total len of the fifo (number of elements) */
    pub maxlen: ::std::os::raw::c_uint,
    /**< indice of the first elt */
    pub start: ::std::os::raw::c_uint,
    /**< indice of the last elt */
    pub end: ::std::os::raw::c_uint,
    /**< current len of fifo */
    pub len: ::std::os::raw::c_uint,
    pub buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cirbuf() {
    assert_eq!(::std::mem::size_of::<cirbuf>() , 24usize);
    assert_eq! (::std::mem::align_of::<cirbuf>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . maxlen as * const _ as usize
                } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . start as * const _ as usize
                } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . end as * const _ as usize }
                , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . len as * const _ as usize }
                , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cirbuf ) ) . buf as * const _ as usize }
                , 16usize);
}
impl Clone for cirbuf {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "cmdline_vt100_commands"]
    pub static mut cmdline_vt100_commands:
               [*const ::std::os::raw::c_char; 0usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cmdline_vt100_parser_state {
    CMDLINE_VT100_INIT = 0,
    CMDLINE_VT100_ESCAPE = 1,
    CMDLINE_VT100_ESCAPE_CSI = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmdline_vt100 {
    pub bufpos: u8,
    pub buf: [::std::os::raw::c_char; 8usize],
    pub state: cmdline_vt100_parser_state,
}
#[test]
fn bindgen_test_layout_cmdline_vt100() {
    assert_eq!(::std::mem::size_of::<cmdline_vt100>() , 16usize);
    assert_eq! (::std::mem::align_of::<cmdline_vt100>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_vt100 ) ) . bufpos as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_vt100 ) ) . buf as * const _ as
                usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmdline_vt100 ) ) . state as * const _ as
                usize } , 12usize);
}
impl Clone for cmdline_vt100 {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rdline_status {
    RDLINE_INIT = 0,
    RDLINE_RUNNING = 1,
    RDLINE_EXITED = 2,
}
#[repr(C)]
pub struct rdline {
    pub status: rdline_status,
    pub left: cirbuf,
    pub right: cirbuf,
    pub left_buf: [::std::os::raw::c_char; 514usize],
    pub right_buf: [::std::os::raw::c_char; 512usize],
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub prompt_size: ::std::os::raw::c_uint,
    pub kill_buf: [::std::os::raw::c_char; 512usize],
    pub kill_size: ::std::os::raw::c_uint,
    pub history: cirbuf,
    pub history_buf: [::std::os::raw::c_char; 8192usize],
    pub history_cur_line: ::std::os::raw::c_int,
    pub write_char: rdline_write_char_t,
    pub validate: rdline_validate_t,
    pub complete: rdline_complete_t,
    pub vt100: cmdline_vt100,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rdline() {
    assert_eq!(::std::mem::size_of::<rdline>() , 9912usize);
    assert_eq! (::std::mem::align_of::<rdline>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . status as * const _ as usize
                } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . left as * const _ as usize }
                , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . right as * const _ as usize
                } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . left_buf as * const _ as
                usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . right_buf as * const _ as
                usize } , 570usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . prompt as * const _ as usize
                } , 1082usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . prompt_size as * const _ as
                usize } , 1116usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . kill_buf as * const _ as
                usize } , 1120usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . kill_size as * const _ as
                usize } , 1632usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . history as * const _ as
                usize } , 1640usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . history_buf as * const _ as
                usize } , 1664usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . history_cur_line as * const
                _ as usize } , 9856usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . write_char as * const _ as
                usize } , 9864usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . validate as * const _ as
                usize } , 9872usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . complete as * const _ as
                usize } , 9880usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . vt100 as * const _ as usize
                } , 9888usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rdline ) ) . opaque as * const _ as usize
                } , 9904usize);
}
pub type rdline_write_char_t =
    ::std::option::Option<unsafe extern "C" fn(rdl: *mut rdline,
                                               arg1: ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
pub type rdline_validate_t =
    ::std::option::Option<unsafe extern "C" fn(rdl: *mut rdline,
                                               buf:
                                                   *const ::std::os::raw::c_char,
                                               size: ::std::os::raw::c_uint)>;
pub type rdline_complete_t =
    ::std::option::Option<unsafe extern "C" fn(rdl: *mut rdline,
                                               buf:
                                                   *const ::std::os::raw::c_char,
                                               dstbuf:
                                                   *mut ::std::os::raw::c_char,
                                               dstsize:
                                                   ::std::os::raw::c_uint,
                                               state:
                                                   *mut ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn cmdline_new(ctx: *mut cmdline_parse_ctx_t,
                       prompt: *const ::std::os::raw::c_char,
                       s_in: ::std::os::raw::c_int,
                       s_out: ::std::os::raw::c_int) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_set_prompt(cl: *mut cmdline,
                              prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cmdline_free(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_printf(cl: *const cmdline,
                          fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cmdline_in(cl: *mut cmdline, buf: *const ::std::os::raw::c_char,
                      size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_write_char(rdl: *mut rdline, c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * This function is nonblocking equivalent of ``cmdline_interact()``. It polls
 * *cl* for one character and interpret it. If return value is *RDLINE_EXITED*
 * it mean that ``cmdline_quit()`` was invoked.
 *
 * @param cl
 *   The command line object.
 *
 * @return
 *   On success return object status - one of *enum rdline_status*.
 *   On error return negative value.
 */
    pub fn cmdline_poll(cl: *mut cmdline) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_interact(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_quit(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_file_new(ctx: *mut cmdline_parse_ctx_t,
                            prompt: *const ::std::os::raw::c_char,
                            path: *const ::std::os::raw::c_char)
     -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_new(ctx: *mut cmdline_parse_ctx_t,
                             prompt: *const ::std::os::raw::c_char)
     -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_exit(cl: *mut cmdline);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_distributor([u8; 0]);
extern "C" {
    /**
 * Function to create a new distributor instance
 *
 * Reserves the memory needed for the distributor operation and
 * initializes the distributor to work with the configured number of workers.
 *
 * @param name
 *   The name to be given to the distributor instance.
 * @param socket_id
 *   The NUMA node on which the memory is to be allocated
 * @param num_workers
 *   The maximum number of workers that will request packets from this
 *   distributor
 * @return
 *   The newly created distributor instance
 */
    pub fn rte_distributor_create(name: *const ::std::os::raw::c_char,
                                  socket_id: ::std::os::raw::c_uint,
                                  num_workers: ::std::os::raw::c_uint)
     -> *mut rte_distributor;
}
extern "C" {
    /**
 * Process a set of packets by distributing them among workers that request
 * packets. The distributor will ensure that no two packets that have the
 * same flow id, or tag, in the mbuf will be procesed at the same time.
 *
 * The user is advocated to set tag for each mbuf before calling this function.
 * If user doesn't set the tag, the tag value can be various values depending on
 * driver implementation and configuration.
 *
 * This is not multi-thread safe and should only be called on a single lcore.
 *
 * @param d
 *   The distributor instance to be used
 * @param mbufs
 *   The mbufs to be distributed
 * @param num_mbufs
 *   The number of mbufs in the mbufs array
 * @return
 *   The number of mbufs processed.
 */
    pub fn rte_distributor_process(d: *mut rte_distributor,
                                   mbufs: *mut *mut rte_mbuf,
                                   num_mbufs: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get a set of mbufs that have been returned to the distributor by workers
 *
 * This should only be called on the same lcore as rte_distributor_process()
 *
 * @param d
 *   The distributor instance to be used
 * @param mbufs
 *   The mbufs pointer array to be filled in
 * @param max_mbufs
 *   The size of the mbufs array
 * @return
 *   The number of mbufs returned in the mbufs array.
 */
    pub fn rte_distributor_returned_pkts(d: *mut rte_distributor,
                                         mbufs: *mut *mut rte_mbuf,
                                         max_mbufs: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Flush the distributor component, so that there are no in-flight or
 * backlogged packets awaiting processing
 *
 * This should only be called on the same lcore as rte_distributor_process()
 *
 * @param d
 *   The distributor instance to be used
 * @return
 *   The number of queued/in-flight packets that were completed by this call.
 */
    pub fn rte_distributor_flush(d: *mut rte_distributor)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Clears the array of returned packets used as the source for the
 * rte_distributor_returned_pkts() API call.
 *
 * This should only be called on the same lcore as rte_distributor_process()
 *
 * @param d
 *   The distributor instance to be used
 */
    pub fn rte_distributor_clear_returns(d: *mut rte_distributor);
}
extern "C" {
    /**
 * API called by a worker to get a new packet to process. Any previous packet
 * given to the worker is assumed to have completed processing, and may be
 * optionally returned to the distributor via the oldpkt parameter.
 *
 * @param d
 *   The distributor instance to be used
 * @param worker_id
 *   The worker instance number to use - must be less that num_workers passed
 *   at distributor creation time.
 * @param oldpkt
 *   The previous packet, if any, being processed by the worker
 *
 * @return
 *   A new packet to be processed by the worker thread.
 */
    pub fn rte_distributor_get_pkt(d: *mut rte_distributor,
                                   worker_id: ::std::os::raw::c_uint,
                                   oldpkt: *mut rte_mbuf) -> *mut rte_mbuf;
}
extern "C" {
    /**
 * API called by a worker to return a completed packet without requesting a
 * new packet, for example, because a worker thread is shutting down
 *
 * @param d
 *   The distributor instance to be used
 * @param worker_id
 *   The worker instance number to use - must be less that num_workers passed
 *   at distributor creation time.
 * @param mbuf
 *   The previous packet being processed by the worker
 */
    pub fn rte_distributor_return_pkt(d: *mut rte_distributor,
                                      worker_id: ::std::os::raw::c_uint,
                                      mbuf: *mut rte_mbuf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * API called by a worker to request a new packet to process.
 * Any previous packet given to the worker is assumed to have completed
 * processing, and may be optionally returned to the distributor via
 * the oldpkt parameter.
 * Unlike rte_distributor_get_pkt(), this function does not wait for a new
 * packet to be provided by the distributor.
 *
 * NOTE: after calling this function, rte_distributor_poll_pkt() should
 * be used to poll for the packet requested. The rte_distributor_get_pkt()
 * API should *not* be used to try and retrieve the new packet.
 *
 * @param d
 *   The distributor instance to be used
 * @param worker_id
 *   The worker instance number to use - must be less that num_workers passed
 *   at distributor creation time.
 * @param oldpkt
 *   The previous packet, if any, being processed by the worker
 */
    pub fn rte_distributor_request_pkt(d: *mut rte_distributor,
                                       worker_id: ::std::os::raw::c_uint,
                                       oldpkt: *mut rte_mbuf);
}
extern "C" {
    /**
 * API called by a worker to check for a new packet that was previously
 * requested by a call to rte_distributor_request_pkt(). It does not wait
 * for the new packet to be available, but returns NULL if the request has
 * not yet been fulfilled by the distributor.
 *
 * @param d
 *   The distributor instance to be used
 * @param worker_id
 *   The worker instance number to use - must be less that num_workers passed
 *   at distributor creation time.
 *
 * @return
 *   A new packet to be processed by the worker thread, or NULL if no
 *   packet is yet available.
 */
    pub fn rte_distributor_poll_pkt(d: *mut rte_distributor,
                                    worker_id: ::std::os::raw::c_uint)
     -> *mut rte_mbuf;
}
#[repr(u32)]
/**
 * Feature filter types
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_filter_type {
    RTE_ETH_FILTER_NONE = 0,
    RTE_ETH_FILTER_MACVLAN = 1,
    RTE_ETH_FILTER_ETHERTYPE = 2,
    RTE_ETH_FILTER_FLEXIBLE = 3,
    RTE_ETH_FILTER_SYN = 4,
    RTE_ETH_FILTER_NTUPLE = 5,
    RTE_ETH_FILTER_TUNNEL = 6,
    RTE_ETH_FILTER_FDIR = 7,
    RTE_ETH_FILTER_HASH = 8,
    RTE_ETH_FILTER_L2_TUNNEL = 9,
    RTE_ETH_FILTER_MAX = 10,
}
#[repr(u32)]
/**
 * Generic operations on filters
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_filter_op {
    RTE_ETH_FILTER_NOP = 0,
    RTE_ETH_FILTER_ADD = 1,
    RTE_ETH_FILTER_UPDATE = 2,
    RTE_ETH_FILTER_DELETE = 3,
    RTE_ETH_FILTER_FLUSH = 4,
    RTE_ETH_FILTER_GET = 5,
    RTE_ETH_FILTER_SET = 6,
    RTE_ETH_FILTER_INFO = 7,
    RTE_ETH_FILTER_STATS = 8,
    RTE_ETH_FILTER_OP_MAX = 9,
}
#[repr(u32)]
/**
 * MAC filter type
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_mac_filter_type {
    RTE_MAC_PERFECT_MATCH = 1,
    RTE_MACVLAN_PERFECT_MATCH = 2,
    RTE_MAC_HASH_MATCH = 3,
    RTE_MACVLAN_HASH_MATCH = 4,
}
/**
 * MAC filter info
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_mac_filter {
    /**< 1 for VF, 0 for port dev */
    pub is_vf: u8,
    /**< VF ID, available when is_vf is 1*/
    pub dst_id: u16,
    /**< MAC filter type */
    pub filter_type: rte_mac_filter_type,
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_mac_filter>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_mac_filter>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . is_vf as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . dst_id as *
                const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . filter_type as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_filter ) ) . mac_addr as *
                const _ as usize } , 8usize);
}
impl Clone for rte_eth_mac_filter {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the ethertype filter entry
 * to support RTE_ETH_FILTER_ETHERTYPE with RTE_ETH_FILTER_ADD,
 * RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ethertype_filter {
    /**< Mac address to match. */
    pub mac_addr: ether_addr,
    /**< Ether type to match */
    pub ether_type: u16,
    /**< Flags from RTE_ETHTYPE_FLAGS_* */
    pub flags: u16,
    /**< Queue assigned to when match*/
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ethertype_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_ethertype_filter>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_ethertype_filter>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . mac_addr
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . ether_type
                as * const _ as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . flags as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ethertype_filter ) ) . queue as *
                const _ as usize } , 10usize);
}
impl Clone for rte_eth_ethertype_filter {
    fn clone(&self) -> Self { *self }
}
/**
 *  A structure used to define the flex filter entry
 *  to support RTE_ETH_FILTER_FLEXIBLE with RTE_ETH_FILTER_ADD,
 *  RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
 */
#[repr(C)]
pub struct rte_eth_flex_filter {
    pub len: u16,
    /**< flex bytes in big endian.*/
    pub bytes: [u8; 128usize],
    /**< if mask bit is 1b, do
					not compare corresponding byte. */
    pub mask: [u8; 16usize],
    pub priority: u8,
    /**< Queue assigned to when match. */
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_flex_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_flex_filter>() , 150usize);
    assert_eq! (::std::mem::align_of::<rte_eth_flex_filter>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . len as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . bytes as *
                const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . mask as * const
                _ as usize } , 130usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . priority as *
                const _ as usize } , 146usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_filter ) ) . queue as *
                const _ as usize } , 148usize);
}
/**
 * A structure used to define the TCP syn filter entry
 * to support RTE_ETH_FILTER_SYN with RTE_ETH_FILTER_ADD,
 * RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_syn_filter {
    /**< 1 - higher priority than other filters,
				  0 - lower priority. */
    pub hig_pri: u8,
    /**< Queue assigned to when match */
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_syn_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_syn_filter>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_eth_syn_filter>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_syn_filter ) ) . hig_pri as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_syn_filter ) ) . queue as * const
                _ as usize } , 2usize);
}
impl Clone for rte_eth_syn_filter {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the ntuple filter entry
 * to support RTE_ETH_FILTER_NTUPLE with RTE_ETH_FILTER_ADD,
 * RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ntuple_filter {
    /**< Flags from RTE_NTUPLE_FLAGS_* */
    pub flags: u16,
    /**< Destination IP address in big endian. */
    pub dst_ip: u32,
    /**< Mask of destination IP address. */
    pub dst_ip_mask: u32,
    /**< Source IP address in big endian. */
    pub src_ip: u32,
    /**< Mask of destination IP address. */
    pub src_ip_mask: u32,
    /**< Destination port in big endian. */
    pub dst_port: u16,
    /**< Mask of destination port. */
    pub dst_port_mask: u16,
    /**< Source Port in big endian. */
    pub src_port: u16,
    /**< Mask of source port. */
    pub src_port_mask: u16,
    /**< L4 protocol. */
    pub proto: u8,
    /**< Mask of L4 protocol. */
    pub proto_mask: u8,
    /** tcp_flags only meaningful when the proto is TCP.
	    The packet matched above ntuple fields and contain
	    any set bit in tcp_flags will hit this filter. */
    pub tcp_flags: u8,
    /**< seven levels (001b-111b), 111b is highest,
				      used when more than one filter matches. */
    pub priority: u16,
    /**< Queue assigned to when match*/
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ntuple_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_ntuple_filter>() , 36usize);
    assert_eq! (::std::mem::align_of::<rte_eth_ntuple_filter>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . flags as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_ip as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_ip_mask
                as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_ip as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_ip_mask
                as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_port as *
                const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . dst_port_mask
                as * const _ as usize } , 22usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_port as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . src_port_mask
                as * const _ as usize } , 26usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . proto as *
                const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . proto_mask as
                * const _ as usize } , 29usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . tcp_flags as
                * const _ as usize } , 30usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . priority as *
                const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ntuple_filter ) ) . queue as *
                const _ as usize } , 34usize);
}
impl Clone for rte_eth_ntuple_filter {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Tunneled type.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_tunnel_type {
    RTE_TUNNEL_TYPE_NONE = 0,
    RTE_TUNNEL_TYPE_VXLAN = 1,
    RTE_TUNNEL_TYPE_GENEVE = 2,
    RTE_TUNNEL_TYPE_TEREDO = 3,
    RTE_TUNNEL_TYPE_NVGRE = 4,
    RTE_TUNNEL_TYPE_IP_IN_GRE = 5,
    RTE_L2_TUNNEL_TYPE_E_TAG = 6,
    RTE_TUNNEL_TYPE_MAX = 7,
}
#[repr(u32)]
/**
 *  Select IPv4 or IPv6 for tunnel filters.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_tunnel_iptype {
    RTE_TUNNEL_IPTYPE_IPV4 = 0,
    RTE_TUNNEL_IPTYPE_IPV6 = 1,
}
/**
 * Tunneling Packet filter configuration.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tunnel_filter_conf {
    /**< Outer MAC address to match. */
    pub outer_mac: ether_addr,
    /**< Inner MAC address to match. */
    pub inner_mac: ether_addr,
    /**< Inner VLAN to match. */
    pub inner_vlan: u16,
    /**< IP address type. */
    pub ip_type: rte_tunnel_iptype,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    /** Flags from ETH_TUNNEL_FILTER_XX - see above. */
    pub filter_type: u16,
    /**< Tunnel Type. */
    pub tunnel_type: rte_eth_tunnel_type,
    /**< Tenant ID to match. VNI, GRE key... */
    pub tenant_id: u32,
    /**< Queue assigned to if match. */
    pub queue_id: u16,
}
/** Outer destination IP address to match if ETH_TUNNEL_FILTER_OIP
	    is set in filter_type, or inner destination IP address to match
	    if ETH_TUNNEL_FILTER_IIP is set in filter_type . */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    /**< IPv4 address in big endian. */
    pub ipv4_addr: __BindgenUnionField<u32>,
    /**< IPv6 address in big endian. */
    pub ipv6_addr: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>()
               , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>()
                , 4usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_tunnel_filter_conf__bindgen_ty_1 ) )
                . ipv4_addr as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_tunnel_filter_conf__bindgen_ty_1 ) )
                . ipv6_addr as * const _ as usize } , 0usize);
}
impl Clone for rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_tunnel_filter_conf>() , 52usize);
    assert_eq! (::std::mem::align_of::<rte_eth_tunnel_filter_conf>() ,
                4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                outer_mac as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                inner_mac as * const _ as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                inner_vlan as * const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) . ip_type
                as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) . ip_addr
                as * const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                filter_type as * const _ as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                tunnel_type as * const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) .
                tenant_id as * const _ as usize } , 44usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_filter_conf ) ) . queue_id
                as * const _ as usize } , 48usize);
}
impl Clone for rte_eth_tunnel_filter_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Global eth device configuration type.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_global_cfg_type {
    RTE_ETH_GLOBAL_CFG_TYPE_UNKNOWN = 0,
    RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN = 1,
    RTE_ETH_GLOBAL_CFG_TYPE_MAX = 2,
}
/**
 * Global eth device configuration.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_global_cfg {
    /**< Global config type. */
    pub cfg_type: rte_eth_global_cfg_type,
    pub cfg: rte_eth_global_cfg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_global_cfg__bindgen_ty_1 {
    /**< Valid GRE key length in byte. */
    pub gre_key_len: __BindgenUnionField<u8>,
    /**< Reserve space for future use. */
    pub reserved: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_global_cfg__bindgen_ty_1>() ,
               8usize);
    assert_eq! (::std::mem::align_of::<rte_eth_global_cfg__bindgen_ty_1>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg__bindgen_ty_1 ) ) .
                gre_key_len as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize);
}
impl Clone for rte_eth_global_cfg__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg() {
    assert_eq!(::std::mem::size_of::<rte_eth_global_cfg>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_global_cfg>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg ) ) . cfg_type as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_global_cfg ) ) . cfg as * const _
                as usize } , 8usize);
}
impl Clone for rte_eth_global_cfg {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Input set fields for Flow Director and Hash filters
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_input_set_field {
    RTE_ETH_INPUT_SET_UNKNOWN = 0,
    RTE_ETH_INPUT_SET_L2_SRC_MAC = 1,
    RTE_ETH_INPUT_SET_L2_DST_MAC = 2,
    RTE_ETH_INPUT_SET_L2_OUTER_VLAN = 3,
    RTE_ETH_INPUT_SET_L2_INNER_VLAN = 4,
    RTE_ETH_INPUT_SET_L2_ETHERTYPE = 5,
    RTE_ETH_INPUT_SET_L3_SRC_IP4 = 129,
    RTE_ETH_INPUT_SET_L3_DST_IP4 = 130,
    RTE_ETH_INPUT_SET_L3_SRC_IP6 = 131,
    RTE_ETH_INPUT_SET_L3_DST_IP6 = 132,
    RTE_ETH_INPUT_SET_L3_IP4_TOS = 133,
    RTE_ETH_INPUT_SET_L3_IP4_PROTO = 134,
    RTE_ETH_INPUT_SET_L3_IP6_TC = 135,
    RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER = 136,
    RTE_ETH_INPUT_SET_L3_IP4_TTL = 137,
    RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS = 138,
    RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT = 257,
    RTE_ETH_INPUT_SET_L4_UDP_DST_PORT = 258,
    RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT = 259,
    RTE_ETH_INPUT_SET_L4_TCP_DST_PORT = 260,
    RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT = 261,
    RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT = 262,
    RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG = 263,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC = 385,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC = 386,
    RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN = 387,
    RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY = 388,
    RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY = 389,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD = 641,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD = 642,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD = 643,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD = 644,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD = 645,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD = 646,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD = 647,
    RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD = 648,
    RTE_ETH_INPUT_SET_DEFAULT = 65533,
    RTE_ETH_INPUT_SET_NONE = 65534,
    RTE_ETH_INPUT_SET_MAX = 65535,
}
#[repr(u32)]
/**
 * Filters input set operations
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_filter_input_set_op {
    RTE_ETH_INPUT_SET_OP_UNKNOWN = 0,
    RTE_ETH_INPUT_SET_SELECT = 1,
    RTE_ETH_INPUT_SET_ADD = 2,
    RTE_ETH_INPUT_SET_OP_MAX = 3,
}
/**
 * A structure used to define the input set configuration for
 * flow director and hash filters
 */
#[repr(C)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field; 128usize],
    pub op: rte_filter_input_set_op,
}
#[test]
fn bindgen_test_layout_rte_eth_input_set_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_input_set_conf>() , 520usize);
    assert_eq! (::std::mem::align_of::<rte_eth_input_set_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . flow_type as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . inset_size
                as * const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . field as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_input_set_conf ) ) . op as *
                const _ as usize } , 516usize);
}
/**
 * A structure used to define the input for L2 flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_l2_flow {
    /**< Ether type in big endian */
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_l2_flow>() , 2usize);
    assert_eq! (::std::mem::align_of::<rte_eth_l2_flow>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_flow ) ) . ether_type as *
                const _ as usize } , 0usize);
}
impl Clone for rte_eth_l2_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV4 flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ipv4_flow {
    /**< IPv4 source address in big endian. */
    pub src_ip: u32,
    /**< IPv4 destination address in big endian. */
    pub dst_ip: u32,
    /**< Type of service to match. */
    pub tos: u8,
    /**< Time to live to match. */
    pub ttl: u8,
    /**< Protocol, next header in big endian. */
    pub proto: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_ipv4_flow>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_ipv4_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . src_ip as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . dst_ip as * const
                _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . tos as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . ttl as * const _
                as usize } , 9usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv4_flow ) ) . proto as * const
                _ as usize } , 10usize);
}
impl Clone for rte_eth_ipv4_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV4 UDP flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_udpv4_flow {
    /**< IPv4 fields to match. */
    pub ip: rte_eth_ipv4_flow,
    /**< UDP source port in big endian. */
    pub src_port: u16,
    /**< UDP destination port in big endian. */
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_udpv4_flow>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_udpv4_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv4_flow ) ) . ip as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv4_flow ) ) . src_port as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv4_flow ) ) . dst_port as *
                const _ as usize } , 14usize);
}
impl Clone for rte_eth_udpv4_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV4 TCP flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tcpv4_flow {
    /**< IPv4 fields to match. */
    pub ip: rte_eth_ipv4_flow,
    /**< TCP source port in big endian. */
    pub src_port: u16,
    /**< TCP destination port in big endian. */
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_tcpv4_flow>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_tcpv4_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv4_flow ) ) . ip as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv4_flow ) ) . src_port as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv4_flow ) ) . dst_port as *
                const _ as usize } , 14usize);
}
impl Clone for rte_eth_tcpv4_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV4 SCTP flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_sctpv4_flow {
    /**< IPv4 fields to match. */
    pub ip: rte_eth_ipv4_flow,
    /**< SCTP source port in big endian. */
    pub src_port: u16,
    /**< SCTP destination port in big endian. */
    pub dst_port: u16,
    /**< Verify tag in big endian */
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv4_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_sctpv4_flow>() , 20usize);
    assert_eq! (::std::mem::align_of::<rte_eth_sctpv4_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . ip as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . src_port as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . dst_port as *
                const _ as usize } , 14usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv4_flow ) ) . verify_tag as *
                const _ as usize } , 16usize);
}
impl Clone for rte_eth_sctpv4_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV6 flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_ipv6_flow {
    /**< IPv6 source address in big endian. */
    pub src_ip: [u32; 4usize],
    /**< IPv6 destination address in big endian. */
    pub dst_ip: [u32; 4usize],
    /**< Traffic class to match. */
    pub tc: u8,
    /**< Protocol, next header to match. */
    pub proto: u8,
    /**< Hop limits to match. */
    pub hop_limits: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_ipv6_flow>() , 36usize);
    assert_eq! (::std::mem::align_of::<rte_eth_ipv6_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . src_ip as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . dst_ip as * const
                _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . tc as * const _
                as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . proto as * const
                _ as usize } , 33usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_ipv6_flow ) ) . hop_limits as *
                const _ as usize } , 34usize);
}
impl Clone for rte_eth_ipv6_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV6 UDP flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_udpv6_flow {
    /**< IPv6 fields to match. */
    pub ip: rte_eth_ipv6_flow,
    /**< UDP source port in big endian. */
    pub src_port: u16,
    /**< UDP destination port in big endian. */
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_udpv6_flow>() , 40usize);
    assert_eq! (::std::mem::align_of::<rte_eth_udpv6_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv6_flow ) ) . ip as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv6_flow ) ) . src_port as *
                const _ as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udpv6_flow ) ) . dst_port as *
                const _ as usize } , 38usize);
}
impl Clone for rte_eth_udpv6_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV6 TCP flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tcpv6_flow {
    /**< IPv6 fields to match. */
    pub ip: rte_eth_ipv6_flow,
    /**< TCP source port to in big endian. */
    pub src_port: u16,
    /**< TCP destination port in big endian. */
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_tcpv6_flow>() , 40usize);
    assert_eq! (::std::mem::align_of::<rte_eth_tcpv6_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv6_flow ) ) . ip as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv6_flow ) ) . src_port as *
                const _ as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tcpv6_flow ) ) . dst_port as *
                const _ as usize } , 38usize);
}
impl Clone for rte_eth_tcpv6_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for IPV6 SCTP flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_sctpv6_flow {
    /**< IPv6 fields to match. */
    pub ip: rte_eth_ipv6_flow,
    /**< SCTP source port in big endian. */
    pub src_port: u16,
    /**< SCTP destination port in big endian. */
    pub dst_port: u16,
    /**< Verify tag in big endian. */
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv6_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_sctpv6_flow>() , 44usize);
    assert_eq! (::std::mem::align_of::<rte_eth_sctpv6_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . ip as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . src_port as *
                const _ as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . dst_port as *
                const _ as usize } , 38usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_sctpv6_flow ) ) . verify_tag as *
                const _ as usize } , 40usize);
}
impl Clone for rte_eth_sctpv6_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for MAC VLAN flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_mac_vlan_flow {
    /**< Mac address to match. */
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_vlan_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_mac_vlan_flow>() , 6usize);
    assert_eq! (::std::mem::align_of::<rte_eth_mac_vlan_flow>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mac_vlan_flow ) ) . mac_addr as *
                const _ as usize } , 0usize);
}
impl Clone for rte_eth_mac_vlan_flow {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Tunnel type for flow director.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_tunnel_type {
    RTE_FDIR_TUNNEL_TYPE_UNKNOWN = 0,
    RTE_FDIR_TUNNEL_TYPE_NVGRE = 1,
    RTE_FDIR_TUNNEL_TYPE_VXLAN = 2,
}
/**
 * A structure used to define the input for tunnel flow, now it's VxLAN or
 * NVGRE
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_tunnel_flow {
    /**< Tunnel type to match. */
    pub tunnel_type: rte_eth_fdir_tunnel_type,
    /** Tunnel ID to match. TNI, VNI... in big endian. */
    pub tunnel_id: u32,
    /**< Mac address to match. */
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_tunnel_flow>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_tunnel_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_flow ) ) . tunnel_type as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_flow ) ) . tunnel_id as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_tunnel_flow ) ) . mac_addr as *
                const _ as usize } , 8usize);
}
impl Clone for rte_eth_tunnel_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * An union contains the inputs for all types of flow
 * Items in flows need to be in big endian
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flow {
    pub l2_flow: __BindgenUnionField<rte_eth_l2_flow>,
    pub udp4_flow: __BindgenUnionField<rte_eth_udpv4_flow>,
    pub tcp4_flow: __BindgenUnionField<rte_eth_tcpv4_flow>,
    pub sctp4_flow: __BindgenUnionField<rte_eth_sctpv4_flow>,
    pub ip4_flow: __BindgenUnionField<rte_eth_ipv4_flow>,
    pub udp6_flow: __BindgenUnionField<rte_eth_udpv6_flow>,
    pub tcp6_flow: __BindgenUnionField<rte_eth_tcpv6_flow>,
    pub sctp6_flow: __BindgenUnionField<rte_eth_sctpv6_flow>,
    pub ipv6_flow: __BindgenUnionField<rte_eth_ipv6_flow>,
    pub mac_vlan_flow: __BindgenUnionField<rte_eth_mac_vlan_flow>,
    pub tunnel_flow: __BindgenUnionField<rte_eth_tunnel_flow>,
    pub bindgen_union_field: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flow>() , 44usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flow>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . l2_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . udp4_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . tcp4_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . sctp4_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . ip4_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . udp6_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . tcp6_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . sctp6_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . ipv6_flow as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . mac_vlan_flow as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow ) ) . tunnel_flow as *
                const _ as usize } , 0usize);
}
impl Clone for rte_eth_fdir_flow {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to contain extend input of flow
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    /**< 1 for VF, 0 for port dev */
    pub is_vf: u8,
    /**< VF ID, available when is_vf is 1*/
    pub dst_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow_ext() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flow_ext>() , 22usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flow_ext>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . vlan_tci as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . flexbytes as
                * const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . is_vf as *
                const _ as usize } , 18usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flow_ext ) ) . dst_id as *
                const _ as usize } , 20usize);
}
impl Clone for rte_eth_fdir_flow_ext {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the input for a flow director filter entry
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_input() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_input>() , 72usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_input>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_input ) ) . flow_type as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_input ) ) . flow as * const
                _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_input ) ) . flow_ext as *
                const _ as usize } , 48usize);
}
impl Clone for rte_eth_fdir_input {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Behavior will be taken if FDIR match
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_behavior {
    RTE_ETH_FDIR_ACCEPT = 0,
    RTE_ETH_FDIR_REJECT = 1,
    RTE_ETH_FDIR_PASSTHRU = 2,
}
#[repr(u32)]
/**
 * Flow director report status
 * It defines what will be reported if FDIR entry is matched.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_status {
    RTE_ETH_FDIR_NO_REPORT_STATUS = 0,
    RTE_ETH_FDIR_REPORT_ID = 1,
    RTE_ETH_FDIR_REPORT_ID_FLEX_4 = 2,
    RTE_ETH_FDIR_REPORT_FLEX_8 = 3,
}
/**
 * A structure used to define an action when match FDIR packet filter.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_action {
    /**< Queue assigned to if FDIR match. */
    pub rx_queue: u16,
    /**< Behavior will be taken */
    pub behavior: rte_eth_fdir_behavior,
    /**< Status report option */
    pub report_status: rte_eth_fdir_status,
    pub flex_off: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_action() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_action>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_action>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . rx_queue as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . behavior as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . report_status
                as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_action ) ) . flex_off as *
                const _ as usize } , 12usize);
}
impl Clone for rte_eth_fdir_action {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the flow director filter entry by filter_ctrl API
 * It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_ADD and
 * RTE_ETH_FILTER_DELETE operations.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    /**< Input set */
    pub input: rte_eth_fdir_input,
    /**< Action taken when match */
    pub action: rte_eth_fdir_action,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_filter>() , 92usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_filter>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter ) ) . soft_id as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter ) ) . input as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter ) ) . action as *
                const _ as usize } , 76usize);
}
impl Clone for rte_eth_fdir_filter {
    fn clone(&self) -> Self { *self }
}
/**
 *  A structure used to configure FDIR masks that are used by the device
 *  to match the various fields of RX packet headers.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_masks {
    /**< Bit mask for vlan_tci in big endian */
    pub vlan_tci_mask: u16,
    /** Bit mask for ipv4 flow in big endian. */
    pub ipv4_mask: rte_eth_ipv4_flow,
    /** Bit maks for ipv6 flow in big endian. */
    pub ipv6_mask: rte_eth_ipv6_flow,
    /** Bit mask for L4 source port in big endian. */
    pub src_port_mask: u16,
    /** Bit mask for L4 destination port in big endian. */
    pub dst_port_mask: u16,
    /** 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the
	    first byte on the wire */
    pub mac_addr_byte_mask: u8,
    /** Bit mask for tunnel ID in big endian. */
    pub tunnel_id_mask: u32,
    /**< 1 - Match tunnel type,
				       0 - Ignore tunnel type. */
    pub tunnel_type_mask: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_masks() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_masks>() , 68usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_masks>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . vlan_tci_mask as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . ipv4_mask as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . ipv6_mask as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . src_port_mask as
                * const _ as usize } , 52usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . dst_port_mask as
                * const _ as usize } , 54usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) .
                mac_addr_byte_mask as * const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . tunnel_id_mask
                as * const _ as usize } , 60usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_masks ) ) . tunnel_type_mask
                as * const _ as usize } , 64usize);
}
impl Clone for rte_eth_fdir_masks {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Payload type
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_payload_type {
    RTE_ETH_PAYLOAD_UNKNOWN = 0,
    RTE_ETH_RAW_PAYLOAD = 1,
    RTE_ETH_L2_PAYLOAD = 2,
    RTE_ETH_L3_PAYLOAD = 3,
    RTE_ETH_L4_PAYLOAD = 4,
    RTE_ETH_PAYLOAD_MAX = 8,
}
/**
 * A structure used to select bytes extracted from the protocol layers to
 * flexible payload for filter
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_flex_payload_cfg {
    /**< Payload type */
    pub type_: rte_eth_payload_type,
    pub src_offset: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_flex_payload_cfg() {
    assert_eq!(::std::mem::size_of::<rte_eth_flex_payload_cfg>() , 36usize);
    assert_eq! (::std::mem::align_of::<rte_eth_flex_payload_cfg>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_payload_cfg ) ) . type_ as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_flex_payload_cfg ) ) . src_offset
                as * const _ as usize } , 4usize);
}
impl Clone for rte_eth_flex_payload_cfg {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define FDIR masks for flexible payload
 * for each flow type
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_mask() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flex_mask>() , 18usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flex_mask>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_mask ) ) . flow_type as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_mask ) ) . mask as *
                const _ as usize } , 2usize);
}
impl Clone for rte_eth_fdir_flex_mask {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define all flexible payload related setting
 * include flex payload and flex mask
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_flex_conf {
    /**< The number of following payload cfg */
    pub nb_payloads: u16,
    /**< The number of following mask */
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 22usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_flex_conf>() , 688usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_flex_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . nb_payloads
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . nb_flexmasks
                as * const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . flex_set as
                * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_flex_conf ) ) . flex_mask as
                * const _ as usize } , 292usize);
}
impl Clone for rte_eth_fdir_flex_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 *  Flow Director setting modes: none, signature or perfect.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_fdir_mode {
    RTE_FDIR_MODE_NONE = 0,
    RTE_FDIR_MODE_SIGNATURE = 1,
    RTE_FDIR_MODE_PERFECT = 2,
    RTE_FDIR_MODE_PERFECT_MAC_VLAN = 3,
    RTE_FDIR_MODE_PERFECT_TUNNEL = 4,
}
/**
 * A structure used to get the information of flow director filter.
 * It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation.
 * It includes the mode, flexible payload configuration information,
 * capabilities and supported flow types, flexible payload characters.
 * It can be gotten to help taking specific configurations per device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_info {
    /**< Flow director mode */
    pub mode: rte_fdir_mode,
    pub mask: rte_eth_fdir_masks,
    /** Flex payload configuration information */
    pub flex_conf: rte_eth_fdir_flex_conf,
    /**< Guaranteed spaces.*/
    pub guarant_spc: u32,
    /**< Best effort spaces.*/
    pub best_spc: u32,
    /** Bit mask for every supported flow type. */
    pub flow_types_mask: [u32; 1usize],
    /**< Total flex payload in bytes. */
    pub max_flexpayload: u32,
    /** Flexible payload unit in bytes. Size and alignments of all flex
	    payload segments should be multiplies of this value. */
    pub flex_payload_unit: u32,
    /** Max number of flexible payload continuous segments.
	    Each segment should be a multiple of flex_payload_unit.*/
    pub max_flex_payload_segment_num: u32,
    /** Maximum src_offset in bytes allowed. It indicates that
	    src_offset[i] in struct rte_eth_flex_payload_cfg should be less
	    than this value. */
    pub flex_payload_limit: u16,
    /** Flex bitmask unit in bytes. Size of flex bitmasks should be a
	    multiply of this value. */
    pub flex_bitmask_unit: u32,
    /** Max supported size of flex bitmasks in flex_bitmask_unit */
    pub max_flex_bitmask_num: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_info>() , 796usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_info>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . mode as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . mask as * const _
                as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flex_conf as *
                const _ as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . guarant_spc as *
                const _ as usize } , 760usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . best_spc as *
                const _ as usize } , 764usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flow_types_mask
                as * const _ as usize } , 768usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . max_flexpayload
                as * const _ as usize } , 772usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flex_payload_unit
                as * const _ as usize } , 776usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) .
                max_flex_payload_segment_num as * const _ as usize } ,
                780usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) .
                flex_payload_limit as * const _ as usize } , 784usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) . flex_bitmask_unit
                as * const _ as usize } , 788usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_info ) ) .
                max_flex_bitmask_num as * const _ as usize } , 792usize);
}
impl Clone for rte_eth_fdir_info {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to define the statistics of flow director.
 * It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fdir_stats {
    /**< Number of filters with collision. */
    pub collision: u32,
    /**< Number of free filters. */
    pub free: u32,
    pub maxhash: u32,
    /**< Longest linked list of filters. */
    pub maxlen: u32,
    /**< Number of added filters. */
    pub add: u64,
    /**< Number of removed filters. */
    pub remove: u64,
    /**< Number of failed added filters. */
    pub f_add: u64,
    /**< Number of failed removed filters. */
    pub f_remove: u64,
    /**< Number of filters in guaranteed spaces. */
    pub guarant_cnt: u32,
    /**< Number of filters in best effort spaces. */
    pub best_cnt: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_stats() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_stats>() , 56usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_stats>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . collision as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . free as * const
                _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . maxhash as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . maxlen as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . add as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . remove as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . f_add as * const
                _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . f_remove as *
                const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . guarant_cnt as *
                const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_stats ) ) . best_cnt as *
                const _ as usize } , 52usize);
}
impl Clone for rte_eth_fdir_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Flow Director filter information types.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fdir_filter_info_type {
    RTE_ETH_FDIR_FILTER_INFO_TYPE_UNKNOWN = 0,
    RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT = 1,
    RTE_ETH_FDIR_FILTER_INFO_TYPE_MAX = 2,
}
/**
 * A structure used to set FDIR filter information, to support filter type
 * of 'RTE_ETH_FILTER_FDIR' RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT operation.
 */
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_fdir_filter_info {
    /**< Information type */
    pub info_type: rte_eth_fdir_filter_info_type,
    pub info: rte_eth_fdir_filter_info__bindgen_ty_1,
}
/** Details of fdir filter information */
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_fdir_filter_info__bindgen_ty_1 {
    /** Flow Director input set configuration per port */
    pub input_set_conf: __BindgenUnionField<rte_eth_input_set_conf>,
    pub bindgen_union_field: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_filter_info__bindgen_ty_1>()
               , 520usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_filter_info__bindgen_ty_1>()
                , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter_info__bindgen_ty_1 )
                ) . input_set_conf as * const _ as usize } , 0usize);
}
impl Clone for rte_eth_fdir_filter_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_fdir_filter_info>() , 524usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fdir_filter_info>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter_info ) ) . info_type
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fdir_filter_info ) ) . info as *
                const _ as usize } , 4usize);
}
impl Clone for rte_eth_fdir_filter_info {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Hash filter information types.
 * - RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT is for getting/setting the
 *   information/configuration of 'symmetric hash enable' per port.
 * - RTE_ETH_HASH_FILTER_GLOBAL_CONFIG is for getting/setting the global
 *   configurations of hash filters. Those global configurations are valid
 *   for all ports of the same NIC.
 * - RTE_ETH_HASH_FILTER_INPUT_SET_SELECT is for setting the global
 *   hash input set fields
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_hash_filter_info_type {
    RTE_ETH_HASH_FILTER_INFO_TYPE_UNKNOWN = 0,
    RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT = 1,
    RTE_ETH_HASH_FILTER_GLOBAL_CONFIG = 2,
    RTE_ETH_HASH_FILTER_INPUT_SET_SELECT = 3,
    RTE_ETH_HASH_FILTER_INFO_TYPE_MAX = 4,
}
#[repr(u32)]
/**
 * Hash function types.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_hash_function {
    RTE_ETH_HASH_FUNCTION_DEFAULT = 0,
    RTE_ETH_HASH_FUNCTION_TOEPLITZ = 1,
    RTE_ETH_HASH_FUNCTION_SIMPLE_XOR = 2,
    RTE_ETH_HASH_FUNCTION_MAX = 3,
}
/**
 * A structure used to set or get global hash function configurations which
 * include symmetric hash enable per flow type and hash function type.
 * Each bit in sym_hash_enable_mask[] indicates if the symmetric hash of the
 * corresponding flow type is enabled or not.
 * Each bit in valid_bit_mask[] indicates if the corresponding bit in
 * sym_hash_enable_mask[] is valid or not. For the configurations gotten, it
 * also means if the flow type is supported by hardware or not.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_hash_global_conf {
    /**< Hash function type */
    pub hash_func: rte_eth_hash_function,
    /** Bit mask for symmetric hash enable per flow type */
    pub sym_hash_enable_mask: [u32; 1usize],
    /** Bit mask indicates if the corresponding bit is valid */
    pub valid_bit_mask: [u32; 1usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_global_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_hash_global_conf>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_hash_global_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_global_conf ) ) . hash_func
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_global_conf ) ) .
                sym_hash_enable_mask as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_global_conf ) ) .
                valid_bit_mask as * const _ as usize } , 8usize);
}
impl Clone for rte_eth_hash_global_conf {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to set or get hash filter information, to support filter
 * type of 'RTE_ETH_FILTER_HASH' and its operations.
 */
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_hash_filter_info {
    /**< Information type */
    pub info_type: rte_eth_hash_filter_info_type,
    pub info: rte_eth_hash_filter_info__bindgen_ty_1,
}
/** Details of hash filter information */
#[repr(C)]
#[derive(Copy)]
pub struct rte_eth_hash_filter_info__bindgen_ty_1 {
    /** For RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT */
    pub enable: __BindgenUnionField<u8>,
    /** Global configurations of hash filter */
    pub global_conf: __BindgenUnionField<rte_eth_hash_global_conf>,
    /** Global configurations of hash filter input set */
    pub input_set_conf: __BindgenUnionField<rte_eth_input_set_conf>,
    pub bindgen_union_field: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_hash_filter_info__bindgen_ty_1>()
               , 520usize);
    assert_eq! (::std::mem::align_of::<rte_eth_hash_filter_info__bindgen_ty_1>()
                , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info__bindgen_ty_1 )
                ) . enable as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info__bindgen_ty_1 )
                ) . global_conf as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info__bindgen_ty_1 )
                ) . input_set_conf as * const _ as usize } , 0usize);
}
impl Clone for rte_eth_hash_filter_info__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_hash_filter_info>() , 524usize);
    assert_eq! (::std::mem::align_of::<rte_eth_hash_filter_info>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info ) ) . info_type
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_hash_filter_info ) ) . info as *
                const _ as usize } , 4usize);
}
impl Clone for rte_eth_hash_filter_info {
    fn clone(&self) -> Self { *self }
}
/**
 * l2 tunnel configuration.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_l2_tunnel_conf {
    pub l2_tunnel_type: rte_eth_tunnel_type,
    pub ether_type: u16,
    pub tunnel_id: u32,
    pub vf_id: u16,
    pub pool: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_tunnel_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_l2_tunnel_conf>() , 20usize);
    assert_eq! (::std::mem::align_of::<rte_eth_l2_tunnel_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) .
                l2_tunnel_type as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . ether_type
                as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . tunnel_id as
                * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . vf_id as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_l2_tunnel_conf ) ) . pool as *
                const _ as usize } , 16usize);
}
impl Clone for rte_eth_l2_tunnel_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_dev_reg_info {
    /**< Buffer for return registers */
    pub data: *mut ::std::os::raw::c_void,
    /**< Start register table location for access */
    pub offset: u32,
    /**< Number of registers to fetch */
    pub length: u32,
    /**< Size of device register */
    pub width: u32,
    /**< Device version */
    pub version: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_reg_info() {
    assert_eq!(::std::mem::size_of::<rte_dev_reg_info>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_dev_reg_info>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . data as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . offset as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . length as * const
                _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . width as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_reg_info ) ) . version as * const
                _ as usize } , 20usize);
}
impl Clone for rte_dev_reg_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_dev_eeprom_info {
    /**< Buffer for return eeprom */
    pub data: *mut ::std::os::raw::c_void,
    /**< Start eeprom address for access*/
    pub offset: u32,
    /**< Length of eeprom region to access */
    pub length: u32,
    /**< Device-specific key, such as device-id */
    pub magic: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_eeprom_info() {
    assert_eq!(::std::mem::size_of::<rte_dev_eeprom_info>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_dev_eeprom_info>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . data as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . offset as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . length as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_dev_eeprom_info ) ) . magic as *
                const _ as usize } , 16usize);
}
impl Clone for rte_dev_eeprom_info {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to retrieve statistics for an Ethernet port.
 * Not all statistics fields in struct rte_eth_stats are supported
 * by any type of network interface card (NIC). If any statistics
 * field is not supported, its value is 0.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_stats {
    /**< Total number of successfully received packets. */
    pub ipackets: u64,
    /**< Total number of successfully transmitted packets.*/
    pub opackets: u64,
    /**< Total number of successfully received bytes. */
    pub ibytes: u64,
    /**< Total number of successfully transmitted bytes. */
    pub obytes: u64,
    pub imissed: u64,
    /**< Total number of erroneous received packets. */
    pub ierrors: u64,
    /**< Total number of failed transmitted packets. */
    pub oerrors: u64,
    /**< Total number of RX mbuf allocation failures. */
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    assert_eq!(::std::mem::size_of::<rte_eth_stats>() , 704usize);
    assert_eq! (::std::mem::align_of::<rte_eth_stats>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . ipackets as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . opackets as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . ibytes as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . obytes as * const _
                as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . imissed as * const _
                as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . ierrors as * const _
                as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . oerrors as * const _
                as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . rx_nombuf as * const
                _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_ipackets as * const
                _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_opackets as * const
                _ as usize } , 192usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_ibytes as * const _
                as usize } , 320usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_obytes as * const _
                as usize } , 448usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_stats ) ) . q_errors as * const _
                as usize } , 576usize);
}
impl Clone for rte_eth_stats {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to retrieve link-level information of an Ethernet port.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_link {
    /**< ETH_SPEED_NUM_ */
    pub link_speed: u32,
    pub _bitfield_1: u8,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(::std::mem::size_of::<rte_eth_link>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_eth_link>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_link ) ) . link_speed as * const
                _ as usize } , 0usize);
}
impl Clone for rte_eth_link {
    fn clone(&self) -> Self { *self }
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u16)
        }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u16 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u16)
        }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u16 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u16)
        }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u16 as u8) << 2u32) & (4usize as u8);
    }
}
/**
 * A structure used to configure the ring threshold registers of an RX/TX
 * queue for an Ethernet port.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_thresh {
    /**< Ring prefetch threshold. */
    pub pthresh: u8,
    /**< Ring host threshold. */
    pub hthresh: u8,
    /**< Ring writeback threshold. */
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    assert_eq!(::std::mem::size_of::<rte_eth_thresh>() , 3usize);
    assert_eq! (::std::mem::align_of::<rte_eth_thresh>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_thresh ) ) . pthresh as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_thresh ) ) . hthresh as * const _
                as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_thresh ) ) . wthresh as * const _
                as usize } , 2usize);
}
impl Clone for rte_eth_thresh {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 *  A set of values to identify what method is to be used to route
 *  packets to multiple queues.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_rx_mq_mode {
    ETH_MQ_RX_NONE = 0,
    ETH_MQ_RX_RSS = 1,
    ETH_MQ_RX_DCB = 2,
    ETH_MQ_RX_DCB_RSS = 3,
    ETH_MQ_RX_VMDQ_ONLY = 4,
    ETH_MQ_RX_VMDQ_RSS = 5,
    ETH_MQ_RX_VMDQ_DCB = 6,
    ETH_MQ_RX_VMDQ_DCB_RSS = 7,
}
#[repr(u32)]
/**
 * A set of values to identify what method is to be used to transmit
 * packets using multi-TCs.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_tx_mq_mode {
    ETH_MQ_TX_NONE = 0,
    ETH_MQ_TX_DCB = 1,
    ETH_MQ_TX_VMDQ_DCB = 2,
    ETH_MQ_TX_VMDQ_ONLY = 3,
}
/**
 * A structure used to configure the RX features of an Ethernet port.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxmode {
    /** The multi-queue packet distribution mode to be used, e.g. RSS. */
    pub mq_mode: rte_eth_rx_mq_mode,
    /**< Only used if jumbo_frame enabled. */
    pub max_rx_pkt_len: u32,
    /**< hdr buf size (header_split enabled).*/
    pub split_hdr_size: u16,
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxmode>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_rxmode>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxmode ) ) . mq_mode as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxmode ) ) . max_rx_pkt_len as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxmode ) ) . split_hdr_size as *
                const _ as usize } , 8usize);
}
impl Clone for rte_eth_rxmode {
    fn clone(&self) -> Self { *self }
}
impl rte_eth_rxmode {
    #[inline]
    pub fn header_split(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u16)
        }
    }
    #[inline]
    pub fn set_header_split(&mut self, val: u16) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn hw_ip_checksum(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u16)
        }
    }
    #[inline]
    pub fn set_hw_ip_checksum(&mut self, val: u16) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn hw_vlan_filter(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                       2u32) as u16)
        }
    }
    #[inline]
    pub fn set_hw_vlan_filter(&mut self, val: u16) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn hw_vlan_strip(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                       3u32) as u16)
        }
    }
    #[inline]
    pub fn set_hw_vlan_strip(&mut self, val: u16) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn hw_vlan_extend(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u16)
        }
    }
    #[inline]
    pub fn set_hw_vlan_extend(&mut self, val: u16) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn jumbo_frame(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u16)
        }
    }
    #[inline]
    pub fn set_jumbo_frame(&mut self, val: u16) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn hw_strip_crc(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u16)
        }
    }
    #[inline]
    pub fn set_hw_strip_crc(&mut self, val: u16) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn enable_scatter(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u16)
        }
    }
    #[inline]
    pub fn set_enable_scatter(&mut self, val: u16) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn enable_lro(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u16)
        }
    }
    #[inline]
    pub fn set_enable_lro(&mut self, val: u16) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
}
#[repr(u32)]
/**
 * VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN.
 * Note that single VLAN is treated the same as inner VLAN.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_vlan_type {
    ETH_VLAN_TYPE_UNKNOWN = 0,
    ETH_VLAN_TYPE_INNER = 1,
    ETH_VLAN_TYPE_OUTER = 2,
    ETH_VLAN_TYPE_MAX = 3,
}
/**
 * A structure used to configure the Receive Side Scaling (RSS) feature
 * of an Ethernet port.
 * If not NULL, the *rss_key* pointer of the *rss_conf* structure points
 * to an array holding the RSS key to use for hashing specific header
 * fields of received packets. The length of this array should be indicated
 * by *rss_key_len* below. Otherwise, a default random hash key is used by
 * the device driver.
 *
 * The *rss_key_len* field of the *rss_conf* structure indicates the length
 * in bytes of the array pointed by *rss_key*. To be compatible, this length
 * will be checked in i40e only. Others assume 40 bytes to be used as before.
 *
 * The *rss_hf* field of the *rss_conf* structure indicates the different
 * types of IPv4/IPv6 packets to which the RSS hashing must be applied.
 * Supplying an *rss_hf* equal to zero disables the RSS feature.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rss_conf {
    /**< If not NULL, 40-byte hash key. */
    pub rss_key: *mut u8,
    /**< hash key length in bytes. */
    pub rss_key_len: u8,
    /**< Hash functions to apply - see below. */
    pub rss_hf: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_rss_conf>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_eth_rss_conf>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_conf ) ) . rss_key as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_conf ) ) . rss_key_len as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_conf ) ) . rss_hf as * const
                _ as usize } , 16usize);
}
impl Clone for rte_eth_rss_conf {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to configure VLAN traffic mirror of an Ethernet port.
 */
#[repr(C)]
pub struct rte_eth_vlan_mirror {
    /**< mask for valid VLAN ID. */
    pub vlan_mask: u64,
    /** VLAN ID list for vlan mirroring. */
    pub vlan_id: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vlan_mirror() {
    assert_eq!(::std::mem::size_of::<rte_eth_vlan_mirror>() , 136usize);
    assert_eq! (::std::mem::align_of::<rte_eth_vlan_mirror>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vlan_mirror ) ) . vlan_mask as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vlan_mirror ) ) . vlan_id as *
                const _ as usize } , 8usize);
}
/**
 * A structure used to configure traffic mirror of an Ethernet port.
 */
#[repr(C)]
pub struct rte_eth_mirror_conf {
    /**< Mirroring rule type */
    pub rule_type: u8,
    /**< Destination pool for this mirror rule. */
    pub dst_pool: u8,
    /**< Bitmap of pool for pool mirroring */
    pub pool_mask: u64,
    /** VLAN ID setting for VLAN mirroring. */
    pub vlan: rte_eth_vlan_mirror,
}
#[test]
fn bindgen_test_layout_rte_eth_mirror_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_mirror_conf>() , 152usize);
    assert_eq! (::std::mem::align_of::<rte_eth_mirror_conf>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . rule_type as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . dst_pool as *
                const _ as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . pool_mask as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_mirror_conf ) ) . vlan as * const
                _ as usize } , 16usize);
}
/**
 * A structure used to configure 64 entries of Redirection Table of the
 * Receive Side Scaling (RSS) feature of an Ethernet port. To configure
 * more than 64 entries supported by hardware, an array of this structure
 * is needed.
 */
#[repr(C)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rss_reta_entry64() {
    assert_eq!(::std::mem::size_of::<rte_eth_rss_reta_entry64>() , 136usize);
    assert_eq! (::std::mem::align_of::<rte_eth_rss_reta_entry64>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_reta_entry64 ) ) . mask as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rss_reta_entry64 ) ) . reta as *
                const _ as usize } , 8usize);
}
#[repr(u32)]
/**
 * This enum indicates the possible number of traffic classes
 * in DCB configratioins
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_nb_tcs { ETH_4_TCS = 4, ETH_8_TCS = 8, }
#[repr(u32)]
/**
 * This enum indicates the possible number of queue pools
 * in VMDQ configurations.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_nb_pools {
    ETH_8_POOLS = 8,
    ETH_16_POOLS = 16,
    ETH_32_POOLS = 32,
    ETH_64_POOLS = 64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_rx_conf {
    /**< Possible DCB TCs, 4 or 8 TCs */
    pub nb_tcs: rte_eth_nb_tcs,
    /** Traffic class each UP mapped to. */
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_rx_conf>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_rx_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_rx_conf ) ) . nb_tcs as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_rx_conf ) ) . dcb_tc as *
                const _ as usize } , 4usize);
}
impl Clone for rte_eth_dcb_rx_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    /**< With DCB, 16 or 32 pools. */
    pub nb_queue_pools: rte_eth_nb_pools,
    /** Traffic class each UP mapped to. */
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_tx_conf ) ) .
                nb_queue_pools as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_tx_conf ) ) . dcb_tc as
                * const _ as usize } , 4usize);
}
impl Clone for rte_eth_vmdq_dcb_tx_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_tx_conf {
    /**< Possible DCB TCs, 4 or 8 TCs. */
    pub nb_tcs: rte_eth_nb_tcs,
    /** Traffic class each UP mapped to. */
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tx_conf>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tx_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tx_conf ) ) . nb_tcs as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tx_conf ) ) . dcb_tc as *
                const _ as usize } , 4usize);
}
impl Clone for rte_eth_dcb_tx_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_tx_conf {
    /**< VMDq mode, 64 pools. */
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_tx_conf>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_tx_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_tx_conf ) ) . nb_queue_pools
                as * const _ as usize } , 0usize);
}
impl Clone for rte_eth_vmdq_tx_conf {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to configure the VMDQ+DCB feature
 * of an Ethernet port.
 *
 * Using this feature, packets are routed to a pool of queues, based
 * on the vlan id in the vlan tag, and then to a specific queue within
 * that pool, using the user priority vlan tag field.
 *
 * A default pool may be used, if desired, to route all traffic which
 * does not match the vlan filter rules.
 */
#[repr(C)]
pub struct rte_eth_vmdq_dcb_conf {
    /**< With DCB, 16 or 32 pools */
    pub nb_queue_pools: rte_eth_nb_pools,
    /**< If non-zero, use a default pool */
    pub enable_default_pool: u8,
    /**< The default pool, if applicable */
    pub default_pool: u8,
    /**< We can have up to 64 filters/mappings */
    pub nb_pool_maps: u8,
    /**< VMDq vlan pool maps. */
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    /**< The vlan id of the received frame */
    pub vlan_id: u16,
    /**< Bitmask of pools for packet rx */
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>() ,
               16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf__bindgen_ty_1 ) ) .
                vlan_id as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf__bindgen_ty_1 ) ) .
                pools as * const _ as usize } , 8usize);
}
impl Clone for rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_dcb_conf>() , 1040usize);
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_dcb_conf>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) .
                nb_queue_pools as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) .
                enable_default_pool as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . default_pool
                as * const _ as usize } , 5usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . nb_pool_maps
                as * const _ as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . pool_map as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_dcb_conf ) ) . dcb_tc as *
                const _ as usize } , 1032usize);
}
#[repr(C)]
pub struct rte_eth_vmdq_rx_conf {
    /**< VMDq only mode, 8 or 64 pools */
    pub nb_queue_pools: rte_eth_nb_pools,
    /**< If non-zero, use a default pool */
    pub enable_default_pool: u8,
    /**< The default pool, if applicable */
    pub default_pool: u8,
    /**< Enable VT loop back */
    pub enable_loop_back: u8,
    /**< We can have up to 64 filters/mappings */
    pub nb_pool_maps: u8,
    /**< Flags from ETH_VMDQ_ACCEPT_* */
    pub rx_mode: u32,
    /**< VMDq vlan pool maps. */
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    /**< The vlan id of the received frame */
    pub vlan_id: u16,
    /**< Bitmask of pools for packet rx */
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() ,
               16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf__bindgen_ty_1 ) ) .
                vlan_id as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf__bindgen_ty_1 ) ) .
                pools as * const _ as usize } , 8usize);
}
impl Clone for rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_vmdq_rx_conf>() , 1040usize);
    assert_eq! (::std::mem::align_of::<rte_eth_vmdq_rx_conf>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . nb_queue_pools
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) .
                enable_default_pool as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . default_pool
                as * const _ as usize } , 5usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) .
                enable_loop_back as * const _ as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . nb_pool_maps
                as * const _ as usize } , 7usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . rx_mode as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_vmdq_rx_conf ) ) . pool_map as *
                const _ as usize } , 16usize);
}
/**
 * A structure used to configure the TX features of an Ethernet port.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_txmode {
    /**< TX multi-queues mode. */
    pub mq_mode: rte_eth_tx_mq_mode,
    pub pvid: u16,
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    assert_eq!(::std::mem::size_of::<rte_eth_txmode>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_eth_txmode>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txmode ) ) . mq_mode as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txmode ) ) . pvid as * const _ as
                usize } , 4usize);
}
impl Clone for rte_eth_txmode {
    fn clone(&self) -> Self { *self }
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u8)
        }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
}
/**
 * A structure used to configure an RX ring of an Ethernet port.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxconf {
    /**< RX ring threshold registers. */
    pub rx_thresh: rte_eth_thresh,
    /**< Drives the freeing of RX descriptors. */
    pub rx_free_thresh: u16,
    /**< Drop packets if no descriptors are available. */
    pub rx_drop_en: u8,
    /**< Do not start queue with rte_eth_dev_start(). */
    pub rx_deferred_start: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxconf>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_eth_rxconf>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_thresh as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_free_thresh as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_drop_en as *
                const _ as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxconf ) ) . rx_deferred_start as
                * const _ as usize } , 7usize);
}
impl Clone for rte_eth_rxconf {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to configure a TX ring of an Ethernet port.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_txconf {
    /**< TX ring threshold registers. */
    pub tx_thresh: rte_eth_thresh,
    /**< Drives the setting of RS bit on TXDs. */
    pub tx_rs_thresh: u16,
    /**< Start freeing TX buffers if there are
				      less free descriptors than this value. */
    pub tx_free_thresh: u16,
    /**< Set flags for the Tx queue */
    pub txq_flags: u32,
    /**< Do not start queue with rte_eth_dev_start(). */
    pub tx_deferred_start: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    assert_eq!(::std::mem::size_of::<rte_eth_txconf>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_txconf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_thresh as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_rs_thresh as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_free_thresh as *
                const _ as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . txq_flags as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txconf ) ) . tx_deferred_start as
                * const _ as usize } , 12usize);
}
impl Clone for rte_eth_txconf {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure contains information about HW descriptor ring limitations.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_desc_lim {
    /**< Max allowed number of descriptors. */
    pub nb_max: u16,
    /**< Min allowed number of descriptors. */
    pub nb_min: u16,
    /**< Number of descriptors should be aligned to. */
    pub nb_align: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    assert_eq!(::std::mem::size_of::<rte_eth_desc_lim>() , 6usize);
    assert_eq! (::std::mem::align_of::<rte_eth_desc_lim>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_max as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_min as * const
                _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_desc_lim ) ) . nb_align as *
                const _ as usize } , 4usize);
}
impl Clone for rte_eth_desc_lim {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * This enum indicates the flow control mode
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_fc_mode {
    RTE_FC_NONE = 0,
    RTE_FC_RX_PAUSE = 1,
    RTE_FC_TX_PAUSE = 2,
    RTE_FC_FULL = 3,
}
/**
 * A structure used to configure Ethernet flow control parameter.
 * These parameters will be configured into the register of the NIC.
 * Please refer to the corresponding data sheet for proper value.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_fc_conf {
    /**< High threshold value to trigger XOFF */
    pub high_water: u32,
    /**< Low threshold value to trigger XON */
    pub low_water: u32,
    /**< Pause quota in the Pause frame */
    pub pause_time: u16,
    /**< Is XON frame need be sent */
    pub send_xon: u16,
    /**< Link flow control mode */
    pub mode: rte_eth_fc_mode,
    /**< Forward MAC control frames */
    pub mac_ctrl_frame_fwd: u8,
    /**< Use Pause autoneg */
    pub autoneg: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fc_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_fc_conf>() , 20usize);
    assert_eq! (::std::mem::align_of::<rte_eth_fc_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . high_water as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . low_water as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . pause_time as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . send_xon as * const
                _ as usize } , 10usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . mode as * const _
                as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . mac_ctrl_frame_fwd
                as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_fc_conf ) ) . autoneg as * const
                _ as usize } , 17usize);
}
impl Clone for rte_eth_fc_conf {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to configure Ethernet priority flow control parameter.
 * These parameters will be configured into the register of the NIC.
 * Please refer to the corresponding data sheet for proper value.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_pfc_conf {
    /**< General flow control parameter. */
    pub fc: rte_eth_fc_conf,
    /**< VLAN User Priority. */
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_pfc_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_pfc_conf>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_eth_pfc_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_pfc_conf ) ) . fc as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_pfc_conf ) ) . priority as *
                const _ as usize } , 20usize);
}
impl Clone for rte_eth_pfc_conf {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 *  Memory space that can be configured to store Flow Director filters
 *  in the board memory.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_fdir_pballoc_type {
    RTE_FDIR_PBALLOC_64K = 0,
    RTE_FDIR_PBALLOC_128K = 1,
    RTE_FDIR_PBALLOC_256K = 2,
}
#[repr(u32)]
/**
 *  Select report mode of FDIR hash information in RX descriptors.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_fdir_status_mode {
    RTE_FDIR_NO_REPORT_STATUS = 0,
    RTE_FDIR_REPORT_STATUS = 1,
    RTE_FDIR_REPORT_STATUS_ALWAYS = 2,
}
/**
 * A structure used to configure the Flow Director (FDIR) feature
 * of an Ethernet port.
 *
 * If mode is RTE_FDIR_DISABLE, the pballoc value is ignored.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_fdir_conf {
    /**< Flow Director mode. */
    pub mode: rte_fdir_mode,
    /**< Space for FDIR filters. */
    pub pballoc: rte_fdir_pballoc_type,
    /**< How to report FDIR hash. */
    pub status: rte_fdir_status_mode,
    /** RX queue of packets matching a "drop" filter in perfect mode. */
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[test]
fn bindgen_test_layout_rte_fdir_conf() {
    assert_eq!(::std::mem::size_of::<rte_fdir_conf>() , 772usize);
    assert_eq! (::std::mem::align_of::<rte_fdir_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . mode as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . pballoc as * const _
                as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . status as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . drop_queue as * const
                _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . mask as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_fdir_conf ) ) . flex_conf as * const
                _ as usize } , 84usize);
}
impl Clone for rte_fdir_conf {
    fn clone(&self) -> Self { *self }
}
/**
 * UDP tunneling configuration.
 * Used to config the UDP port for a type of tunnel.
 * NICs need the UDP port to identify the tunnel type.
 * Normally a type of tunnel has a default UDP port, this structure can be used
 * in case if the users want to change or support more UDP port.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_udp_tunnel {
    /**< UDP port used for the tunnel. */
    pub udp_port: u16,
    /**< Tunnel type. Defined in rte_eth_tunnel_type. */
    pub prot_type: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_udp_tunnel() {
    assert_eq!(::std::mem::size_of::<rte_eth_udp_tunnel>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_eth_udp_tunnel>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udp_tunnel ) ) . udp_port as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_udp_tunnel ) ) . prot_type as *
                const _ as usize } , 2usize);
}
impl Clone for rte_eth_udp_tunnel {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to enable/disable specific device interrupts.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_intr_conf {
    /** enable/disable lsc interrupt. 0 (default) - disable, 1 enable */
    pub lsc: u16,
    /** enable/disable rxq interrupt. 0 (default) - disable, 1 enable */
    pub rxq: u16,
}
#[test]
fn bindgen_test_layout_rte_intr_conf() {
    assert_eq!(::std::mem::size_of::<rte_intr_conf>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_intr_conf>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_conf ) ) . lsc as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_intr_conf ) ) . rxq as * const _ as
                usize } , 2usize);
}
impl Clone for rte_intr_conf {
    fn clone(&self) -> Self { *self }
}
/**
 * A structure used to configure an Ethernet port.
 * Depending upon the RX multi-queue mode, extra advanced
 * configuration settings may be needed.
 */
#[repr(C)]
pub struct rte_eth_conf {
    /**< bitmap of ETH_LINK_SPEED_XXX of speeds to be
				used. ETH_LINK_SPEED_FIXED disables link
				autonegotiation, and a unique speed shall be
				set. Otherwise, the bitmap defines the set of
				speeds to be advertised. If the special value
				ETH_LINK_SPEED_AUTONEG (0) is used, all speeds
				supported are advertised. */
    pub link_speeds: u32,
    /**< Port RX configuration. */
    pub rxmode: rte_eth_rxmode,
    /**< Port TX configuration. */
    pub txmode: rte_eth_txmode,
    /**< Loopback operation mode. By default the value
			         is 0, meaning the loopback mode is disabled.
				 Read the datasheet of given ethernet controller
				 for details. The possible values of this field
				 are defined in implementation of each driver. */
    pub lpbk_mode: u32,
    /**< Port RX filtering configuration (union). */
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    /**< Port TX DCB configuration (union). */
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    /** Currently,Priority Flow Control(PFC) are supported,if DCB with PFC
	    is needed,and the variable must be set ETH_DCB_PFC_SUPPORT. */
    pub dcb_capability_en: u32,
    /**< FDIR configuration. */
    pub fdir_conf: rte_fdir_conf,
    /**< Interrupt mode configuration. */
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
pub struct rte_eth_conf__bindgen_ty_1 {
    /**< Port RSS configuration */
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>() ,
               2120usize);
    assert_eq! (::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) . rss_conf
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) .
                vmdq_dcb_conf as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) .
                dcb_rx_conf as * const _ as usize } , 1064usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_1 ) ) .
                vmdq_rx_conf as * const _ as usize } , 1080usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: __BindgenUnionField<rte_eth_vmdq_dcb_tx_conf>,
    pub dcb_tx_conf: __BindgenUnionField<rte_eth_dcb_tx_conf>,
    pub vmdq_tx_conf: __BindgenUnionField<rte_eth_vmdq_tx_conf>,
    pub bindgen_union_field: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>() ,
                4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_2 ) ) .
                vmdq_dcb_tx_conf as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_2 ) ) .
                dcb_tx_conf as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf__bindgen_ty_2 ) ) .
                vmdq_tx_conf as * const _ as usize } , 0usize);
}
impl Clone for rte_eth_conf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    assert_eq!(::std::mem::size_of::<rte_eth_conf>() , 2944usize);
    assert_eq! (::std::mem::align_of::<rte_eth_conf>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . link_speeds as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . rxmode as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . txmode as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . lpbk_mode as * const _
                as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . rx_adv_conf as * const
                _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . tx_adv_conf as * const
                _ as usize } , 2152usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . dcb_capability_en as *
                const _ as usize } , 2164usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . fdir_conf as * const _
                as usize } , 2168usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_conf ) ) . intr_conf as * const _
                as usize } , 2940usize);
}
/**
 * Ethernet device information
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_info {
    /**< Device PCI information. */
    pub pci_dev: *mut pci_device_list_rte_pci_device,
    /**< Device Driver name. */
    pub driver_name: *const ::std::os::raw::c_char,
    /**< Index to bound host interface, or 0 if none.
		Use if_indextoname() to translate into an interface name. */
    pub if_index: ::std::os::raw::c_uint,
    /**< Minimum size of RX buffer. */
    pub min_rx_bufsize: u32,
    /**< Maximum configurable length of RX pkt. */
    pub max_rx_pktlen: u32,
    /**< Maximum number of RX queues. */
    pub max_rx_queues: u16,
    /**< Maximum number of TX queues. */
    pub max_tx_queues: u16,
    /**< Maximum number of MAC addresses. */
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    /**< Maximum number of VFs. */
    pub max_vfs: u16,
    /**< Maximum number of VMDq pools. */
    pub max_vmdq_pools: u16,
    /**< Device RX offload capabilities. */
    pub rx_offload_capa: u32,
    /**< Device TX offload capabilities. */
    pub tx_offload_capa: u32,
    pub reta_size: u16,
    /**< Hash key size in bytes */
    pub hash_key_size: u8,
    /** Bit mask of RSS offloads, the bit offset also means flow type */
    pub flow_type_rss_offloads: u64,
    /**< Default RX configuration */
    pub default_rxconf: rte_eth_rxconf,
    /**< Default TX configuration */
    pub default_txconf: rte_eth_txconf,
    /**< First queue ID for VMDQ pools. */
    pub vmdq_queue_base: u16,
    /**< Queue number for VMDQ pools. */
    pub vmdq_queue_num: u16,
    /**< First ID of VMDQ pools. */
    pub vmdq_pool_base: u16,
    /**< RX descriptors limits */
    pub rx_desc_lim: rte_eth_desc_lim,
    /**< TX descriptors limits */
    pub tx_desc_lim: rte_eth_desc_lim,
    /**< Supported speeds bitmap (ETH_LINK_SPEED_). */
    pub speed_capa: u32,
    /**< Number of RX queues. */
    pub nb_rx_queues: u16,
    /**< Number of TX queues. */
    pub nb_tx_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_info>() , 120usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dev_info>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . pci_dev as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . driver_name as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . if_index as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . min_rx_bufsize as
                * const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_rx_pktlen as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_rx_queues as *
                const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_tx_queues as *
                const _ as usize } , 30usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_mac_addrs as *
                const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_hash_mac_addrs
                as * const _ as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_vfs as * const
                _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . max_vmdq_pools as
                * const _ as usize } , 42usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . rx_offload_capa as
                * const _ as usize } , 44usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . tx_offload_capa as
                * const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . reta_size as *
                const _ as usize } , 52usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . hash_key_size as *
                const _ as usize } , 54usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) .
                flow_type_rss_offloads as * const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . default_rxconf as
                * const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . default_txconf as
                * const _ as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . vmdq_queue_base as
                * const _ as usize } , 88usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . vmdq_queue_num as
                * const _ as usize } , 90usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . vmdq_pool_base as
                * const _ as usize } , 92usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . rx_desc_lim as *
                const _ as usize } , 94usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . tx_desc_lim as *
                const _ as usize } , 100usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . speed_capa as *
                const _ as usize } , 108usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . nb_rx_queues as *
                const _ as usize } , 112usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_info ) ) . nb_tx_queues as *
                const _ as usize } , 114usize);
}
impl Clone for rte_eth_dev_info {
    fn clone(&self) -> Self { *self }
}
/**
 * Ethernet device RX queue information structure.
 * Used to retieve information about configured queue.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxq_info {
    /**< mempool used by that queue. */
    pub mp: *mut rte_mempool_objhdr_rte_mempool,
    /**< queue config parameters. */
    pub conf: rte_eth_rxconf,
    /**< scattered packets RX supported. */
    pub scattered_rx: u8,
    /**< configured number of RXDs. */
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxq_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxq_info>() , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . mp as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . conf as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . scattered_rx as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxq_info ) ) . nb_desc as * const
                _ as usize } , 18usize);
}
impl Clone for rte_eth_rxq_info {
    fn clone(&self) -> Self { *self }
}
/**
 * Ethernet device TX queue information structure.
 * Used to retieve information about configured queue.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_txq_info {
    /**< queue config parameters. */
    pub conf: rte_eth_txconf,
    /**< configured number of TXDs. */
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u16; 23usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txq_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_txq_info>() , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txq_info ) ) . conf as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_txq_info ) ) . nb_desc as * const
                _ as usize } , 16usize);
}
impl Clone for rte_eth_txq_info {
    fn clone(&self) -> Self { *self }
}
/**
 * An Ethernet device extended statistic structure
 *
 * This structure is used by ethdev->eth_xstats_get() to provide
 * statistics that are not provided in the generic rte_eth_stats
 * structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_xstat {
    pub id: u64,
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_xstat() {
    assert_eq!(::std::mem::size_of::<rte_eth_xstat>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_xstat>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_xstat ) ) . id as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_xstat ) ) . value as * const _ as
                usize } , 8usize);
}
impl Clone for rte_eth_xstat {
    fn clone(&self) -> Self { *self }
}
/**
 * A name-key lookup element for extended statistics.
 *
 * This structure is used to map between names and ID numbers
 * for extended ethernet statistics.
 */
#[repr(C)]
pub struct rte_eth_xstat_name {
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_xstat_name() {
    assert_eq!(::std::mem::size_of::<rte_eth_xstat_name>() , 64usize);
    assert_eq! (::std::mem::align_of::<rte_eth_xstat_name>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_xstat_name ) ) . name as * const
                _ as usize } , 0usize);
}
/**
 * A structure used to get the information of queue and
 * TC mapping on both TX and RX paths.
 */
#[repr(C)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
/** rx queues assigned to tc per Pool */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>()
               , 2usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>()
                , 1usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 )
                ) . base as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 )
                ) . nb_queue as * const _ as usize } , 1usize);
}
impl Clone for rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
/** rx queues assigned to tc per Pool */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>()
               , 2usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>()
                , 1usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 )
                ) . base as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & (
                * ( 0 as * const rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 )
                ) . nb_queue as * const _ as usize } , 1usize);
}
impl Clone for rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>() ,
               2048usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>() ,
                1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tc_queue_mapping ) ) . tc_rxq
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_tc_queue_mapping ) ) . tc_txq
                as * const _ as usize } , 1024usize);
}
/**
 * A structure used to get the information of DCB.
 * It includes TC UP mapping and queue TC mapping.
 */
#[repr(C)]
pub struct rte_eth_dcb_info {
    /**< number of TCs */
    pub nb_tcs: u8,
    /**< Priority to tc */
    pub prio_tc: [u8; 8usize],
    /**< TX BW percentage for each TC */
    pub tc_bws: [u8; 8usize],
    /** rx queues assigned to tc */
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_info() {
    assert_eq!(::std::mem::size_of::<rte_eth_dcb_info>() , 2065usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dcb_info>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . nb_tcs as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . prio_tc as * const
                _ as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . tc_bws as * const
                _ as usize } , 9usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dcb_info ) ) . tc_queue as *
                const _ as usize } , 17usize);
}
/**
 * @internal
 * The generic data structure associated with each ethernet device.
 *
 * Pointers to burst-oriented packet receive and transmit functions are
 * located at the beginning of the structure, along with the pointer to
 * where all the data elements for the particular device are stored in shared
 * memory. This split allows the function pointer and driver data to be per-
 * process, while the actual configuration data for the device is shared.
 */
#[repr(C)]
pub struct rte_eth_dev {
    /**< Pointer to PMD receive function. */
    pub rx_pkt_burst: eth_rx_burst_t,
    /**< Pointer to PMD transmit function. */
    pub tx_pkt_burst: eth_tx_burst_t,
    /**< Pointer to device data */
    pub data: *mut rte_eth_dev_rte_eth_dev_data,
    /**< Driver for this device */
    pub driver: *const rte_eth_dev_eth_driver,
    /**< Functions exported by PMD */
    pub dev_ops: *const eth_dev_ops,
    /**< PCI info. supplied by probing */
    pub pci_dev: *mut pci_device_list_rte_pci_device,
    /** User application callbacks for NIC interrupts */
    pub link_intr_cbs: rte_eth_dev_cb_list,
    /**
	 * User-supplied functions called from rx_burst to post-process
	 * received packets before passing them to the user
	 */
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    /**
	 * User-supplied functions called from tx_burst to pre-process
	 * received packets before passing them to the driver for transmission.
	 */
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    /**< Flag indicating the port is attached */
    pub attached: u8,
    pub __bindgen_padding_0: [u8; 63usize],
}
/**
 * @internal
 * The data part, with no function pointers, associated with each ethernet device.
 *
 * This structure is safe to place in shared memory to be common among different
 * processes in a multi-process configuration.
 */
#[repr(C)]
pub struct rte_eth_dev_rte_eth_dev_data {
    /**< Unique identifier name */
    pub name: [::std::os::raw::c_char; 32usize],
    /**< Array of pointers to RX queues. */
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    /**< Array of pointers to TX queues. */
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    /**< Number of RX queues. */
    pub nb_rx_queues: u16,
    /**< Number of TX queues. */
    pub nb_tx_queues: u16,
    /**< SRIOV data */
    pub sriov: rte_eth_dev_sriov,
    /**< PMD-specific private data */
    pub dev_private: *mut ::std::os::raw::c_void,
    pub dev_link: rte_eth_link,
    /**< Configuration applied to device. */
    pub dev_conf: rte_eth_conf,
    /**< Maximum Transmission Unit. */
    pub mtu: u16,
    pub min_rx_buf_size: u32,
    /**< RX ring mbuf allocation failures. */
    pub rx_mbuf_alloc_failed: u64,
    /**< Device Ethernet Link address. */
    pub mac_addrs: *mut ether_addr,
    pub mac_pool_sel: [u64; 128usize],
    /** bitmap array of associating Ethernet MAC addresses to pools */
    pub hash_mac_addrs: *mut ether_addr,
    /**< Device [external] port identifier. */
    pub port_id: u8,
    pub _bitfield_1: u8,
    pub rx_queue_state: [u8; 1024usize],
    /** Queues state: STARTED(1) / STOPPED(0) */
    pub tx_queue_state: [u8; 1024usize],
    /**< Capabilities */
    pub dev_flags: u32,
    /**< Kernel driver passthrough */
    pub kdrv: rte_kernel_driver,
    /**< NUMA node connection */
    pub numa_node: ::std::os::raw::c_int,
    /**< Driver name */
    pub drv_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_rte_eth_dev_data() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_rte_eth_dev_data>() ,
               6152usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dev_rte_eth_dev_data>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) . name
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                rx_queues as * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                tx_queues as * const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                nb_rx_queues as * const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                nb_tx_queues as * const _ as usize } , 50usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) . sriov
                as * const _ as usize } , 52usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                dev_private as * const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                dev_link as * const _ as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                dev_conf as * const _ as usize } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) . mtu as
                * const _ as usize } , 3024usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                min_rx_buf_size as * const _ as usize } , 3028usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                rx_mbuf_alloc_failed as * const _ as usize } , 3032usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                mac_addrs as * const _ as usize } , 3040usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                mac_pool_sel as * const _ as usize } , 3048usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                hash_mac_addrs as * const _ as usize } , 4072usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                port_id as * const _ as usize } , 4080usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                rx_queue_state as * const _ as usize } , 4082usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                tx_queue_state as * const _ as usize } , 5106usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                dev_flags as * const _ as usize } , 6132usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) . kdrv
                as * const _ as usize } , 6136usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                numa_node as * const _ as usize } , 6140usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_rte_eth_dev_data ) ) .
                drv_name as * const _ as usize } , 6144usize);
}
impl rte_eth_dev_rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u8)) >>
                                       2u32) as u8)
        }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        self._bitfield_1 &= !(4usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (4usize as u8);
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u8)) >>
                                       3u32) as u8)
        }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        self._bitfield_1 &= !(8usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 3u32) & (8usize as u8);
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u8)) >>
                                       4u32) as u8)
        }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        self._bitfield_1 &= !(16usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 4u32) & (16usize as u8);
    }
}
/**
 * @internal
 * The structure associated with a PMD Ethernet driver.
 *
 * Each Ethernet driver acts as a PCI driver and is represented by a generic
 * *eth_driver* structure that holds:
 *
 * - An *rte_pci_driver* structure (which must be the first field).
 *
 * - The *eth_dev_init* function invoked for each matching PCI device.
 *
 * - The *eth_dev_uninit* function invoked for each matching PCI device.
 *
 * - The size of the private data to allocate for each matching device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_eth_driver {
    /**< The PMD is also a PCI driver. */
    pub pci_drv: pci_driver_list_rte_pci_driver,
    /**< Device init function. */
    pub eth_dev_init: eth_dev_init_t,
    /**< Device uninit function. */
    pub eth_dev_uninit: eth_dev_uninit_t,
    /**< Size of device private data. */
    pub dev_private_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_eth_driver() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_eth_driver>() , 104usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dev_eth_driver>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_eth_driver ) ) . pci_drv as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_eth_driver ) ) . eth_dev_init
                as * const _ as usize } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_eth_driver ) ) .
                eth_dev_uninit as * const _ as usize } , 88usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_eth_driver ) ) .
                dev_private_size as * const _ as usize } , 96usize);
}
impl Clone for rte_eth_dev_eth_driver {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_dev() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev>() , 16512usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . rx_pkt_burst as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . tx_pkt_burst as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . data as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . driver as * const _ as
                usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . dev_ops as * const _ as
                usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . pci_dev as * const _ as
                usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . link_intr_cbs as *
                const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . post_rx_burst_cbs as *
                const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . pre_tx_burst_cbs as *
                const _ as usize } , 8256usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev ) ) . attached as * const _
                as usize } , 16448usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback([u8; 0]);
/** @internal Structure to keep track of registered callbacks */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_cb_list() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_cb_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dev_cb_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_cb_list ) ) . tqh_first as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_cb_list ) ) . tqh_last as *
                const _ as usize } , 8usize);
}
impl Clone for rte_eth_dev_cb_list {
    fn clone(&self) -> Self { *self }
}
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_link_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               wait_to_complete:
                                                   ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type eth_stats_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               igb_stats:
                                                   *mut rte_eth_stats)>;
pub type eth_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               stats: *mut rte_eth_xstat,
                                               n: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type eth_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_names_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               xstats_names:
                                                   *mut rte_eth_xstat_name,
                                               size: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type eth_queue_stats_mapping_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_id: u16, stat_idx: u8,
                                               is_rx: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_infos_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               dev_info:
                                                   *mut rte_eth_dev_info)>;
pub type eth_dev_supported_ptypes_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> *const ::std::os::raw::c_uint>;
pub type eth_queue_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_queue_stop_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_rx_queue_setup_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16,
                                               nb_rx_desc: u16,
                                               socket_id:
                                                   ::std::os::raw::c_uint,
                                               rx_conf: *const rte_eth_rxconf,
                                               mb_pool:
                                                   *mut rte_mempool_objhdr_rte_mempool)
                              -> ::std::os::raw::c_int>;
pub type eth_tx_queue_setup_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tx_queue_id: u16,
                                               nb_tx_desc: u16,
                                               socket_id:
                                                   ::std::os::raw::c_uint,
                                               tx_conf: *const rte_eth_txconf)
                              -> ::std::os::raw::c_int>;
pub type eth_rx_enable_intr_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_rx_disable_intr_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(queue:
                                                   *mut ::std::os::raw::c_void)>;
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16)
                              -> ::std::os::raw::c_uint>;
pub type eth_rx_descriptor_done_t =
    ::std::option::Option<unsafe extern "C" fn(rxq:
                                                   *mut ::std::os::raw::c_void,
                                               offset: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_rxq_info_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16,
                                               qinfo: *mut rte_eth_rxq_info)>;
pub type eth_txq_info_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tx_queue_id: u16,
                                               qinfo: *mut rte_eth_txq_info)>;
pub type mtu_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mtu: u16)
                              -> ::std::os::raw::c_int>;
pub type vlan_filter_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               vlan_id: u16,
                                               on: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type vlan_tpid_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               type_: rte_vlan_type,
                                               tpid: u16)
                              -> ::std::os::raw::c_int>;
pub type vlan_offload_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mask: ::std::os::raw::c_int)>;
pub type vlan_pvid_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               vlan_id: u16,
                                               on: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type vlan_strip_queue_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rx_queue_id: u16,
                                               on: ::std::os::raw::c_int)>;
pub type eth_rx_burst_t =
    ::std::option::Option<unsafe extern "C" fn(rxq:
                                                   *mut ::std::os::raw::c_void,
                                               rx_pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16)
                              -> ::std::os::raw::c_ushort>;
pub type eth_tx_burst_t =
    ::std::option::Option<unsafe extern "C" fn(txq:
                                                   *mut ::std::os::raw::c_void,
                                               tx_pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16)
                              -> ::std::os::raw::c_ushort>;
pub type flow_ctrl_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               fc_conf: *mut rte_eth_fc_conf)
                              -> ::std::os::raw::c_int>;
pub type flow_ctrl_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               fc_conf: *mut rte_eth_fc_conf)
                              -> ::std::os::raw::c_int>;
pub type priority_flow_ctrl_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               pfc_conf:
                                                   *mut rte_eth_pfc_conf)
                              -> ::std::os::raw::c_int>;
pub type reta_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               reta_conf:
                                                   *mut rte_eth_rss_reta_entry64,
                                               reta_size: u16)
                              -> ::std::os::raw::c_int>;
pub type reta_query_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               reta_conf:
                                                   *mut rte_eth_rss_reta_entry64,
                                               reta_size: u16)
                              -> ::std::os::raw::c_int>;
pub type rss_hash_update_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rss_conf:
                                                   *mut rte_eth_rss_conf)
                              -> ::std::os::raw::c_int>;
pub type rss_hash_conf_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rss_conf:
                                                   *mut rte_eth_rss_conf)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               index: u32)>;
pub type eth_mac_addr_add_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mac_addr: *mut ether_addr,
                                               index: u32, vmdq: u32)>;
pub type eth_mac_addr_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mac_addr: *mut ether_addr)>;
pub type eth_uc_hash_table_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mac_addr: *mut ether_addr,
                                               on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_uc_all_hash_table_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_set_vf_rx_mode_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, vf: u16,
                                               rx_mode: u16, on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_set_vf_rx_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, vf: u16,
                                               on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_set_vf_tx_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, vf: u16,
                                               on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_set_vf_vlan_filter_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               vlan: u16, vf_mask: u64,
                                               vlan_on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_set_queue_rate_limit_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               queue_idx: u16, tx_rate: u16)
                              -> ::std::os::raw::c_int>;
pub type eth_set_vf_rate_limit_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, vf: u16,
                                               tx_rate: u16, q_msk: u64)
                              -> ::std::os::raw::c_int>;
pub type eth_mirror_rule_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mirror_conf:
                                                   *mut rte_eth_mirror_conf,
                                               rule_id: u8, on: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_mirror_rule_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               rule_id: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_udp_tunnel_port_add_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tunnel_udp:
                                                   *mut rte_eth_udp_tunnel)
                              -> ::std::os::raw::c_int>;
pub type eth_udp_tunnel_port_del_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               tunnel_udp:
                                                   *mut rte_eth_udp_tunnel)
                              -> ::std::os::raw::c_int>;
pub type eth_set_mc_addr_list_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               mc_addr_set: *mut ether_addr,
                                               nb_mc_addr: u32)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_read_rx_timestamp_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *mut timespec,
                                               flags: u32)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_read_tx_timestamp_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *mut timespec)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_adjust_time =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               arg1: i64)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_read_time =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *mut timespec)
                              -> ::std::os::raw::c_int>;
pub type eth_timesync_write_time =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               timestamp: *const timespec)
                              -> ::std::os::raw::c_int>;
pub type eth_get_reg_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               info: *mut rte_dev_reg_info)
                              -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               info: *mut rte_dev_eeprom_info)
                              -> ::std::os::raw::c_int>;
pub type eth_set_eeprom_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               info: *mut rte_dev_eeprom_info)
                              -> ::std::os::raw::c_int>;
pub type eth_l2_tunnel_eth_type_conf_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               l2_tunnel:
                                                   *mut rte_eth_l2_tunnel_conf)
                              -> ::std::os::raw::c_int>;
pub type eth_l2_tunnel_offload_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               l2_tunnel:
                                                   *mut rte_eth_l2_tunnel_conf,
                                               mask: u32, en: u8)
                              -> ::std::os::raw::c_int>;
pub type eth_filter_ctrl_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               filter_type: rte_filter_type,
                                               filter_op: rte_filter_op,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type eth_get_dcb_info =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev,
                                               dcb_info:
                                                   *mut rte_eth_dcb_info)
                              -> ::std::os::raw::c_int>;
/**
 * @internal A structure containing the functions exported by an Ethernet driver.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eth_dev_ops {
    /**< Configure device. */
    pub dev_configure: eth_dev_configure_t,
    /**< Start device. */
    pub dev_start: eth_dev_start_t,
    /**< Stop device. */
    pub dev_stop: eth_dev_stop_t,
    /**< Device link up. */
    pub dev_set_link_up: eth_dev_set_link_up_t,
    /**< Device link down. */
    pub dev_set_link_down: eth_dev_set_link_down_t,
    /**< Close device. */
    pub dev_close: eth_dev_close_t,
    /**< Promiscuous ON. */
    pub promiscuous_enable: eth_promiscuous_enable_t,
    /**< Promiscuous OFF. */
    pub promiscuous_disable: eth_promiscuous_disable_t,
    /**< RX multicast ON. */
    pub allmulticast_enable: eth_allmulticast_enable_t,
    /**< RX multicast OF. */
    pub allmulticast_disable: eth_allmulticast_disable_t,
    /**< Get device link state. */
    pub link_update: eth_link_update_t,
    /**< Get generic device statistics. */
    pub stats_get: eth_stats_get_t,
    /**< Reset generic device statistics. */
    pub stats_reset: eth_stats_reset_t,
    /**< Get extended device statistics. */
    pub xstats_get: eth_xstats_get_t,
    /**< Reset extended device statistics. */
    pub xstats_reset: eth_xstats_reset_t,
    pub xstats_get_names: eth_xstats_get_names_t,
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    /**< Get device info. */
    pub dev_infos_get: eth_dev_infos_get_t,
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    /**< Set MTU. */
    pub mtu_set: mtu_set_t,
    /**< Filter VLAN Setup. */
    pub vlan_filter_set: vlan_filter_set_t,
    /**< Outer/Inner VLAN TPID Setup. */
    pub vlan_tpid_set: vlan_tpid_set_t,
    /**< VLAN Stripping on queue. */
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    /**< Set VLAN Offload. */
    pub vlan_offload_set: vlan_offload_set_t,
    /**< Set port based TX VLAN insertion */
    pub vlan_pvid_set: vlan_pvid_set_t,
    /**< Start RX for a queue.*/
    pub rx_queue_start: eth_queue_start_t,
    /**< Stop RX for a queue.*/
    pub rx_queue_stop: eth_queue_stop_t,
    /**< Start TX for a queue.*/
    pub tx_queue_start: eth_queue_start_t,
    /**< Stop TX for a queue.*/
    pub tx_queue_stop: eth_queue_stop_t,
    /**< Set up device RX queue.*/
    pub rx_queue_setup: eth_rx_queue_setup_t,
    /**< Release RX queue.*/
    pub rx_queue_release: eth_queue_release_t,
    /**< Get Rx queue count. */
    pub rx_queue_count: eth_rx_queue_count_t,
    /**< Check rxd DD bit */
	/**< Enable Rx queue interrupt. */
    pub rx_descriptor_done: eth_rx_descriptor_done_t,
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    /**< Set up device TX queue.*/
    pub tx_queue_setup: eth_tx_queue_setup_t,
    /**< Release TX queue.*/
    pub tx_queue_release: eth_queue_release_t,
    /**< Turn on LED. */
    pub dev_led_on: eth_dev_led_on_t,
    /**< Turn off LED. */
    pub dev_led_off: eth_dev_led_off_t,
    /**< Get flow control. */
    pub flow_ctrl_get: flow_ctrl_get_t,
    /**< Setup flow control. */
    pub flow_ctrl_set: flow_ctrl_set_t,
    /**< Setup priority flow control.*/
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    /**< Remove MAC address */
    pub mac_addr_remove: eth_mac_addr_remove_t,
    /**< Add a MAC address */
    pub mac_addr_add: eth_mac_addr_add_t,
    /**< Set a MAC address */
    pub mac_addr_set: eth_mac_addr_set_t,
    /**< Set Unicast Table Array */
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    /**< Set Unicast hash bitmap */
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    /**< Add a traffic mirror rule.*/
    pub mirror_rule_set: eth_mirror_rule_set_t,
    /**< reset a traffic mirror rule.*/
    pub mirror_rule_reset: eth_mirror_rule_reset_t,
    /**< Set VF RX mode */
    pub set_vf_rx_mode: eth_set_vf_rx_mode_t,
    /**< enable/disable a VF receive */
    pub set_vf_rx: eth_set_vf_rx_t,
    /**< enable/disable a VF transmit */
    pub set_vf_tx: eth_set_vf_tx_t,
    /**< Set VF VLAN filter */
    pub set_vf_vlan_filter: eth_set_vf_vlan_filter_t,
    /** Add UDP tunnel port. */
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    /** Del UDP tunnel port. */
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    /**< Set queue rate limit */
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    /**< Set VF rate limit */
    pub set_vf_rate_limit: eth_set_vf_rate_limit_t,
    /** Update redirection table. */
    pub reta_update: reta_update_t,
    /** Query redirection table. */
    pub reta_query: reta_query_t,
    pub get_reg: eth_get_reg_t,
    pub get_eeprom_length: eth_get_eeprom_length_t,
    pub get_eeprom: eth_get_eeprom_t,
    pub set_eeprom: eth_set_eeprom_t,
    /** Configure RSS hash protocols. */
    pub rss_hash_update: rss_hash_update_t,
    /** Get current RSS hash configuration. */
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    pub filter_ctrl: eth_filter_ctrl_t,
    /**< set list of mcast addrs */
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    pub rxq_info_get: eth_rxq_info_get_t,
    pub txq_info_get: eth_txq_info_get_t,
    /** Turn IEEE1588/802.1AS timestamping on. */
    pub timesync_enable: eth_timesync_enable_t,
    /** Turn IEEE1588/802.1AS timestamping off. */
    pub timesync_disable: eth_timesync_disable_t,
    /** Read the IEEE1588/802.1AS RX timestamp. */
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    /** Read the IEEE1588/802.1AS TX timestamp. */
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    /** Get DCB information */
    pub get_dcb_info: eth_get_dcb_info,
    /** Adjust the device clock.*/
    pub timesync_adjust_time: eth_timesync_adjust_time,
    /** Get the device clock time. */
    pub timesync_read_time: eth_timesync_read_time,
    /** Set the device clock time. */
    pub timesync_write_time: eth_timesync_write_time,
    /** Config ether type of l2 tunnel */
    pub l2_tunnel_eth_type_conf: eth_l2_tunnel_eth_type_conf_t,
    /** Enable/disable l2 tunnel offload functions */
    pub l2_tunnel_offload_set: eth_l2_tunnel_offload_set_t,
}
#[test]
fn bindgen_test_layout_eth_dev_ops() {
    assert_eq!(::std::mem::size_of::<eth_dev_ops>() , 632usize);
    assert_eq! (::std::mem::align_of::<eth_dev_ops>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_configure as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_start as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_stop as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_set_link_up as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_set_link_down as *
                const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_close as * const _
                as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . promiscuous_enable as *
                const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . promiscuous_disable as
                * const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . allmulticast_enable as
                * const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . allmulticast_disable as
                * const _ as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . link_update as * const
                _ as usize } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . stats_get as * const _
                as usize } , 88usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . stats_reset as * const
                _ as usize } , 96usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_get as * const _
                as usize } , 104usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_reset as * const
                _ as usize } , 112usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . xstats_get_names as *
                const _ as usize } , 120usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . queue_stats_mapping_set
                as * const _ as usize } , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_infos_get as *
                const _ as usize } , 136usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) .
                dev_supported_ptypes_get as * const _ as usize } , 144usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mtu_set as * const _ as
                usize } , 152usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_filter_set as *
                const _ as usize } , 160usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_tpid_set as *
                const _ as usize } , 168usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_strip_queue_set as
                * const _ as usize } , 176usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_offload_set as *
                const _ as usize } , 184usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . vlan_pvid_set as *
                const _ as usize } , 192usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_start as *
                const _ as usize } , 200usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_stop as *
                const _ as usize } , 208usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_start as *
                const _ as usize } , 216usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_stop as *
                const _ as usize } , 224usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_setup as *
                const _ as usize } , 232usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_release as *
                const _ as usize } , 240usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_count as *
                const _ as usize } , 248usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_descriptor_done as *
                const _ as usize } , 256usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_intr_enable as
                * const _ as usize } , 264usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rx_queue_intr_disable
                as * const _ as usize } , 272usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_setup as *
                const _ as usize } , 280usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . tx_queue_release as *
                const _ as usize } , 288usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_led_on as * const _
                as usize } , 296usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . dev_led_off as * const
                _ as usize } , 304usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . flow_ctrl_get as *
                const _ as usize } , 312usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . flow_ctrl_set as *
                const _ as usize } , 320usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . priority_flow_ctrl_set
                as * const _ as usize } , 328usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mac_addr_remove as *
                const _ as usize } , 336usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mac_addr_add as * const
                _ as usize } , 344usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mac_addr_set as * const
                _ as usize } , 352usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . uc_hash_table_set as *
                const _ as usize } , 360usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . uc_all_hash_table_set
                as * const _ as usize } , 368usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mirror_rule_set as *
                const _ as usize } , 376usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . mirror_rule_reset as *
                const _ as usize } , 384usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_vf_rx_mode as *
                const _ as usize } , 392usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_vf_rx as * const _
                as usize } , 400usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_vf_tx as * const _
                as usize } , 408usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_vf_vlan_filter as *
                const _ as usize } , 416usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . udp_tunnel_port_add as
                * const _ as usize } , 424usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . udp_tunnel_port_del as
                * const _ as usize } , 432usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_queue_rate_limit as
                * const _ as usize } , 440usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_vf_rate_limit as *
                const _ as usize } , 448usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . reta_update as * const
                _ as usize } , 456usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . reta_query as * const _
                as usize } , 464usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_reg as * const _ as
                usize } , 472usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_eeprom_length as *
                const _ as usize } , 480usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_eeprom as * const _
                as usize } , 488usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_eeprom as * const _
                as usize } , 496usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rss_hash_update as *
                const _ as usize } , 504usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rss_hash_conf_get as *
                const _ as usize } , 512usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . filter_ctrl as * const
                _ as usize } , 520usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . set_mc_addr_list as *
                const _ as usize } , 528usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . rxq_info_get as * const
                _ as usize } , 536usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . txq_info_get as * const
                _ as usize } , 544usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_enable as *
                const _ as usize } , 552usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_disable as *
                const _ as usize } , 560usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) .
                timesync_read_rx_timestamp as * const _ as usize } ,
                568usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) .
                timesync_read_tx_timestamp as * const _ as usize } ,
                576usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . get_dcb_info as * const
                _ as usize } , 584usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_adjust_time as
                * const _ as usize } , 592usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_read_time as *
                const _ as usize } , 600usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . timesync_write_time as
                * const _ as usize } , 608usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . l2_tunnel_eth_type_conf
                as * const _ as usize } , 616usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const eth_dev_ops ) ) . l2_tunnel_offload_set
                as * const _ as usize } , 624usize);
}
impl Clone for eth_dev_ops {
    fn clone(&self) -> Self { *self }
}
/**
 * Function type used for RX packet processing packet callbacks.
 *
 * The callback function is called on RX with a burst of packets that have
 * been received on the given port and queue.
 *
 * @param port
 *   The Ethernet port on which RX is being performed.
 * @param queue
 *   The queue on the Ethernet port which is being used to receive the packets.
 * @param pkts
 *   The burst of packets that have just been received.
 * @param nb_pkts
 *   The number of packets in the burst pointed to by "pkts".
 * @param max_pkts
 *   The max number of packets that can be stored in the "pkts" array.
 * @param user_param
 *   The arbitrary user parameter passed in by the application when the callback
 *   was originally configured.
 * @return
 *   The number of packets returned to the user.
 */
pub type rte_rx_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(port: u8, queue: u16,
                                               pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16, max_pkts: u16,
                                               user_param:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_ushort>;
/**
 * Function type used for TX packet processing packet callbacks.
 *
 * The callback function is called on TX with a burst of packets immediately
 * before the packets are put onto the hardware queue for transmission.
 *
 * @param port
 *   The Ethernet port on which TX is being performed.
 * @param queue
 *   The queue on the Ethernet port which is being used to transmit the packets.
 * @param pkts
 *   The burst of packets that are about to be transmitted.
 * @param nb_pkts
 *   The number of packets in the burst pointed to by "pkts".
 * @param user_param
 *   The arbitrary user parameter passed in by the application when the callback
 *   was originally configured.
 * @return
 *   The number of packets to be written to the NIC.
 */
pub type rte_tx_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(port: u8, queue: u16,
                                               pkts: *mut *mut rte_mbuf,
                                               nb_pkts: u16,
                                               user_param:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_ushort>;
/**
 * @internal
 * Structure used to hold information about the callbacks to be called for a
 * queue on RX and TX.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: __BindgenUnionField<rte_rx_callback_fn>,
    pub tx: __BindgenUnionField<rte_tx_callback_fn>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxtx_callback__bindgen_ty_1>() ,
               8usize);
    assert_eq! (::std::mem::align_of::<rte_eth_rxtx_callback__bindgen_ty_1>()
                , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback__bindgen_ty_1 ) ) .
                rx as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback__bindgen_ty_1 ) ) .
                tx as * const _ as usize } , 0usize);
}
impl Clone for rte_eth_rxtx_callback__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback() {
    assert_eq!(::std::mem::size_of::<rte_eth_rxtx_callback>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_eth_rxtx_callback>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback ) ) . next as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback ) ) . fn_ as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_rxtx_callback ) ) . param as *
                const _ as usize } , 16usize);
}
impl Clone for rte_eth_rxtx_callback {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_sriov {
    /**< SRIOV is active with 16, 32 or 64 pools */
    pub active: u8,
    /**< rx queue number per pool */
    pub nb_q_per_pool: u8,
    /**< Default pool num used for PF */
    pub def_vmdq_idx: u16,
    /**< Default pool queue start reg index */
    pub def_pool_q_idx: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_sriov() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_sriov>() , 6usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dev_sriov>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . active as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . nb_q_per_pool as
                * const _ as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . def_vmdq_idx as *
                const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_eth_dev_sriov ) ) . def_pool_q_idx as
                * const _ as usize } , 4usize);
}
impl Clone for rte_eth_dev_sriov {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Get the total number of Ethernet devices that have been successfully
 * initialized by the [matching] Ethernet driver during the PCI probing phase.
 * All devices whose port identifier is in the range
 * [0,  rte_eth_dev_count() - 1] can be operated on by network applications
 * immediately after invoking rte_eal_init().
 * If the application unplugs a port using hotplug function, The enabled port
 * numbers may be noncontiguous. In the case, the applications need to manage
 * enabled port by themselves.
 *
 * @return
 *   - The total number of usable Ethernet devices.
 */
    pub fn rte_eth_dev_count() -> u8;
}
extern "C" {
    /**
 * @internal
 * Returns a ethdev slot specified by the unique identifier name.
 *
 * @param	name
 *  The pointer to the Unique identifier name for each Ethernet device
 * @return
 *   - The pointer to the ethdev slot, on success. NULL on error
 */
    pub fn rte_eth_dev_allocated(name: *const ::std::os::raw::c_char)
     -> *mut rte_eth_dev;
}
extern "C" {
    /**
 * @internal
 * Allocates a new ethdev slot for an ethernet device and returns the pointer
 * to that slot for the driver to use.
 *
 * @param	name	Unique identifier name for each Ethernet device
 * @param	type	Device type of this Ethernet device
 * @return
 *   - Slot in the rte_dev_devices array for a new device;
 */
    pub fn rte_eth_dev_allocate(name: *const ::std::os::raw::c_char)
     -> *mut rte_eth_dev;
}
extern "C" {
    /**
 * @internal
 * Release the specified ethdev port.
 *
 * @param eth_dev
 * The *eth_dev* pointer is the address of the *rte_eth_dev* structure.
 * @return
 *   - 0 on success, negative on error
 */
    pub fn rte_eth_dev_release_port(eth_dev: *mut rte_eth_dev)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Attach a new Ethernet device specified by aruguments.
 *
 * @param devargs
 *  A pointer to a strings array describing the new device
 *  to be attached. The strings should be a pci address like
 *  '0000:01:00.0' or virtual device name like 'net_pcap0'.
 * @param port_id
 *  A pointer to a port identifier actually attached.
 * @return
 *  0 on success and port_id is filled, negative on error
 */
    pub fn rte_eth_dev_attach(devargs: *const ::std::os::raw::c_char,
                              port_id: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Detach a Ethernet device specified by port identifier.
 * This function must be called when the device is in the
 * closed state.
 *
 * @param port_id
 *   The port identifier of the device to detach.
 * @param devname
 *  A pointer to a device name actually detached.
 * @return
 *  0 on success and devname is filled, negative on error
 */
    pub fn rte_eth_dev_detach(port_id: u8,
                              devname: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
/**
 * @internal
 * Initialization function of an Ethernet driver invoked for each matching
 * Ethernet PCI device detected during the PCI probing phase.
 *
 * @param eth_dev
 *   The *eth_dev* pointer is the address of the *rte_eth_dev* structure
 *   associated with the matching device and which have been [automatically]
 *   allocated in the *rte_eth_devices* array.
 *   The *eth_dev* structure is supplied to the driver initialization function
 *   with the following fields already initialized:
 *
 *   - *pci_dev*: Holds the pointers to the *rte_pci_device* structure which
 *     contains the generic PCI information of the matching device.
 *
 *   - *driver*: Holds the pointer to the *eth_driver* structure.
 *
 *   - *dev_private*: Holds a pointer to the device private data structure.
 *
 *   - *mtu*: Contains the default Ethernet maximum frame length (1500).
 *
 *   - *port_id*: Contains the port index of the device (actually the index
 *     of the *eth_dev* structure in the *rte_eth_devices* array).
 *
 * @return
 *   - 0: Success, the device is properly initialized by the driver.
 *        In particular, the driver MUST have set up the *dev_ops* pointer
 *        of the *eth_dev* structure.
 *   - <0: Error code of the device initialization failure.
 */
pub type eth_dev_init_t =
    ::std::option::Option<unsafe extern "C" fn(eth_dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
/**
 * @internal
 * Finalization function of an Ethernet driver invoked for each matching
 * Ethernet PCI device detected during the PCI closing phase.
 *
 * @param eth_dev
 *   The *eth_dev* pointer is the address of the *rte_eth_dev* structure
 *   associated with the matching device and which have been [automatically]
 *   allocated in the *rte_eth_devices* array.
 * @return
 *   - 0: Success, the device is properly finalized by the driver.
 *        In particular, the driver MUST free the *dev_ops* pointer
 *        of the *eth_dev* structure.
 *   - <0: Error code of the device initialization failure.
 */
pub type eth_dev_uninit_t =
    ::std::option::Option<unsafe extern "C" fn(eth_dev: *mut rte_eth_dev)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /**
 * Convert a numerical speed in Mbps to a bitmap flag that can be used in
 * the bitmap link_speeds of the struct rte_eth_conf
 *
 * @param speed
 *   Numerical speed value in Mbps
 * @param duplex
 *   ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)
 * @return
 *   0 if the speed cannot be mapped
 */
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int)
     -> u32;
}
extern "C" {
    /**
 * Configure an Ethernet device.
 * This function must be invoked first before any other function in the
 * Ethernet API. This function can also be re-invoked when a device is in the
 * stopped state.
 *
 * @param port_id
 *   The port identifier of the Ethernet device to configure.
 * @param nb_rx_queue
 *   The number of receive queues to set up for the Ethernet device.
 * @param nb_tx_queue
 *   The number of transmit queues to set up for the Ethernet device.
 * @param eth_conf
 *   The pointer to the configuration data to be used for the Ethernet device.
 *   The *rte_eth_conf* structure includes:
 *     -  the hardware offload features to activate, with dedicated fields for
 *        each statically configurable offload hardware feature provided by
 *        Ethernet devices, such as IP checksum or VLAN tag stripping for
 *        example.
 *     - the Receive Side Scaling (RSS) configuration when using multiple RX
 *         queues per port.
 *
 *   Embedding all configuration information in a single data structure
 *   is the more flexible method that allows the addition of new features
 *   without changing the syntax of the API.
 * @return
 *   - 0: Success, device configured.
 *   - <0: Error code returned by the driver configuration function.
 */
    pub fn rte_eth_dev_configure(port_id: u8, nb_rx_queue: u16,
                                 nb_tx_queue: u16,
                                 eth_conf: *const rte_eth_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Allocate and set up a receive queue for an Ethernet device.
 *
 * The function allocates a contiguous block of memory for *nb_rx_desc*
 * receive descriptors from a memory zone associated with *socket_id*
 * and initializes each receive descriptor with a network buffer allocated
 * from the memory pool *mb_pool*.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param rx_queue_id
 *   The index of the receive queue to set up.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @param nb_rx_desc
 *   The number of receive descriptors to allocate for the receive ring.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in case of NUMA.
 *   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for
 *   the DMA memory allocated for the receive descriptors of the ring.
 * @param rx_conf
 *   The pointer to the configuration data to be used for the receive queue.
 *   NULL value is allowed, in which case default RX configuration
 *   will be used.
 *   The *rx_conf* structure contains an *rx_thresh* structure with the values
 *   of the Prefetch, Host, and Write-Back threshold registers of the receive
 *   ring.
 * @param mb_pool
 *   The pointer to the memory pool from which to allocate *rte_mbuf* network
 *   memory buffers to populate each descriptor of the receive ring.
 * @return
 *   - 0: Success, receive queue correctly set up.
 *   - -EINVAL: The size of network buffers which can be allocated from the
 *      memory pool does not fit the various buffer sizes allowed by the
 *      device controller.
 *   - -ENOMEM: Unable to allocate the receive ring descriptors or to
 *      allocate network memory buffers from the memory pool when
 *      initializing receive descriptors.
 */
    pub fn rte_eth_rx_queue_setup(port_id: u8, rx_queue_id: u16,
                                  nb_rx_desc: u16,
                                  socket_id: ::std::os::raw::c_uint,
                                  rx_conf: *const rte_eth_rxconf,
                                  mb_pool:
                                      *mut rte_mempool_objhdr_rte_mempool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Allocate and set up a transmit queue for an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param tx_queue_id
 *   The index of the transmit queue to set up.
 *   The value must be in the range [0, nb_tx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @param nb_tx_desc
 *   The number of transmit descriptors to allocate for the transmit ring.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in case of NUMA.
 *   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for
 *   the DMA memory allocated for the transmit descriptors of the ring.
 * @param tx_conf
 *   The pointer to the configuration data to be used for the transmit queue.
 *   NULL value is allowed, in which case default RX configuration
 *   will be used.
 *   The *tx_conf* structure contains the following data:
 *   - The *tx_thresh* structure with the values of the Prefetch, Host, and
 *     Write-Back threshold registers of the transmit ring.
 *     When setting Write-Back threshold to the value greater then zero,
 *     *tx_rs_thresh* value should be explicitly set to one.
 *   - The *tx_free_thresh* value indicates the [minimum] number of network
 *     buffers that must be pending in the transmit ring to trigger their
 *     [implicit] freeing by the driver transmit function.
 *   - The *tx_rs_thresh* value indicates the [minimum] number of transmit
 *     descriptors that must be pending in the transmit ring before setting the
 *     RS bit on a descriptor by the driver transmit function.
 *     The *tx_rs_thresh* value should be less or equal then
 *     *tx_free_thresh* value, and both of them should be less then
 *     *nb_tx_desc* - 3.
 *   - The *txq_flags* member contains flags to pass to the TX queue setup
 *     function to configure the behavior of the TX queue. This should be set
 *     to 0 if no special configuration is required.
 *
 *     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces
 *     the transmit function to use default values.
 * @return
 *   - 0: Success, the transmit queue is correctly set up.
 *   - -ENOMEM: Unable to allocate the transmit ring descriptors.
 */
    pub fn rte_eth_tx_queue_setup(port_id: u8, tx_queue_id: u16,
                                  nb_tx_desc: u16,
                                  socket_id: ::std::os::raw::c_uint,
                                  tx_conf: *const rte_eth_txconf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Return the NUMA socket to which an Ethernet device is connected
 *
 * @param port_id
 *   The port identifier of the Ethernet device
 * @return
 *   The NUMA socket id to which the Ethernet device is connected or
 *   a default of zero if the socket could not be determined.
 *   -1 is returned is the port_id value is out of range.
 */
    pub fn rte_eth_dev_socket_id(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Check if port_id of device is attached
 *
 * @param port_id
 *   The port identifier of the Ethernet device
 * @return
 *   - 0 if port is out of range or not attached
 *   - 1 if device is attached
 */
    pub fn rte_eth_dev_is_valid_port(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Start specified RX queue of a port. It is used when rx_deferred_start
 * flag of the specified queue is true.
 *
 * @param port_id
 *   The port identifier of the Ethernet device
 * @param rx_queue_id
 *   The index of the rx queue to update the ring.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @return
 *   - 0: Success, the receive queue is started.
 *   - -EINVAL: The port_id or the queue_id out of range.
 *   - -ENOTSUP: The function not supported in PMD driver.
 */
    pub fn rte_eth_dev_rx_queue_start(port_id: u8, rx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Stop specified RX queue of a port
 *
 * @param port_id
 *   The port identifier of the Ethernet device
 * @param rx_queue_id
 *   The index of the rx queue to update the ring.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @return
 *   - 0: Success, the receive queue is stopped.
 *   - -EINVAL: The port_id or the queue_id out of range.
 *   - -ENOTSUP: The function not supported in PMD driver.
 */
    pub fn rte_eth_dev_rx_queue_stop(port_id: u8, rx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Start TX for specified queue of a port. It is used when tx_deferred_start
 * flag of the specified queue is true.
 *
 * @param port_id
 *   The port identifier of the Ethernet device
 * @param tx_queue_id
 *   The index of the tx queue to update the ring.
 *   The value must be in the range [0, nb_tx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @return
 *   - 0: Success, the transmit queue is started.
 *   - -EINVAL: The port_id or the queue_id out of range.
 *   - -ENOTSUP: The function not supported in PMD driver.
 */
    pub fn rte_eth_dev_tx_queue_start(port_id: u8, tx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Stop specified TX queue of a port
 *
 * @param port_id
 *   The port identifier of the Ethernet device
 * @param tx_queue_id
 *   The index of the tx queue to update the ring.
 *   The value must be in the range [0, nb_tx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @return
 *   - 0: Success, the transmit queue is stopped.
 *   - -EINVAL: The port_id or the queue_id out of range.
 *   - -ENOTSUP: The function not supported in PMD driver.
 */
    pub fn rte_eth_dev_tx_queue_stop(port_id: u8, tx_queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Start an Ethernet device.
 *
 * The device start step is the last one and consists of setting the configured
 * offload features and in starting the transmit and the receive units of the
 * device.
 * On success, all basic functions exported by the Ethernet API (link status,
 * receive/transmit, and so on) can be invoked.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - 0: Success, Ethernet device started.
 *   - <0: Error code of the driver device start function.
 */
    pub fn rte_eth_dev_start(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Stop an Ethernet device. The device can be restarted with a call to
 * rte_eth_dev_start()
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_dev_stop(port_id: u8);
}
extern "C" {
    /**
 * Link up an Ethernet device.
 *
 * Set device link up will re-enable the device rx/tx
 * functionality after it is previously set device linked down.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - 0: Success, Ethernet device linked up.
 *   - <0: Error code of the driver device link up function.
 */
    pub fn rte_eth_dev_set_link_up(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Link down an Ethernet device.
 * The device rx/tx functionality will be disabled if success,
 * and it can be re-enabled with a call to
 * rte_eth_dev_set_link_up()
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_dev_set_link_down(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Close a stopped Ethernet device. The device cannot be restarted!
 * The function frees all resources except for needed by the
 * closed state. To free these resources, call rte_eth_dev_detach().
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_dev_close(port_id: u8);
}
extern "C" {
    /**
 * Enable receipt in promiscuous mode for an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_promiscuous_enable(port_id: u8);
}
extern "C" {
    /**
 * Disable receipt in promiscuous mode for an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_promiscuous_disable(port_id: u8);
}
extern "C" {
    /**
 * Return the value of promiscuous mode for an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - (1) if promiscuous is enabled
 *   - (0) if promiscuous is disabled.
 *   - (-1) on error
 */
    pub fn rte_eth_promiscuous_get(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Enable the receipt of any multicast frame by an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_allmulticast_enable(port_id: u8);
}
extern "C" {
    /**
 * Disable the receipt of all multicast frames by an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_allmulticast_disable(port_id: u8);
}
extern "C" {
    /**
 * Return the value of allmulticast mode for an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - (1) if allmulticast is enabled
 *   - (0) if allmulticast is disabled.
 *   - (-1) on error
 */
    pub fn rte_eth_allmulticast_get(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX
 * or FULL-DUPLEX) of the physical link of an Ethernet device. It might need
 * to wait up to 9 seconds in it.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param link
 *   A pointer to an *rte_eth_link* structure to be filled with
 *   the status, the speed and the mode of the Ethernet device link.
 */
    pub fn rte_eth_link_get(port_id: u8, link: *mut rte_eth_link);
}
extern "C" {
    /**
 * Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX
 * or FULL-DUPLEX) of the physical link of an Ethernet device. It is a no-wait
 * version of rte_eth_link_get().
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param link
 *   A pointer to an *rte_eth_link* structure to be filled with
 *   the status, the speed and the mode of the Ethernet device link.
 */
    pub fn rte_eth_link_get_nowait(port_id: u8, link: *mut rte_eth_link);
}
extern "C" {
    /**
 * Retrieve the general I/O statistics of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param stats
 *   A pointer to a structure of type *rte_eth_stats* to be filled with
 *   the values of device counters for the following set of statistics:
 *   - *ipackets* with the total of successfully received packets.
 *   - *opackets* with the total of successfully transmitted packets.
 *   - *ibytes*   with the total of successfully received bytes.
 *   - *obytes*   with the total of successfully transmitted bytes.
 *   - *ierrors*  with the total of erroneous received packets.
 *   - *oerrors*  with the total of failed transmitted packets.
 * @return
 *   Zero if successful. Non-zero otherwise.
 */
    pub fn rte_eth_stats_get(port_id: u8, stats: *mut rte_eth_stats)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Reset the general I/O statistics of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_stats_reset(port_id: u8);
}
extern "C" {
    /**
 * Retrieve names of extended statistics of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param xstats_names
 *  Block of memory to insert names into. Must be at least size in capacity.
 *  If set to NULL, function returns required capacity.
 * @param size
 *  Capacity of xstats_names (number of names).
 * @return
 *   - positive value lower or equal to size: success. The return value
 *     is the number of entries filled in the stats table.
 *   - positive value higher than size: error, the given statistics table
 *     is too small. The return value corresponds to the size that should
 *     be given to succeed. The entries in the table are not valid and
 *     shall not be used by the caller.
 *   - negative value on error (invalid port id)
 */
    pub fn rte_eth_xstats_get_names(port_id: u8,
                                    xstats_names: *mut rte_eth_xstat_name,
                                    size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve extended statistics of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param xstats
 *   A pointer to a table of structure of type *rte_eth_xstat*
 *   to be filled with device statistics ids and values.
 *   This parameter can be set to NULL if n is 0.
 * @param n
 *   The size of the stats table, which should be large enough to store
 *   all the statistics of the device.
 * @return
 *   - positive value lower or equal to n: success. The return value
 *     is the number of entries filled in the stats table.
 *   - positive value higher than n: error, the given statistics table
 *     is too small. The return value corresponds to the size that should
 *     be given to succeed. The entries in the table are not valid and
 *     shall not be used by the caller.
 *   - negative value on error (invalid port id)
 */
    pub fn rte_eth_xstats_get(port_id: u8, xstats: *mut rte_eth_xstat,
                              n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Reset extended statistics of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 */
    pub fn rte_eth_xstats_reset(port_id: u8);
}
extern "C" {
    /**
 *  Set a mapping for the specified transmit queue to the specified per-queue
 *  statistics counter.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param tx_queue_id
 *   The index of the transmit queue for which a queue stats mapping is required.
 *   The value must be in the range [0, nb_tx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @param stat_idx
 *   The per-queue packet statistics functionality number that the transmit
 *   queue is to be assigned.
 *   The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1].
 * @return
 *   Zero if successful. Non-zero otherwise.
 */
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(port_id: u8,
                                                  tx_queue_id: u16,
                                                  stat_idx: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *  Set a mapping for the specified receive queue to the specified per-queue
 *  statistics counter.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param rx_queue_id
 *   The index of the receive queue for which a queue stats mapping is required.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @param stat_idx
 *   The per-queue packet statistics functionality number that the receive
 *   queue is to be assigned.
 *   The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1].
 * @return
 *   Zero if successful. Non-zero otherwise.
 */
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(port_id: u8,
                                                  rx_queue_id: u16,
                                                  stat_idx: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve the Ethernet address of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param mac_addr
 *   A pointer to a structure of type *ether_addr* to be filled with
 *   the Ethernet address of the Ethernet device.
 */
    pub fn rte_eth_macaddr_get(port_id: u8, mac_addr: *mut ether_addr);
}
extern "C" {
    /**
 * Retrieve the contextual information of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param dev_info
 *   A pointer to a structure of type *rte_eth_dev_info* to be filled with
 *   the contextual information of the Ethernet device.
 */
    pub fn rte_eth_dev_info_get(port_id: u8, dev_info: *mut rte_eth_dev_info);
}
extern "C" {
    /**
 * Retrieve the supported packet types of an Ethernet device.
 *
 * When a packet type is announced as supported, it *must* be recognized by
 * the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN
 * and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following
 * packet types for these packets:
 * - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4
 * - Ether/Vlan/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4
 * - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER
 * - Ether/Vlan/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN
 *
 * When a packet is received by a PMD, the most precise type must be
 * returned among the ones supported. However a PMD is allowed to set
 * packet type that is not in the supported list, at the condition that it
 * is more precise. Therefore, a PMD announcing no supported packet types
 * can still set a matching packet type in a received packet.
 *
 * @note
 *   Better to invoke this API after the device is already started or rx burst
 *   function is decided, to obtain correct supported ptypes.
 * @note
 *   if a given PMD does not report what ptypes it supports, then the supported
 *   ptype count is reported as 0.
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param ptype_mask
 *   A hint of what kind of packet type which the caller is interested in.
 * @param ptypes
 *   An array pointer to store adequent packet types, allocated by caller.
 * @param num
 *  Size of the array pointed by param ptypes.
 * @return
 *   - (>=0) Number of supported ptypes. If the number of types exceeds num,
 *           only num entries will be filled into the ptypes array, but the full
 *           count of supported ptypes will be returned.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_get_supported_ptypes(port_id: u8, ptype_mask: u32,
                                            ptypes: *mut u32,
                                            num: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve the MTU of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param mtu
 *   A pointer to a uint16_t where the retrieved MTU is to be stored.
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_get_mtu(port_id: u8, mtu: *mut u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Change the MTU of an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param mtu
 *   A uint16_t for the MTU to be applied.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if operation is not supported.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if *mtu* invalid.
 *   - (-EBUSY) if operation is not allowed when the port is running
 */
    pub fn rte_eth_dev_set_mtu(port_id: u8, mtu: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Enable/Disable hardware filtering by an Ethernet device of received
 * VLAN packets tagged with a given VLAN Tag Identifier.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param vlan_id
 *   The VLAN Tag Identifier whose filtering must be enabled or disabled.
 * @param on
 *   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*.
 *   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*.
 * @return
 *   - (0) if successful.
 *   - (-ENOSUP) if hardware-assisted VLAN filtering not configured.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-ENOSYS) if VLAN filtering on *port_id* disabled.
 *   - (-EINVAL) if *vlan_id* > 4095.
 */
    pub fn rte_eth_dev_vlan_filter(port_id: u8, vlan_id: u16,
                                   on: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device.
 * 82599/X540/X550 can support VLAN stripping at the rx queue level
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param rx_queue_id
 *   The index of the receive queue for which a queue stats mapping is required.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @param on
 *   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port.
 *   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port.
 * @return
 *   - (0) if successful.
 *   - (-ENOSUP) if hardware-assisted VLAN stripping not configured.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if *rx_queue_id* invalid.
 */
    pub fn rte_eth_dev_set_vlan_strip_on_queue(port_id: u8, rx_queue_id: u16,
                                               on: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to
 * the VLAN Header. This is a register setup available on some Intel NIC, not
 * but all, please check the data sheet for availability.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param vlan_type
 *   The vlan type.
 * @param tag_type
 *   The Tag Protocol ID
 * @return
 *   - (0) if successful.
 *   - (-ENOSUP) if hardware-assisted VLAN TPID setup is not supported.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_set_vlan_ether_type(port_id: u8,
                                           vlan_type: rte_vlan_type,
                                           tag_type: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set VLAN offload configuration on an Ethernet device
 * Enable/Disable Extended VLAN by an Ethernet device, This is a register setup
 * available on some Intel NIC, not but all, please check the data sheet for
 * availability.
 * Enable/Disable VLAN Strip can be done on rx queue for certain NIC, but here
 * the configuration is applied on the port level.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param offload_mask
 *   The VLAN Offload bit mask can be mixed use with "OR"
 *       ETH_VLAN_STRIP_OFFLOAD
 *       ETH_VLAN_FILTER_OFFLOAD
 *       ETH_VLAN_EXTEND_OFFLOAD
 * @return
 *   - (0) if successful.
 *   - (-ENOSUP) if hardware-assisted VLAN filtering not configured.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_set_vlan_offload(port_id: u8,
                                        offload_mask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read VLAN Offload configuration from an Ethernet device
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - (>0) if successful. Bit mask to indicate
 *       ETH_VLAN_STRIP_OFFLOAD
 *       ETH_VLAN_FILTER_OFFLOAD
 *       ETH_VLAN_EXTEND_OFFLOAD
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_get_vlan_offload(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set port based TX VLAN insersion on or off.
 *
 * @param port_id
 *  The port identifier of the Ethernet device.
 * @param pvid
 *  Port based TX VLAN identifier togeth with user priority.
 * @param on
 *  Turn on or off the port based TX VLAN insertion.
 *
 * @return
 *   - (0) if successful.
 *   - negative if failed.
 */
    pub fn rte_eth_dev_set_vlan_pvid(port_id: u8, pvid: u16,
                                     on: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn =
    ::std::option::Option<unsafe extern "C" fn(unsent: *mut *mut rte_mbuf,
                                               count: u16,
                                               userdata:
                                                   *mut ::std::os::raw::c_void)>;
/**
 * Structure used to buffer packets for future TX
 * Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    /**< Size of buffer for buffered tx */
    pub size: u16,
    /**< Number of packets in the array */
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_tx_buffer() {
    assert_eq!(::std::mem::size_of::<rte_eth_dev_tx_buffer>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_eth_dev_tx_buffer>() , 8usize);
}
impl Clone for rte_eth_dev_tx_buffer {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Initialize default values for buffered transmitting
 *
 * @param buffer
 *   Tx buffer to be initialized.
 * @param size
 *   Buffer size
 * @return
 *   0 if no error
 */
    pub fn rte_eth_tx_buffer_init(buffer: *mut rte_eth_dev_tx_buffer,
                                  size: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Configure a callback for buffered packets which cannot be sent
 *
 * Register a specific callback to be called when an attempt is made to send
 * all packets buffered on an ethernet port, but not all packets can
 * successfully be sent. The callback registered here will be called only
 * from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs.
 * The default callback configured for each queue by default just frees the
 * packets back to the calling mempool. If additional behaviour is required,
 * for example, to count dropped packets, or to retry transmission of packets
 * which cannot be sent, this function should be used to register a suitable
 * callback function to implement the desired behaviour.
 * The example callback "rte_eth_count_unsent_packet_callback()" is also
 * provided as reference.
 *
 * @param buffer
 *   The port identifier of the Ethernet device.
 * @param callback
 *   The function to be used as the callback.
 * @param userdata
 *   Arbitrary parameter to be passed to the callback function
 * @return
 *   0 on success, or -1 on error with rte_errno set appropriately
 */
    pub fn rte_eth_tx_buffer_set_err_callback(buffer:
                                                  *mut rte_eth_dev_tx_buffer,
                                              callback: buffer_tx_error_fn,
                                              userdata:
                                                  *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Callback function for silently dropping unsent buffered packets.
 *
 * This function can be passed to rte_eth_tx_buffer_set_err_callback() to
 * adjust the default behavior when buffered packets cannot be sent. This
 * function drops any unsent packets silently and is used by tx buffered
 * operations as default behavior.
 *
 * NOTE: this function should not be called directly, instead it should be used
 *       as a callback for packet buffering.
 *
 * NOTE: when configuring this function as a callback with
 *       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter
 *       should point to an uint64_t value.
 *
 * @param pkts
 *   The previously buffered packets which could not be sent
 * @param unsent
 *   The number of unsent packets in the pkts array
 * @param userdata
 *   Not used
 */
    pub fn rte_eth_tx_buffer_drop_callback(pkts: *mut *mut rte_mbuf,
                                           unsent: u16,
                                           userdata:
                                               *mut ::std::os::raw::c_void);
}
extern "C" {
    /**
 * Callback function for tracking unsent buffered packets.
 *
 * This function can be passed to rte_eth_tx_buffer_set_err_callback() to
 * adjust the default behavior when buffered packets cannot be sent. This
 * function drops any unsent packets, but also updates a user-supplied counter
 * to track the overall number of packets dropped. The counter should be an
 * uint64_t variable.
 *
 * NOTE: this function should not be called directly, instead it should be used
 *       as a callback for packet buffering.
 *
 * NOTE: when configuring this function as a callback with
 *       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter
 *       should point to an uint64_t value.
 *
 * @param pkts
 *   The previously buffered packets which could not be sent
 * @param unsent
 *   The number of unsent packets in the pkts array
 * @param userdata
 *   Pointer to an uint64_t value, which will be incremented by unsent
 */
    pub fn rte_eth_tx_buffer_count_callback(pkts: *mut *mut rte_mbuf,
                                            unsent: u16,
                                            userdata:
                                                *mut ::std::os::raw::c_void);
}
#[repr(u32)]
/**
 * The eth device event type for interrupt, and maybe others in the future.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_eth_event_type {
    RTE_ETH_EVENT_UNKNOWN = 0,
    RTE_ETH_EVENT_INTR_LSC = 1,
    RTE_ETH_EVENT_QUEUE_STATE = 2,
    RTE_ETH_EVENT_INTR_RESET = 3,
    RTE_ETH_EVENT_VF_MBOX = 4,
    RTE_ETH_EVENT_MAX = 5,
}
pub type rte_eth_dev_cb_fn =
    ::std::option::Option<unsafe extern "C" fn(port_id: u8,
                                               event: rte_eth_event_type,
                                               cb_arg:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /**
 * Register a callback function for specific port id.
 *
 * @param port_id
 *  Port id.
 * @param event
 *  Event interested.
 * @param cb_fn
 *  User supplied callback function to be called.
 * @param cb_arg
 *  Pointer to the parameters for the registered callback.
 *
 *  The user data is overwritten in the case of RTE_ETH_EVENT_VF_MBOX.
 *	This even occurs when a message from the VF is received by the PF.
 *	The user data is overwritten with struct rte_pmd_ixgbe_mb_event_param.
 *	This struct is defined in rte_pmd_ixgbe.h.
 *
 * @return
 *  - On success, zero.
 *  - On failure, a negative value.
 */
    pub fn rte_eth_dev_callback_register(port_id: u8,
                                         event: rte_eth_event_type,
                                         cb_fn: rte_eth_dev_cb_fn,
                                         cb_arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Unregister a callback function for specific port id.
 *
 * @param port_id
 *  Port id.
 * @param event
 *  Event interested.
 * @param cb_fn
 *  User supplied callback function to be called.
 * @param cb_arg
 *  Pointer to the parameters for the registered callback. -1 means to
 *  remove all for the same callback address and same event.
 *
 * @return
 *  - On success, zero.
 *  - On failure, a negative value.
 */
    pub fn rte_eth_dev_callback_unregister(port_id: u8,
                                           event: rte_eth_event_type,
                                           cb_fn: rte_eth_dev_cb_fn,
                                           cb_arg:
                                               *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * When there is no rx packet coming in Rx Queue for a long time, we can
 * sleep lcore related to RX Queue for power saving, and enable rx interrupt
 * to be triggered when rx packect arrives.
 *
 * The rte_eth_dev_rx_intr_enable() function enables rx queue
 * interrupt on specific rx queue of a port.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The index of the receive queue from which to retrieve input packets.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if underlying hardware OR driver doesn't support
 *     that operation.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_rx_intr_enable(port_id: u8, queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * When lcore wakes up from rx interrupt indicating packet coming, disable rx
 * interrupt and returns to polling mode.
 *
 * The rte_eth_dev_rx_intr_disable() function disables rx queue
 * interrupt on specific rx queue of a port.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The index of the receive queue from which to retrieve input packets.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if underlying hardware OR driver doesn't support
 *     that operation.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_rx_intr_disable(port_id: u8, queue_id: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * RX Interrupt control per port.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param epfd
 *   Epoll instance fd which the intr vector associated to.
 *   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.
 * @param op
 *   The operation be performed for the vector.
 *   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.
 * @param data
 *   User raw data.
 * @return
 *   - On success, zero.
 *   - On failure, a negative value.
 */
    pub fn rte_eth_dev_rx_intr_ctl(port_id: u8, epfd: ::std::os::raw::c_int,
                                   op: ::std::os::raw::c_int,
                                   data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * RX Interrupt control per queue.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The index of the receive queue from which to retrieve input packets.
 *   The value must be in the range [0, nb_rx_queue - 1] previously supplied
 *   to rte_eth_dev_configure().
 * @param epfd
 *   Epoll instance fd which the intr vector associated to.
 *   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.
 * @param op
 *   The operation be performed for the vector.
 *   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.
 * @param data
 *   User raw data.
 * @return
 *   - On success, zero.
 *   - On failure, a negative value.
 */
    pub fn rte_eth_dev_rx_intr_ctl_q(port_id: u8, queue_id: u16,
                                     epfd: ::std::os::raw::c_int,
                                     op: ::std::os::raw::c_int,
                                     data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Turn on the LED on the Ethernet device.
 * This function turns on the LED on the Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if underlying hardware OR driver doesn't support
 *     that operation.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_led_on(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Turn off the LED on the Ethernet device.
 * This function turns off the LED on the Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if underlying hardware OR driver doesn't support
 *     that operation.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_led_off(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get current status of the Ethernet link flow control for Ethernet device
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param fc_conf
 *   The pointer to the structure where to store the flow control parameters.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support flow control.
 *   - (-ENODEV)  if *port_id* invalid.
 */
    pub fn rte_eth_dev_flow_ctrl_get(port_id: u8,
                                     fc_conf: *mut rte_eth_fc_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Configure the Ethernet link flow control for Ethernet device
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param fc_conf
 *   The pointer to the structure of the flow control parameters.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support flow control mode.
 *   - (-ENODEV)  if *port_id* invalid.
 *   - (-EINVAL)  if bad parameter
 *   - (-EIO)     if flow control setup failure
 */
    pub fn rte_eth_dev_flow_ctrl_set(port_id: u8,
                                     fc_conf: *mut rte_eth_fc_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Configure the Ethernet priority flow control under DCB environment
 * for Ethernet device.
 *
 * @param port_id
 * The port identifier of the Ethernet device.
 * @param pfc_conf
 * The pointer to the structure of the priority flow control parameters.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support priority flow control mode.
 *   - (-ENODEV)  if *port_id* invalid.
 *   - (-EINVAL)  if bad parameter
 *   - (-EIO)     if flow control setup failure
 */
    pub fn rte_eth_dev_priority_flow_ctrl_set(port_id: u8,
                                              pfc_conf: *mut rte_eth_pfc_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add a MAC address to an internal array of addresses used to enable whitelist
 * filtering to accept packets only if the destination MAC address matches.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param mac_addr
 *   The MAC address to add.
 * @param pool
 *   VMDq pool index to associate address with (if VMDq is enabled). If VMDq is
 *   not enabled, this should be set to 0.
 * @return
 *   - (0) if successfully added or *mac_addr" was already added.
 *   - (-ENOTSUP) if hardware doesn't support this feature.
 *   - (-ENODEV) if *port* is invalid.
 *   - (-ENOSPC) if no more MAC addresses can be added.
 *   - (-EINVAL) if MAC address is invalid.
 */
    pub fn rte_eth_dev_mac_addr_add(port: u8, mac_addr: *mut ether_addr,
                                    pool: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Remove a MAC address from the internal array of addresses.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param mac_addr
 *   MAC address to remove.
 * @return
 *   - (0) if successful, or *mac_addr* didn't exist.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENODEV) if *port* invalid.
 *   - (-EADDRINUSE) if attempting to remove the default MAC address
 */
    pub fn rte_eth_dev_mac_addr_remove(port: u8, mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the default MAC address.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param mac_addr
 *   New default MAC address.
 * @return
 *   - (0) if successful, or *mac_addr* didn't exist.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENODEV) if *port* invalid.
 *   - (-EINVAL) if MAC address is invalid.
 */
    pub fn rte_eth_dev_default_mac_addr_set(port: u8,
                                            mac_addr: *mut ether_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param reta_conf
 *   RETA to update.
 * @param reta_size
 *   Redirection table size. The table size can be queried by
 *   rte_eth_dev_info_get().
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_rss_reta_update(port: u8,
                                       reta_conf:
                                           *mut rte_eth_rss_reta_entry64,
                                       reta_size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param reta_conf
 *   RETA to query.
 * @param reta_size
 *   Redirection table size. The table size can be queried by
 *   rte_eth_dev_info_get().
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_rss_reta_query(port: u8,
                                      reta_conf:
                                          *mut rte_eth_rss_reta_entry64,
                                      reta_size: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Updates unicast hash table for receiving packet with the given destination
 * MAC address, and the packet is routed to all VFs for which the RX mode is
 * accept packets that match the unicast hash table.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param addr
 *   Unicast MAC address.
 * @param on
 *    1 - Set an unicast hash bit for receiving packets with the MAC address.
 *    0 - Clear an unicast hash bit.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
  *  - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_uc_hash_table_set(port: u8, addr: *mut ether_addr,
                                         on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Updates all unicast hash bitmaps for receiving packet with any Unicast
 * Ethernet MAC addresses,the packet is routed to all VFs for which the RX
 * mode is accept packets that match the unicast hash table.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param on
 *    1 - Set all unicast hash bitmaps for receiving all the Ethernet
 *         MAC addresses
 *    0 - Clear all unicast hash bitmaps
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
  *  - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_uc_all_hash_table_set(port: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set RX L2 Filtering mode of a VF of an Ethernet device.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param vf
 *   VF id.
 * @param rx_mode
 *    The RX mode mask, which  is one or more of  accepting Untagged Packets,
 *    packets that match the PFUTA table, Broadcast and Multicast Promiscuous.
 *    ETH_VMDQ_ACCEPT_UNTAG,ETH_VMDQ_ACCEPT_HASH_UC,
 *    ETH_VMDQ_ACCEPT_BROADCAST and ETH_VMDQ_ACCEPT_MULTICAST will be used
 *    in rx_mode.
 * @param on
 *    1 - Enable a VF RX mode.
 *    0 - Disable a VF RX mode.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_set_vf_rxmode(port: u8, vf: u16, rx_mode: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Enable or disable a VF traffic transmit of the Ethernet device.
*
* @param port
*   The port identifier of the Ethernet device.
* @param vf
*   VF id.
* @param on
*    1 - Enable a VF traffic transmit.
*    0 - Disable a VF traffic transmit.
* @return
*   - (0) if successful.
*   - (-ENODEV) if *port_id* invalid.
*   - (-ENOTSUP) if hardware doesn't support.
*   - (-EINVAL) if bad parameter.
*/
    pub fn rte_eth_dev_set_vf_tx(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Enable or disable a VF traffic receive of an Ethernet device.
*
* @param port
*   The port identifier of the Ethernet device.
* @param vf
*   VF id.
* @param on
*    1 - Enable a VF traffic receive.
*    0 - Disable a VF traffic receive.
* @return
*   - (0) if successful.
*   - (-ENOTSUP) if hardware doesn't support.
*   - (-ENODEV) if *port_id* invalid.
*   - (-EINVAL) if bad parameter.
*/
    pub fn rte_eth_dev_set_vf_rx(port: u8, vf: u16, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Enable/Disable hardware VF VLAN filtering by an Ethernet device of
* received VLAN packets tagged with a given VLAN Tag Identifier.
*
* @param port id
*   The port identifier of the Ethernet device.
* @param vlan_id
*   The VLAN Tag Identifier whose filtering must be enabled or disabled.
* @param vf_mask
*    Bitmap listing which VFs participate in the VLAN filtering.
* @param vlan_on
*    1 - Enable VFs VLAN filtering.
*    0 - Disable VFs VLAN filtering.
* @return
*   - (0) if successful.
*   - (-ENOTSUP) if hardware doesn't support.
*   - (-ENODEV) if *port_id* invalid.
*   - (-EINVAL) if bad parameter.
*/
    pub fn rte_eth_dev_set_vf_vlan_filter(port: u8, vlan_id: u16,
                                          vf_mask: u64, vlan_on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set a traffic mirroring rule on an Ethernet device
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param mirror_conf
 *   The pointer to the traffic mirroring structure describing the mirroring rule.
 *   The *rte_eth_vm_mirror_conf* structure includes the type of mirroring rule,
 *   destination pool and the value of rule if enable vlan or pool mirroring.
 *
 * @param rule_id
 *   The index of traffic mirroring rule, we support four separated rules.
 * @param on
 *   1 - Enable a mirroring rule.
 *   0 - Disable a mirroring rule.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support this feature.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if the mr_conf information is not correct.
 */
    pub fn rte_eth_mirror_rule_set(port_id: u8,
                                   mirror_conf: *mut rte_eth_mirror_conf,
                                   rule_id: u8, on: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Reset a traffic mirroring rule on an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param rule_id
 *   The index of traffic mirroring rule, we support four separated rules.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support this feature.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_mirror_rule_reset(port_id: u8, rule_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the rate limitation for a queue on an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_idx
 *   The queue id.
 * @param tx_rate
 *   The tx rate in Mbps. Allocated from the total port link speed.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support this feature.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_set_queue_rate_limit(port_id: u8, queue_idx: u16,
                                        tx_rate: u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the rate limitation for a vf on an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param vf
 *   VF id.
 * @param tx_rate
 *   The tx rate allocated from the total link speed for this VF id.
 * @param q_msk
 *   The queue mask which need to set the rate.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support this feature.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_set_vf_rate_limit(port_id: u8, vf: u16, tx_rate: u16,
                                     q_msk: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Initialize bypass logic. This function needs to be called before
 * executing any other bypass API.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_init(port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Return bypass state.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param state
 *   The return bypass state.
 *   - (1) Normal mode
 *   - (2) Bypass mode
 *   - (3) Isolate mode
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_state_show(port: u8, state: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set bypass state
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param new_state
 *   The current bypass state.
 *   - (1) Normal mode
 *   - (2) Bypass mode
 *   - (3) Isolate mode
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_state_set(port: u8, new_state: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Return bypass state when given event occurs.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param event
 *   The bypass event
 *   - (1) Main power on (power button is pushed)
 *   - (2) Auxiliary power on (power supply is being plugged)
 *   - (3) Main power off (system shutdown and power supply is left plugged in)
 *   - (4) Auxiliary power off (power supply is being unplugged)
 *   - (5) Display or set the watchdog timer
 * @param state
 *   The bypass state when given event occurred.
 *   - (1) Normal mode
 *   - (2) Bypass mode
 *   - (3) Isolate mode
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_event_show(port: u8, event: u32,
                                         state: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set bypass state when given event occurs.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param event
 *   The bypass event
 *   - (1) Main power on (power button is pushed)
 *   - (2) Auxiliary power on (power supply is being plugged)
 *   - (3) Main power off (system shutdown and power supply is left plugged in)
 *   - (4) Auxiliary power off (power supply is being unplugged)
 *   - (5) Display or set the watchdog timer
 * @param state
 *   The assigned state when given event occurs.
 *   - (1) Normal mode
 *   - (2) Bypass mode
 *   - (3) Isolate mode
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_event_store(port: u8, event: u32, state: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set bypass watchdog timeout count.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param timeout
 *   The timeout to be set.
 *   - (0) 0 seconds (timer is off)
 *   - (1) 1.5 seconds
 *   - (2) 2 seconds
 *   - (3) 3 seconds
 *   - (4) 4 seconds
 *   - (5) 8 seconds
 *   - (6) 16 seconds
 *   - (7) 32 seconds
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_wd_timeout_store(port: u8, timeout: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get bypass firmware version.
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param ver
 *   The firmware version
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_ver_show(port: u8, ver: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Return bypass watchdog timeout in seconds
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @param wd_timeout
 *   The return watchdog timeout. "0" represents timer expired
 *   - (0) 0 seconds (timer is off)
 *   - (1) 1.5 seconds
 *   - (2) 2 seconds
 *   - (3) 3 seconds
 *   - (4) 4 seconds
 *   - (5) 8 seconds
 *   - (6) 16 seconds
 *   - (7) 32 seconds
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_wd_timeout_show(port: u8, wd_timeout: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Reset bypass watchdog timer
 *
 * @param port
 *   The port identifier of the Ethernet device.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_bypass_wd_reset(port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Configuration of Receive Side Scaling hash computation of Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param rss_conf
 *   The new configuration to use for RSS hash computation on the port.
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if port identifier is invalid.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-EINVAL) if bad parameter.
 */
    pub fn rte_eth_dev_rss_hash_update(port_id: u8,
                                       rss_conf: *mut rte_eth_rss_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve current configuration of Receive Side Scaling hash computation
 * of Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param rss_conf
 *   Where to store the current RSS hash configuration of the Ethernet device.
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if port identifier is invalid.
 *   - (-ENOTSUP) if hardware doesn't support RSS.
 */
    pub fn rte_eth_dev_rss_hash_conf_get(port_id: u8,
                                         rss_conf: *mut rte_eth_rss_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add UDP tunneling port for a specific type of tunnel.
 * The packets with this UDP port will be identified as this type of tunnel.
 * Before enabling any offloading function for a tunnel, users can call this API
 * to change or add more UDP port for the tunnel. So the offloading function
 * can take effect on the packets with the sepcific UDP port.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param tunnel_udp
 *   UDP tunneling configuration.
 *
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if port identifier is invalid.
 *   - (-ENOTSUP) if hardware doesn't support tunnel type.
 */
    pub fn rte_eth_dev_udp_tunnel_port_add(port_id: u8,
                                           tunnel_udp:
                                               *mut rte_eth_udp_tunnel)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete UDP tunneling port a specific type of tunnel.
 * The packets with this UDP port will not be identified as this type of tunnel
 * any more.
 * Before enabling any offloading function for a tunnel, users can call this API
 * to delete a UDP port for the tunnel. So the offloading function will not take
 * effect on the packets with the sepcific UDP port.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param tunnel_udp
 *   UDP tunneling configuration.
 *
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if port identifier is invalid.
 *   - (-ENOTSUP) if hardware doesn't support tunnel type.
 */
    pub fn rte_eth_dev_udp_tunnel_port_delete(port_id: u8,
                                              tunnel_udp:
                                                  *mut rte_eth_udp_tunnel)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Check whether the filter type is supported on an Ethernet device.
 * All the supported filter types are defined in 'rte_eth_ctrl.h'.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param filter_type
 *   Filter type.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support this filter type.
 *   - (-ENODEV) if *port_id* invalid.
 */
    pub fn rte_eth_dev_filter_supported(port_id: u8,
                                        filter_type: rte_filter_type)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Take operations to assigned filter type on an Ethernet device.
 * All the supported operations and filter types are defined in 'rte_eth_ctrl.h'.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param filter_type
 *   Filter type.
 * @param filter_op
 *   Type of operation.
 * @param arg
 *   A pointer to arguments defined specifically for the operation.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENODEV) if *port_id* invalid.
 *   - others depends on the specific operations implementation.
 */
    pub fn rte_eth_dev_filter_ctrl(port_id: u8, filter_type: rte_filter_type,
                                   filter_op: rte_filter_op,
                                   arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Get DCB information on an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param dcb_info
 *   dcb information.
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if port identifier is invalid.
 *   - (-ENOTSUP) if hardware doesn't support.
 */
    pub fn rte_eth_dev_get_dcb_info(port_id: u8,
                                    dcb_info: *mut rte_eth_dcb_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add a callback to be called on packet RX on a given port and queue.
 *
 * This API configures a function to be called for each burst of
 * packets received on a given NIC port queue. The return value is a pointer
 * that can be used to later remove the callback using
 * rte_eth_remove_rx_callback().
 *
 * Multiple functions are called in the order that they are added.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The queue on the Ethernet device on which the callback is to be added.
 * @param fn
 *   The callback function
 * @param user_param
 *   A generic pointer parameter which will be passed to each invocation of the
 *   callback function on this port and queue.
 *
 * @return
 *   NULL on error.
 *   On success, a pointer value which can later be used to remove the callback.
 */
    pub fn rte_eth_add_rx_callback(port_id: u8, queue_id: u16,
                                   fn_: rte_rx_callback_fn,
                                   user_param: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_eth_add_first_rx_callback(port_id: u8, queue_id: u16,
                                         fn_: rte_rx_callback_fn,
                                         user_param:
                                             *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Add a callback to be called on packet TX on a given port and queue.
 *
 * This API configures a function to be called for each burst of
 * packets sent on a given NIC port queue. The return value is a pointer
 * that can be used to later remove the callback using
 * rte_eth_remove_tx_callback().
 *
 * Multiple functions are called in the order that they are added.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The queue on the Ethernet device on which the callback is to be added.
 * @param fn
 *   The callback function
 * @param user_param
 *   A generic pointer parameter which will be passed to each invocation of the
 *   callback function on this port and queue.
 *
 * @return
 *   NULL on error.
 *   On success, a pointer value which can later be used to remove the callback.
 */
    pub fn rte_eth_add_tx_callback(port_id: u8, queue_id: u16,
                                   fn_: rte_tx_callback_fn,
                                   user_param: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * Remove an RX packet callback from a given port and queue.
 *
 * This function is used to removed callbacks that were added to a NIC port
 * queue using rte_eth_add_rx_callback().
 *
 * Note: the callback is removed from the callback list but it isn't freed
 * since the it may still be in use. The memory for the callback can be
 * subsequently freed back by the application by calling rte_free():
 *
 * - Immediately - if the port is stopped, or the user knows that no
 *   callbacks are in flight e.g. if called from the thread doing RX/TX
 *   on that queue.
 *
 * - After a short delay - where the delay is sufficient to allow any
 *   in-flight callbacks to complete.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The queue on the Ethernet device from which the callback is to be removed.
 * @param user_cb
 *   User supplied callback created via rte_eth_add_rx_callback().
 *
 * @return
 *   - 0: Success. Callback was removed.
 *   - -ENOTSUP: Callback support is not available.
 *   - -EINVAL:  The port_id or the queue_id is out of range, or the callback
 *               is NULL or not found for the port/queue.
 */
    pub fn rte_eth_remove_rx_callback(port_id: u8, queue_id: u16,
                                      user_cb: *mut rte_eth_rxtx_callback)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Remove a TX packet callback from a given port and queue.
 *
 * This function is used to removed callbacks that were added to a NIC port
 * queue using rte_eth_add_tx_callback().
 *
 * Note: the callback is removed from the callback list but it isn't freed
 * since the it may still be in use. The memory for the callback can be
 * subsequently freed back by the application by calling rte_free():
 *
 * - Immediately - if the port is stopped, or the user knows that no
 *   callbacks are in flight e.g. if called from the thread doing RX/TX
 *   on that queue.
 *
 * - After a short delay - where the delay is sufficient to allow any
 *   in-flight callbacks to complete.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The queue on the Ethernet device from which the callback is to be removed.
 * @param user_cb
 *   User supplied callback created via rte_eth_add_tx_callback().
 *
 * @return
 *   - 0: Success. Callback was removed.
 *   - -ENOTSUP: Callback support is not available.
 *   - -EINVAL:  The port_id or the queue_id is out of range, or the callback
 *               is NULL or not found for the port/queue.
 */
    pub fn rte_eth_remove_tx_callback(port_id: u8, queue_id: u16,
                                      user_cb: *mut rte_eth_rxtx_callback)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve information about given port's RX queue.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The RX queue on the Ethernet device for which information
 *   will be retrieved.
 * @param qinfo
 *   A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with
 *   the information of the Ethernet device.
 *
 * @return
 *   - 0: Success
 *   - -ENOTSUP: routine is not supported by the device PMD.
 *   - -EINVAL:  The port_id or the queue_id is out of range.
 */
    pub fn rte_eth_rx_queue_info_get(port_id: u8, queue_id: u16,
                                     qinfo: *mut rte_eth_rxq_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve information about given port's TX queue.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param queue_id
 *   The TX queue on the Ethernet device for which information
 *   will be retrieved.
 * @param qinfo
 *   A pointer to a structure of type *rte_eth_txq_info_info* to be filled with
 *   the information of the Ethernet device.
 *
 * @return
 *   - 0: Success
 *   - -ENOTSUP: routine is not supported by the device PMD.
 *   - -EINVAL:  The port_id or the queue_id is out of range.
 */
    pub fn rte_eth_tx_queue_info_get(port_id: u8, queue_id: u16,
                                     qinfo: *mut rte_eth_txq_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve device registers and register attributes (number of registers and
 * register size)
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param info
 *   Pointer to rte_dev_reg_info structure to fill in. If info->data is
 *   NULL the function fills in the width and length fields. If non-NULL
 *   the registers are put into the buffer pointed at by the data field.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENODEV) if *port_id* invalid.
 *   - others depends on the specific operations implementation.
 */
    pub fn rte_eth_dev_get_reg_info(port_id: u8, info: *mut rte_dev_reg_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve size of device EEPROM
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @return
 *   - (>=0) EEPROM size if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENODEV) if *port_id* invalid.
 *   - others depends on the specific operations implementation.
 */
    pub fn rte_eth_dev_get_eeprom_length(port_id: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve EEPROM and EEPROM attribute
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param info
 *   The template includes buffer for return EEPROM data and
 *   EEPROM attributes to be filled.
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENODEV) if *port_id* invalid.
 *   - others depends on the specific operations implementation.
 */
    pub fn rte_eth_dev_get_eeprom(port_id: u8, info: *mut rte_dev_eeprom_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Program EEPROM with provided data
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param info
 *   The template includes EEPROM data for programming and
 *   EEPROM attributes to be filled
 * @return
 *   - (0) if successful.
 *   - (-ENOTSUP) if hardware doesn't support.
 *   - (-ENODEV) if *port_id* invalid.
 *   - others depends on the specific operations implementation.
 */
    pub fn rte_eth_dev_set_eeprom(port_id: u8, info: *mut rte_dev_eeprom_info)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the list of multicast addresses to filter on an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param mc_addr_set
 *   The array of multicast addresses to set. Equal to NULL when the function
 *   is invoked to flush the set of filtered addresses.
 * @param nb_mc_addr
 *   The number of multicast addresses in the *mc_addr_set* array. Equal to 0
 *   when the function is invoked to flush the set of filtered addresses.
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if *port_id* invalid.
 *   - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering.
 *   - (-ENOSPC) if *port_id* has not enough multicast filtering resources.
 */
    pub fn rte_eth_dev_set_mc_addr_list(port_id: u8,
                                        mc_addr_set: *mut ether_addr,
                                        nb_mc_addr: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Enable IEEE1588/802.1AS timestamping for an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 *
 * @return
 *   - 0: Success.
 *   - -ENODEV: The port ID is invalid.
 *   - -ENOTSUP: The function is not supported by the Ethernet driver.
 */
    pub fn rte_eth_timesync_enable(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Disable IEEE1588/802.1AS timestamping for an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 *
 * @return
 *   - 0: Success.
 *   - -ENODEV: The port ID is invalid.
 *   - -ENOTSUP: The function is not supported by the Ethernet driver.
 */
    pub fn rte_eth_timesync_disable(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read an IEEE1588/802.1AS RX timestamp from an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param timestamp
 *   Pointer to the timestamp struct.
 * @param flags
 *   Device specific flags. Used to pass the RX timesync register index to
 *   i40e. Unused in igb/ixgbe, pass 0 instead.
 *
 * @return
 *   - 0: Success.
 *   - -EINVAL: No timestamp is available.
 *   - -ENODEV: The port ID is invalid.
 *   - -ENOTSUP: The function is not supported by the Ethernet driver.
 */
    pub fn rte_eth_timesync_read_rx_timestamp(port_id: u8,
                                              timestamp: *mut timespec,
                                              flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read an IEEE1588/802.1AS TX timestamp from an Ethernet device.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param timestamp
 *   Pointer to the timestamp struct.
 *
 * @return
 *   - 0: Success.
 *   - -EINVAL: No timestamp is available.
 *   - -ENODEV: The port ID is invalid.
 *   - -ENOTSUP: The function is not supported by the Ethernet driver.
 */
    pub fn rte_eth_timesync_read_tx_timestamp(port_id: u8,
                                              timestamp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Adjust the timesync clock on an Ethernet device.
 *
 * This is usually used in conjunction with other Ethdev timesync functions to
 * synchronize the device time using the IEEE1588/802.1AS protocol.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param delta
 *   The adjustment in nanoseconds.
 *
 * @return
 *   - 0: Success.
 *   - -ENODEV: The port ID is invalid.
 *   - -ENOTSUP: The function is not supported by the Ethernet driver.
 */
    pub fn rte_eth_timesync_adjust_time(port_id: u8, delta: i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read the time from the timesync clock on an Ethernet device.
 *
 * This is usually used in conjunction with other Ethdev timesync functions to
 * synchronize the device time using the IEEE1588/802.1AS protocol.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param time
 *   Pointer to the timespec struct that holds the time.
 *
 * @return
 *   - 0: Success.
 */
    pub fn rte_eth_timesync_read_time(port_id: u8, time: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Set the time of the timesync clock on an Ethernet device.
 *
 * This is usually used in conjunction with other Ethdev timesync functions to
 * synchronize the device time using the IEEE1588/802.1AS protocol.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param time
 *   Pointer to the timespec struct that holds the time.
 *
 * @return
 *   - 0: Success.
 *   - -EINVAL: No timestamp is available.
 *   - -ENODEV: The port ID is invalid.
 *   - -ENOTSUP: The function is not supported by the Ethernet driver.
 */
    pub fn rte_eth_timesync_write_time(port_id: u8, time: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Copy pci device info to the Ethernet device data.
 *
 * @param eth_dev
 * The *eth_dev* pointer is the address of the *rte_eth_dev* structure.
 * @param pci_dev
 * The *pci_dev* pointer is the address of the *rte_pci_device* structure.
 *
 * @return
 *   - 0 on success, negative on error
 */
    pub fn rte_eth_copy_pci_info(eth_dev: *mut rte_eth_dev,
                                 pci_dev:
                                     *mut pci_device_list_rte_pci_device);
}
extern "C" {
    /**
 * Create memzone for HW rings.
 * malloc can't be used as the physical address is needed.
 * If the memzone is already created, then this function returns a ptr
 * to the old one.
 *
 * @param eth_dev
 *   The *eth_dev* pointer is the address of the *rte_eth_dev* structure
 * @param name
 *   The name of the memory zone
 * @param queue_id
 *   The index of the queue to add to name
 * @param size
 *   The sizeof of the memory area
 * @param align
 *   Alignment for resulting memzone. Must be a power of 2.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in case of NUMA.
 */
    pub fn rte_eth_dma_zone_reserve(eth_dev: *const rte_eth_dev,
                                    name: *const ::std::os::raw::c_char,
                                    queue_id: u16, size: usize,
                                    align: ::std::os::raw::c_uint,
                                    socket_id: ::std::os::raw::c_int)
     -> *const rte_memzone;
}
extern "C" {
    /**
 * Config l2 tunnel ether type of an Ethernet device for filtering specific
 * tunnel packets by ether type.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param l2_tunnel
 *   l2 tunnel configuration.
 *
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if port identifier is invalid.
 *   - (-ENOTSUP) if hardware doesn't support tunnel type.
 */
    pub fn rte_eth_dev_l2_tunnel_eth_type_conf(port_id: u8,
                                               l2_tunnel:
                                                   *mut rte_eth_l2_tunnel_conf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Enable/disable l2 tunnel offload functions. Include,
 * 1, The ability of parsing a type of l2 tunnel of an Ethernet device.
 *    Filtering, forwarding and offloading this type of tunnel packets depend on
 *    this ability.
 * 2, Stripping the l2 tunnel tag.
 * 3, Insertion of the l2 tunnel tag.
 * 4, Forwarding the packets based on the l2 tunnel tag.
 *
 * @param port_id
 *   The port identifier of the Ethernet device.
 * @param l2_tunnel
 *   l2 tunnel parameters.
 * @param mask
 *   Indicate the offload function.
 * @param en
 *   Enable or disable this function.
 *
 * @return
 *   - (0) if successful.
 *   - (-ENODEV) if port identifier is invalid.
 *   - (-ENOTSUP) if hardware doesn't support tunnel type.
 */
    pub fn rte_eth_dev_l2_tunnel_offload_set(port_id: u8,
                                             l2_tunnel:
                                                 *mut rte_eth_l2_tunnel_conf,
                                             mask: u32, en: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Get the port id from pci adrress or device name
* Ex: 0000:2:00.0 or vdev name net_pcap0
*
* @param name
*  pci address or name of the device
* @param port_id
*   pointer to port identifier of the device
* @return
*   - (0) if successful.
*   - (-ENODEV or -EINVAL) on failure.
*/
    pub fn rte_eth_dev_get_port_by_name(name: *const ::std::os::raw::c_char,
                                        port_id: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* Get the device name from port id
*
* @param port_id
*   pointer to port identifier of the device
* @param name
*  pci address or name of the device
* @return
*   - (0) if successful.
*   - (-EINVAL) on failure.
*/
    pub fn rte_eth_dev_get_name_by_port(port_id: u8,
                                        name: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @internal
 * Wrapper for use by pci drivers as a .probe function to attach to a ethdev
 * interface.
 */
    pub fn rte_eth_dev_pci_probe(pci_drv: *mut pci_driver_list_rte_pci_driver,
                                 pci_dev: *mut pci_device_list_rte_pci_device)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @internal
 * Wrapper for use by pci drivers as a .remove function to detach a ethdev
 * interface.
 */
    pub fn rte_eth_dev_pci_remove(pci_dev:
                                      *mut pci_device_list_rte_pci_device)
     -> ::std::os::raw::c_int;
}
/** Signature of key that is stored internally. */
pub type hash_sig_t = u32;
/** Type of function that can be used for calculating the hash value. */
pub type rte_hash_function =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void,
                                               key_len: u32, init_val: u32)
                              -> ::std::os::raw::c_uint>;
/** Type of function used to compare the hash key. */
pub type rte_hash_cmp_eq_t =
    ::std::option::Option<unsafe extern "C" fn(key1:
                                                   *const ::std::os::raw::c_void,
                                               key2:
                                                   *const ::std::os::raw::c_void,
                                               key_len: usize)
                              -> ::std::os::raw::c_int>;
/**
 * Parameters used when creating the hash table.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_hash_parameters {
    /**< Name of the hash. */
    pub name: *const ::std::os::raw::c_char,
    /**< Total hash table entries. */
    pub entries: u32,
    /**< Unused field. Should be set to 0 */
    pub reserved: u32,
    /**< Length of hash key. */
    pub key_len: u32,
    /**< Primary Hash function used to calculate hash. */
    pub hash_func: rte_hash_function,
    /**< Init value used by hash_func. */
    pub hash_func_init_val: u32,
    /**< NUMA Socket ID for memory. */
    pub socket_id: ::std::os::raw::c_int,
    /**< Indicate if additional parameters are present. */
    pub extra_flag: u8,
}
#[test]
fn bindgen_test_layout_rte_hash_parameters() {
    assert_eq!(::std::mem::size_of::<rte_hash_parameters>() , 48usize);
    assert_eq! (::std::mem::align_of::<rte_hash_parameters>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . name as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . entries as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . reserved as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . key_len as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . hash_func as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) .
                hash_func_init_val as * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . socket_id as *
                const _ as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_hash_parameters ) ) . extra_flag as *
                const _ as usize } , 40usize);
}
impl Clone for rte_hash_parameters {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_hash([u8; 0]);
extern "C" {
    /**
 * Create a new hash table.
 *
 * @param params
 *   Parameters used to create and initialise the hash table.
 * @return
 *   Pointer to hash table structure that is used in future hash table
 *   operations, or NULL on error, with error code set in rte_errno.
 *   Possible rte_errno errors include:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - ENOENT - missing entry
 *    - EINVAL - invalid parameter passed to function
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */
    pub fn rte_hash_create(params: *const rte_hash_parameters)
     -> *mut rte_hash;
}
extern "C" {
    /**
 * Set a new hash compare function other than the default one.
 *
 * @note Function pointer does not work with multi-process, so do not use it
 * in multi-process mode.
 *
 * @param h
 *   Hash table for which the function is to be changed
 * @param func
 *   New compare function
 */
    pub fn rte_hash_set_cmp_func(h: *mut rte_hash, func: rte_hash_cmp_eq_t);
}
extern "C" {
    /**
 * Find an existing hash table object and return a pointer to it.
 *
 * @param name
 *   Name of the hash table as passed to rte_hash_create()
 * @return
 *   Pointer to hash table or NULL if object not found
 *   with rte_errno set appropriately. Possible rte_errno values include:
 *    - ENOENT - value not available for return
 */
    pub fn rte_hash_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_hash;
}
extern "C" {
    /**
 * De-allocate all memory used by hash table.
 * @param h
 *   Hash table to free
 */
    pub fn rte_hash_free(h: *mut rte_hash);
}
extern "C" {
    /**
 * Reset all hash structure, by zeroing all entries
 * @param h
 *   Hash table to reset
 */
    pub fn rte_hash_reset(h: *mut rte_hash);
}
extern "C" {
    /**
 * Add a key-value pair to an existing hash table.
 * This operation is not multi-thread safe
 * and should only be called from one thread.
 *
 * @param h
 *   Hash table to add the key to.
 * @param key
 *   Key to add to the hash table.
 * @param data
 *   Data to add to the hash table.
 * @return
 *   - 0 if added successfully
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOSPC if there is no space in the hash for this key.
 */
    pub fn rte_hash_add_key_data(h: *const rte_hash,
                                 key: *const ::std::os::raw::c_void,
                                 data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Add a key-value pair with a pre-computed hash value
 * to an existing hash table.
 * This operation is not multi-thread safe
 * and should only be called from one thread.
 *
 * @param h
 *   Hash table to add the key to.
 * @param key
 *   Key to add to the hash table.
 * @param sig
 *   Precomputed hash value for 'key'
 * @param data
 *   Data to add to the hash table.
 * @return
 *   - 0 if added successfully
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOSPC if there is no space in the hash for this key.
 */
    pub fn rte_hash_add_key_with_hash_data(h: *const rte_hash,
                                           key: *const ::std::os::raw::c_void,
                                           sig: hash_sig_t,
                                           data: *mut ::std::os::raw::c_void)
     -> i32;
}
extern "C" {
    /**
 * Add a key to an existing hash table. This operation is not multi-thread safe
 * and should only be called from one thread.
 *
 * @param h
 *   Hash table to add the key to.
 * @param key
 *   Key to add to the hash table.
 * @return
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOSPC if there is no space in the hash for this key.
 *   - A positive value that can be used by the caller as an offset into an
 *     array of user data. This value is unique for this key.
 */
    pub fn rte_hash_add_key(h: *const rte_hash,
                            key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    /**
 * Add a key to an existing hash table.
 * This operation is not multi-thread safe
 * and should only be called from one thread.
 *
 * @param h
 *   Hash table to add the key to.
 * @param key
 *   Key to add to the hash table.
 * @param sig
 *   Precomputed hash value for 'key'.
 * @return
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOSPC if there is no space in the hash for this key.
 *   - A positive value that can be used by the caller as an offset into an
 *     array of user data. This value is unique for this key.
 */
    pub fn rte_hash_add_key_with_hash(h: *const rte_hash,
                                      key: *const ::std::os::raw::c_void,
                                      sig: hash_sig_t) -> i32;
}
extern "C" {
    /**
 * Remove a key from an existing hash table.
 * This operation is not multi-thread safe
 * and should only be called from one thread.
 *
 * @param h
 *   Hash table to remove the key from.
 * @param key
 *   Key to remove from the hash table.
 * @return
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOENT if the key is not found.
 *   - A positive value that can be used by the caller as an offset into an
 *     array of user data. This value is unique for this key, and is the same
 *     value that was returned when the key was added.
 */
    pub fn rte_hash_del_key(h: *const rte_hash,
                            key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    /**
 * Remove a key from an existing hash table.
 * This operation is not multi-thread safe
 * and should only be called from one thread.
 *
 * @param h
 *   Hash table to remove the key from.
 * @param key
 *   Key to remove from the hash table.
 * @param sig
 *   Precomputed hash value for 'key'.
 * @return
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOENT if the key is not found.
 *   - A positive value that can be used by the caller as an offset into an
 *     array of user data. This value is unique for this key, and is the same
 *     value that was returned when the key was added.
 */
    pub fn rte_hash_del_key_with_hash(h: *const rte_hash,
                                      key: *const ::std::os::raw::c_void,
                                      sig: hash_sig_t) -> i32;
}
extern "C" {
    /**
 * Find a key in the hash table given the position.
 * This operation is multi-thread safe.
 *
 * @param h
 *   Hash table to get the key from.
 * @param position
 *   Position returned when the key was inserted.
 * @param key
 *   Output containing a pointer to the key
 * @return
 *   - 0 if retrieved successfully
 *   - EINVAL if the parameters are invalid.
 *   - ENOENT if no valid key is found in the given position.
 */
    pub fn rte_hash_get_key_with_position(h: *const rte_hash, position: i32,
                                          key:
                                              *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Find a key-value pair in the hash table.
 * This operation is multi-thread safe.
 *
 * @param h
 *   Hash table to look in.
 * @param key
 *   Key to find.
 * @param data
 *   Output with pointer to data returned from the hash table.
 * @return
 *   0 if successful lookup
 *   - EINVAL if the parameters are invalid.
 *   - ENOENT if the key is not found.
 */
    pub fn rte_hash_lookup_data(h: *const rte_hash,
                                key: *const ::std::os::raw::c_void,
                                data: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Find a key-value pair with a pre-computed hash value
 * to an existing hash table.
 * This operation is multi-thread safe.
 *
 * @param h
 *   Hash table to look in.
 * @param key
 *   Key to find.
 * @param sig
 *   Precomputed hash value for 'key'
 * @param data
 *   Output with pointer to data returned from the hash table.
 * @return
 *   0 if successful lookup
 *   - EINVAL if the parameters are invalid.
 *   - ENOENT if the key is not found.
 */
    pub fn rte_hash_lookup_with_hash_data(h: *const rte_hash,
                                          key: *const ::std::os::raw::c_void,
                                          sig: hash_sig_t,
                                          data:
                                              *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Find a key in the hash table.
 * This operation is multi-thread safe.
 *
 * @param h
 *   Hash table to look in.
 * @param key
 *   Key to find.
 * @return
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOENT if the key is not found.
 *   - A positive value that can be used by the caller as an offset into an
 *     array of user data. This value is unique for this key, and is the same
 *     value that was returned when the key was added.
 */
    pub fn rte_hash_lookup(h: *const rte_hash,
                           key: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    /**
 * Find a key in the hash table.
 * This operation is multi-thread safe.
 *
 * @param h
 *   Hash table to look in.
 * @param key
 *   Key to find.
 * @param sig
 *   Hash value to remove from the hash table.
 * @return
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOENT if the key is not found.
 *   - A positive value that can be used by the caller as an offset into an
 *     array of user data. This value is unique for this key, and is the same
 *     value that was returned when the key was added.
 */
    pub fn rte_hash_lookup_with_hash(h: *const rte_hash,
                                     key: *const ::std::os::raw::c_void,
                                     sig: hash_sig_t) -> i32;
}
extern "C" {
    /**
 * Calc a hash value by key.
 * This operation is not multi-thread safe.
 *
 * @param h
 *   Hash table to look in.
 * @param key
 *   Key to find.
 * @return
 *   - hash value
 */
    pub fn rte_hash_hash(h: *const rte_hash,
                         key: *const ::std::os::raw::c_void) -> hash_sig_t;
}
extern "C" {
    /**
 * Find multiple keys in the hash table.
 * This operation is multi-thread safe.
 *
 * @param h
 *   Hash table to look in.
 * @param keys
 *   A pointer to a list of keys to look for.
 * @param num_keys
 *   How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
 * @param hit_mask
 *   Output containing a bitmask with all successful lookups.
 * @param data
 *   Output containing array of data returned from all the successful lookups.
 * @return
 *   -EINVAL if there's an error, otherwise number of successful lookups.
 */
    pub fn rte_hash_lookup_bulk_data(h: *const rte_hash,
                                     keys: *mut *const ::std::os::raw::c_void,
                                     num_keys: u32, hit_mask: *mut u64,
                                     data: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Find multiple keys in the hash table.
 * This operation is multi-thread safe.
 *
 * @param h
 *   Hash table to look in.
 * @param keys
 *   A pointer to a list of keys to look for.
 * @param num_keys
 *   How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX).
 * @param positions
 *   Output containing a list of values, corresponding to the list of keys that
 *   can be used by the caller as an offset into an array of user data. These
 *   values are unique for each key, and are the same values that were returned
 *   when each key was added. If a key in the list was not found, then -ENOENT
 *   will be the value.
 * @return
 *   -EINVAL if there's an error, otherwise 0.
 */
    pub fn rte_hash_lookup_bulk(h: *const rte_hash,
                                keys: *mut *const ::std::os::raw::c_void,
                                num_keys: u32, positions: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Iterate through the hash table, returning key-value pairs.
 *
 * @param h
 *   Hash table to iterate
 * @param key
 *   Output containing the key where current iterator
 *   was pointing at
 * @param data
 *   Output containing the data associated with key.
 *   Returns NULL if data was not stored.
 * @param next
 *   Pointer to iterator. Should be 0 to start iterating the hash table.
 *   Iterator is incremented after each call of this function.
 * @return
 *   Position where key was stored, if successful.
 *   - -EINVAL if the parameters are invalid.
 *   - -ENOENT if end of the hash table.
 */
    pub fn rte_hash_iterate(h: *const rte_hash,
                            key: *mut *const ::std::os::raw::c_void,
                            data: *mut *mut ::std::os::raw::c_void,
                            next: *mut u32) -> i32;
}
/**
 * IPv4 Header
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ipv4_hdr {
    /**< version and header length */
    pub version_ihl: u8,
    /**< type of service */
    pub type_of_service: u8,
    /**< length of packet */
    pub total_length: u16,
    /**< packet ID */
    pub packet_id: u16,
    /**< fragmentation offset */
    pub fragment_offset: u16,
    /**< time to live */
    pub time_to_live: u8,
    /**< protocol ID */
    pub next_proto_id: u8,
    /**< header checksum */
    pub hdr_checksum: u16,
    /**< source address */
    pub src_addr: u32,
    /**< destination address */
    pub dst_addr: u32,
}
#[test]
fn bindgen_test_layout_ipv4_hdr() {
    assert_eq!(::std::mem::size_of::<ipv4_hdr>() , 20usize);
    assert_eq! (::std::mem::align_of::<ipv4_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . version_ihl as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . type_of_service as * const
                _ as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . total_length as * const _
                as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . packet_id as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . fragment_offset as * const
                _ as usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . time_to_live as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . next_proto_id as * const _
                as usize } , 9usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . hdr_checksum as * const _
                as usize } , 10usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . src_addr as * const _ as
                usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv4_hdr ) ) . dst_addr as * const _ as
                usize } , 16usize);
}
impl Clone for ipv4_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * IPv6 Header
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ipv6_hdr {
    /**< IP version, traffic class & flow label. */
    pub vtc_flow: u32,
    /**< IP packet length - includes sizeof(ip_header). */
    pub payload_len: u16,
    /**< Protocol, next header. */
    pub proto: u8,
    /**< Hop limits. */
    pub hop_limits: u8,
    /**< IP address of source host. */
    pub src_addr: [u8; 16usize],
    /**< IP address of destination host(s). */
    pub dst_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ipv6_hdr() {
    assert_eq!(::std::mem::size_of::<ipv6_hdr>() , 40usize);
    assert_eq! (::std::mem::align_of::<ipv6_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . vtc_flow as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . payload_len as * const _
                as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . proto as * const _ as
                usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . hop_limits as * const _ as
                usize } , 7usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . src_addr as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_hdr ) ) . dst_addr as * const _ as
                usize } , 24usize);
}
impl Clone for ipv6_hdr {
    fn clone(&self) -> Self { *self }
}
/** @internal fragmented mbuf */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag {
    /**< offset into the packet */
    pub ofs: u16,
    /**< length of fragment */
    pub len: u16,
    /**< fragment mbuf */
    pub mb: *mut rte_mbuf,
}
#[test]
fn bindgen_test_layout_ip_frag() {
    assert_eq!(::std::mem::size_of::<ip_frag>() , 16usize);
    assert_eq! (::std::mem::align_of::<ip_frag>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag ) ) . ofs as * const _ as usize }
                , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag ) ) . len as * const _ as usize }
                , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag ) ) . mb as * const _ as usize }
                , 8usize);
}
impl Clone for ip_frag {
    fn clone(&self) -> Self { *self }
}
/** @internal <src addr, dst_addr, id> to uniquely indetify fragmented datagram. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag_key {
    /**< src address, first 8 bytes used for IPv4 */
    pub src_dst: [u64; 4usize],
    /**< dst address */
    pub id: u32,
    /**< src/dst key length */
    pub key_len: u32,
}
#[test]
fn bindgen_test_layout_ip_frag_key() {
    assert_eq!(::std::mem::size_of::<ip_frag_key>() , 40usize);
    assert_eq! (::std::mem::align_of::<ip_frag_key>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_key ) ) . src_dst as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_key ) ) . id as * const _ as
                usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_key ) ) . key_len as * const _ as
                usize } , 36usize);
}
impl Clone for ip_frag_key {
    fn clone(&self) -> Self { *self }
}
/**
 * @internal Fragmented packet to reassemble.
 * First two entries in the frags[] array are for the last and first fragments.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag_pkt {
    /**< LRU list */
    pub lru: ip_frag_pkt__bindgen_ty_1,
    /**< fragmentation key */
    pub key: ip_frag_key,
    /**< creation timestamp */
    pub start: u64,
    /**< expected reassembled size */
    pub total_size: u32,
    /**< size of fragments received */
    pub frag_size: u32,
    /**< index of next entry to fill */
    pub last_idx: u32,
    /**< fragments */
    pub frags: [ip_frag; 4usize],
    pub __bindgen_padding_0: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag_pkt__bindgen_ty_1 {
    pub tqe_next: *mut ip_frag_pkt,
    pub tqe_prev: *mut *mut ip_frag_pkt,
}
#[test]
fn bindgen_test_layout_ip_frag_pkt__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ip_frag_pkt__bindgen_ty_1>() , 16usize);
    assert_eq! (::std::mem::align_of::<ip_frag_pkt__bindgen_ty_1>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize);
}
impl Clone for ip_frag_pkt__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ip_frag_pkt() {
    assert_eq!(::std::mem::size_of::<ip_frag_pkt>() , 192usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . lru as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . key as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . start as * const _ as
                usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . total_size as * const _
                as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . frag_size as * const _
                as usize } , 68usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . last_idx as * const _
                as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_pkt ) ) . frags as * const _ as
                usize } , 80usize);
}
impl Clone for ip_frag_pkt {
    fn clone(&self) -> Self { *self }
}
/** mbuf death row (packets to be freed) */
#[repr(C)]
pub struct rte_ip_frag_death_row {
    /**< number of mbufs currently on death row */
    pub cnt: u32,
    pub row: [*mut rte_mbuf; 160usize],
}
#[test]
fn bindgen_test_layout_rte_ip_frag_death_row() {
    assert_eq!(::std::mem::size_of::<rte_ip_frag_death_row>() , 1288usize);
    assert_eq! (::std::mem::align_of::<rte_ip_frag_death_row>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_death_row ) ) . cnt as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_death_row ) ) . row as *
                const _ as usize } , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_pkt_list {
    pub tqh_first: *mut ip_frag_pkt,
    pub tqh_last: *mut *mut ip_frag_pkt,
}
#[test]
fn bindgen_test_layout_ip_pkt_list() {
    assert_eq!(::std::mem::size_of::<ip_pkt_list>() , 16usize);
    assert_eq! (::std::mem::align_of::<ip_pkt_list>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_pkt_list ) ) . tqh_first as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_pkt_list ) ) . tqh_last as * const _
                as usize } , 8usize);
}
impl Clone for ip_pkt_list {
    fn clone(&self) -> Self { *self }
}
/** fragmentation table statistics */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_frag_tbl_stat {
    /**< total # of find/insert attempts. */
    pub find_num: u64,
    /**< # of add ops. */
    pub add_num: u64,
    /**< # of del ops. */
    pub del_num: u64,
    /**< # of reuse (del/add) ops. */
    pub reuse_num: u64,
    /**< total # of add failures. */
    pub fail_total: u64,
    /**< # of 'no space' add failures. */
    pub fail_nospace: u64,
    pub __bindgen_padding_0: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ip_frag_tbl_stat() {
    assert_eq!(::std::mem::size_of::<ip_frag_tbl_stat>() , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . find_num as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . add_num as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . del_num as * const
                _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . reuse_num as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . fail_total as *
                const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_frag_tbl_stat ) ) . fail_nospace as *
                const _ as usize } , 40usize);
}
impl Clone for ip_frag_tbl_stat {
    fn clone(&self) -> Self { *self }
}
/** fragmentation table */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_ip_frag_tbl {
    /**< ttl for table entries. */
    pub max_cycles: u64,
    /**< hash value mask. */
    pub entry_mask: u32,
    /**< max entries allowed. */
    pub max_entries: u32,
    /**< entries in use. */
    pub use_entries: u32,
    /**< hash assocaitivity. */
    pub bucket_entries: u32,
    /**< total size of the table. */
    pub nb_entries: u32,
    /**< num of associativity lines. */
    pub nb_buckets: u32,
    /**< last used entry. */
    pub last: *mut ip_frag_pkt,
    /**< LRU list for table entries. */
    pub lru: ip_pkt_list,
    pub __bindgen_padding_0: u64,
    /**< statistics counters. */
    pub stat: ip_frag_tbl_stat,
    /**< hash table. */
    pub pkt: __IncompleteArrayField<ip_frag_pkt>,
}
#[test]
fn bindgen_test_layout_rte_ip_frag_tbl() {
    assert_eq!(::std::mem::size_of::<rte_ip_frag_tbl>() , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . max_cycles as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . entry_mask as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . max_entries as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . use_entries as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . bucket_entries as *
                const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . nb_entries as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . nb_buckets as *
                const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . last as * const _
                as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . lru as * const _ as
                usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . stat as * const _
                as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_ip_frag_tbl ) ) . pkt as * const _ as
                usize } , 128usize);
}
impl Clone for rte_ip_frag_tbl {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ipv6_extension_fragment {
    /**< Next header type */
    pub next_header: u8,
    /**< Reserved */
    pub reserved: u8,
    /**< All fragmentation data */
    pub frag_data: u16,
    /**< Packet ID */
    pub id: u32,
}
#[test]
fn bindgen_test_layout_ipv6_extension_fragment() {
    assert_eq!(::std::mem::size_of::<ipv6_extension_fragment>() , 8usize);
    assert_eq! (::std::mem::align_of::<ipv6_extension_fragment>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . next_header
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . reserved as
                * const _ as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . frag_data
                as * const _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_extension_fragment ) ) . id as *
                const _ as usize } , 4usize);
}
impl Clone for ipv6_extension_fragment {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Create a new IP fragmentation table.
 *
 * @param bucket_num
 *   Number of buckets in the hash table.
 * @param bucket_entries
 *   Number of entries per bucket (e.g. hash associativity).
 *   Should be power of two.
 * @param max_entries
 *   Maximum number of entries that could be stored in the table.
 *   The value should be less or equal then bucket_num * bucket_entries.
 * @param max_cycles
 *   Maximum TTL in cycles for each fragmented packet.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in the case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA constraints.
 * @return
 *   The pointer to the new allocated fragmentation table, on success. NULL on error.
 */
    pub fn rte_ip_frag_table_create(bucket_num: u32, bucket_entries: u32,
                                    max_entries: u32, max_cycles: u64,
                                    socket_id: ::std::os::raw::c_int)
     -> *mut rte_ip_frag_tbl;
}
extern "C" {
    /**
 * This function implements the fragmentation of IPv6 packets.
 *
 * @param pkt_in
 *   The input packet.
 * @param pkts_out
 *   Array storing the output fragments.
 * @param nb_pkts_out
 *   Number of fragments.
 * @param mtu_size
 *   Size in bytes of the Maximum Transfer Unit (MTU) for the outgoing IPv6
 *   datagrams. This value includes the size of the IPv6 header.
 * @param pool_direct
 *   MBUF pool used for allocating direct buffers for the output fragments.
 * @param pool_indirect
 *   MBUF pool used for allocating indirect buffers for the output fragments.
 * @return
 *   Upon successful completion - number of output fragments placed
 *   in the pkts_out array.
 *   Otherwise - (-1) * errno.
 */
    pub fn rte_ipv6_fragment_packet(pkt_in: *mut rte_mbuf,
                                    pkts_out: *mut *mut rte_mbuf,
                                    nb_pkts_out: u16, mtu_size: u16,
                                    pool_direct:
                                        *mut rte_mempool_objhdr_rte_mempool,
                                    pool_indirect:
                                        *mut rte_mempool_objhdr_rte_mempool)
     -> i32;
}
extern "C" {
    /**
 * This function implements reassembly of fragmented IPv6 packets.
 * Incoming mbuf should have its l2_len/l3_len fields setup correctly.
 *
 * @param tbl
 *   Table where to lookup/add the fragmented packet.
 * @param dr
 *   Death row to free buffers to
 * @param mb
 *   Incoming mbuf with IPv6 fragment.
 * @param tms
 *   Fragment arrival timestamp.
 * @param ip_hdr
 *   Pointer to the IPv6 header.
 * @param frag_hdr
 *   Pointer to the IPv6 fragment extension header.
 * @return
 *   Pointer to mbuf for reassembled packet, or NULL if:
 *   - an error occured.
 *   - not all fragments of the packet are collected yet.
 */
    pub fn rte_ipv6_frag_reassemble_packet(tbl: *mut rte_ip_frag_tbl,
                                           dr: *mut rte_ip_frag_death_row,
                                           mb: *mut rte_mbuf, tms: u64,
                                           ip_hdr: *mut ipv6_hdr,
                                           frag_hdr:
                                               *mut ipv6_extension_fragment)
     -> *mut rte_mbuf;
}
extern "C" {
    /**
 * IPv4 fragmentation.
 *
 * This function implements the fragmentation of IPv4 packets.
 *
 * @param pkt_in
 *   The input packet.
 * @param pkts_out
 *   Array storing the output fragments.
 * @param nb_pkts_out
 *   Number of fragments.
 * @param mtu_size
 *   Size in bytes of the Maximum Transfer Unit (MTU) for the outgoing IPv4
 *   datagrams. This value includes the size of the IPv4 header.
 * @param pool_direct
 *   MBUF pool used for allocating direct buffers for the output fragments.
 * @param pool_indirect
 *   MBUF pool used for allocating indirect buffers for the output fragments.
 * @return
 *   Upon successful completion - number of output fragments placed
 *   in the pkts_out array.
 *   Otherwise - (-1) * errno.
 */
    pub fn rte_ipv4_fragment_packet(pkt_in: *mut rte_mbuf,
                                    pkts_out: *mut *mut rte_mbuf,
                                    nb_pkts_out: u16, mtu_size: u16,
                                    pool_direct:
                                        *mut rte_mempool_objhdr_rte_mempool,
                                    pool_indirect:
                                        *mut rte_mempool_objhdr_rte_mempool)
     -> i32;
}
extern "C" {
    /**
 * This function implements reassembly of fragmented IPv4 packets.
 * Incoming mbufs should have its l2_len/l3_len fields setup correclty.
 *
 * @param tbl
 *   Table where to lookup/add the fragmented packet.
 * @param dr
 *   Death row to free buffers to
 * @param mb
 *   Incoming mbuf with IPv4 fragment.
 * @param tms
 *   Fragment arrival timestamp.
 * @param ip_hdr
 *   Pointer to the IPV4 header inside the fragment.
 * @return
 *   Pointer to mbuf for reassebled packet, or NULL if:
 *   - an error occured.
 *   - not all fragments of the packet are collected yet.
 */
    pub fn rte_ipv4_frag_reassemble_packet(tbl: *mut rte_ip_frag_tbl,
                                           dr: *mut rte_ip_frag_death_row,
                                           mb: *mut rte_mbuf, tms: u64,
                                           ip_hdr: *mut ipv4_hdr)
     -> *mut rte_mbuf;
}
extern "C" {
    /**
 * Free mbufs on a given death row.
 *
 * @param dr
 *   Death row to free mbufs in.
 * @param prefetch
 *   How many buffers to prefetch before freeing.
 */
    pub fn rte_ip_frag_free_death_row(dr: *mut rte_ip_frag_death_row,
                                      prefetch: u32);
}
extern "C" {
    /**
 * Dump fragmentation table statistics to file.
 *
 * @param f
 *   File to dump statistics to
 * @param tbl
 *   Fragmentation table to dump statistics from
 */
    pub fn rte_ip_frag_table_statistics_dump(f: *mut FILE,
                                             tbl: *const rte_ip_frag_tbl);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_kni_req_id {
    RTE_KNI_REQ_UNKNOWN = 0,
    RTE_KNI_REQ_CHANGE_MTU = 1,
    RTE_KNI_REQ_CFG_NETWORK_IF = 2,
    RTE_KNI_REQ_MAX = 3,
}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct rte_kni_request {
    /**< Request id */
    pub req_id: u32,
    pub __bindgen_anon_1: rte_kni_request__bindgen_ty_1,
    /**< Result for processing request */
    pub result: i32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_request__bindgen_ty_1 {
    /**< New MTU */
    pub new_mtu: __BindgenUnionField<u32>,
    /**< 1: interface up, 0: interface down */
    pub if_up: __BindgenUnionField<u8>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_rte_kni_request__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_kni_request__bindgen_ty_1>() ,
               4usize);
    assert_eq! (::std::mem::align_of::<rte_kni_request__bindgen_ty_1>() ,
                4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request__bindgen_ty_1 ) ) .
                new_mtu as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request__bindgen_ty_1 ) ) . if_up
                as * const _ as usize } , 0usize);
}
impl Clone for rte_kni_request__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_kni_request() {
    assert_eq!(::std::mem::size_of::<rte_kni_request>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_kni_request>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request ) ) . req_id as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_request ) ) . result as * const _
                as usize } , 8usize);
}
impl Clone for rte_kni_request {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_fifo {
    /**< Next position to be written*/
    pub write: ::std::os::raw::c_uint,
    /**< Next position to be read */
    pub read: ::std::os::raw::c_uint,
    /**< Circular buffer length */
    pub len: ::std::os::raw::c_uint,
    /**< Pointer size - for 32/64 bit OS */
    pub elem_size: ::std::os::raw::c_uint,
    /**< The buffer contains mbuf pointers */
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_kni_fifo() {
    assert_eq!(::std::mem::size_of::<rte_kni_fifo>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_kni_fifo>() , 8usize);
}
impl Clone for rte_kni_fifo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_mbuf {
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub buf_physaddr: u64,
    pub pad0: [::std::os::raw::c_char; 2usize],
    /**< Start address of data in segment buffer. */
    pub data_off: u16,
    pub pad1: [::std::os::raw::c_char; 2usize],
    /**< Number of segments. */
    pub nb_segs: u8,
    pub pad4: [::std::os::raw::c_char; 1usize],
    /**< Offload features. */
    pub ol_flags: u64,
    pub pad2: [::std::os::raw::c_char; 4usize],
    /**< Total pkt len: sum of all segment data_len. */
    pub pkt_len: u32,
    /**< Amount of data in segment buffer. */
    pub data_len: u16,
    pub __bindgen_padding_0: [u8; 22usize],
    pub pad3: [::std::os::raw::c_char; 8usize],
    pub pool: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub __bindgen_padding_1: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_rte_kni_mbuf() {
    assert_eq!(::std::mem::size_of::<rte_kni_mbuf>() , 128usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . buf_addr as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . buf_physaddr as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad0 as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . data_off as * const _
                as usize } , 18usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad1 as * const _ as
                usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . nb_segs as * const _
                as usize } , 22usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad4 as * const _ as
                usize } , 23usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . ol_flags as * const _
                as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad2 as * const _ as
                usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pkt_len as * const _
                as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . data_len as * const _
                as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pad3 as * const _ as
                usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . pool as * const _ as
                usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_mbuf ) ) . next as * const _ as
                usize } , 80usize);
}
impl Clone for rte_kni_mbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_device_info {
    /**< Network device name for KNI */
    pub name: [::std::os::raw::c_char; 32usize],
    pub tx_phys: phys_addr_t,
    pub rx_phys: phys_addr_t,
    pub alloc_phys: phys_addr_t,
    pub free_phys: phys_addr_t,
    pub req_phys: phys_addr_t,
    pub resp_phys: phys_addr_t,
    pub sync_phys: phys_addr_t,
    pub sync_va: *mut ::std::os::raw::c_void,
    pub mbuf_va: *mut ::std::os::raw::c_void,
    pub mbuf_phys: phys_addr_t,
    /**< Vendor ID or PCI_ANY_ID. */
    pub vendor_id: u16,
    /**< Device ID or PCI_ANY_ID. */
    pub device_id: u16,
    /**< Device bus */
    pub bus: u8,
    /**< Device ID */
    pub devid: u8,
    /**< Device function. */
    pub function: u8,
    /**< Group ID */
    pub group_id: u16,
    /**< core ID to bind for kernel thread */
    pub core_id: u32,
    pub _bitfield_1: u8,
    pub mbuf_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_kni_device_info() {
    assert_eq!(::std::mem::size_of::<rte_kni_device_info>() , 136usize);
    assert_eq! (::std::mem::align_of::<rte_kni_device_info>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . name as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . tx_phys as *
                const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . rx_phys as *
                const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . alloc_phys as *
                const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . free_phys as *
                const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . req_phys as *
                const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . resp_phys as *
                const _ as usize } , 72usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . sync_phys as *
                const _ as usize } , 80usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . sync_va as *
                const _ as usize } , 88usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . mbuf_va as *
                const _ as usize } , 96usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . mbuf_phys as *
                const _ as usize } , 104usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . vendor_id as *
                const _ as usize } , 112usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . device_id as *
                const _ as usize } , 114usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . bus as * const
                _ as usize } , 116usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . devid as *
                const _ as usize } , 117usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . function as *
                const _ as usize } , 118usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . group_id as *
                const _ as usize } , 120usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . core_id as *
                const _ as usize } , 124usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_device_info ) ) . mbuf_size as *
                const _ as usize } , 132usize);
}
impl Clone for rte_kni_device_info {
    fn clone(&self) -> Self { *self }
}
impl rte_kni_device_info {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni([u8; 0]);
/**
 * Structure which has the function pointers for KNI interface.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_ops {
    pub port_id: u8,
    pub change_mtu: ::std::option::Option<unsafe extern "C" fn(port_id: u8,
                                                               new_mtu:
                                                                   ::std::os::raw::c_uint)
                                              -> ::std::os::raw::c_int>,
    pub config_network_if: ::std::option::Option<unsafe extern "C" fn(port_id:
                                                                          u8,
                                                                      if_up:
                                                                          u8)
                                                     ->
                                                         ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_rte_kni_ops() {
    assert_eq!(::std::mem::size_of::<rte_kni_ops>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_kni_ops>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_ops ) ) . port_id as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_ops ) ) . change_mtu as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_ops ) ) . config_network_if as *
                const _ as usize } , 16usize);
}
impl Clone for rte_kni_ops {
    fn clone(&self) -> Self { *self }
}
/**
 * Structure for configuring KNI device.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_kni_conf {
    pub name: [::std::os::raw::c_char; 32usize],
    pub core_id: u32,
    pub group_id: u16,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub addr: rte_pci_addr,
    pub id: rte_pci_id,
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout_rte_kni_conf() {
    assert_eq!(::std::mem::size_of::<rte_kni_conf>() , 68usize);
    assert_eq! (::std::mem::align_of::<rte_kni_conf>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . name as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . core_id as * const _
                as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . group_id as * const _
                as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . mbuf_size as * const _
                as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . addr as * const _ as
                usize } , 44usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_kni_conf ) ) . id as * const _ as
                usize } , 52usize);
}
impl Clone for rte_kni_conf {
    fn clone(&self) -> Self { *self }
}
impl rte_kni_conf {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
}
extern "C" {
    /**
 * Initialize and preallocate KNI subsystem
 *
 * This function is to be executed on the MASTER lcore only, after EAL
 * initialization and before any KNI interface is attempted to be
 * allocated
 *
 * @param max_kni_ifaces
 *  The maximum number of KNI interfaces that can coexist concurrently
 */
    pub fn rte_kni_init(max_kni_ifaces: ::std::os::raw::c_uint);
}
extern "C" {
    /**
 * Allocate KNI interface according to the port id, mbuf size, mbuf pool,
 * configurations and callbacks for kernel requests.The KNI interface created
 * in the kernel space is the net interface the traditional Linux application
 * talking to.
 *
 * The rte_kni_alloc shall not be called before rte_kni_init() has been
 * called. rte_kni_alloc is thread safe.
 *
 * The mempool should have capacity of more than "2 x KNI_FIFO_COUNT_MAX"
 * elements for each KNI interface allocated.
 *
 * @param pktmbuf_pool
 *  The mempool for allocting mbufs for packets.
 * @param conf
 *  The pointer to the configurations of the KNI device.
 * @param ops
 *  The pointer to the callbacks for the KNI kernel requests.
 *
 * @return
 *  - The pointer to the context of a KNI interface.
 *  - NULL indicate error.
 */
    pub fn rte_kni_alloc(pktmbuf_pool: *mut rte_mempool_objhdr_rte_mempool,
                         conf: *const rte_kni_conf, ops: *mut rte_kni_ops)
     -> *mut rte_kni;
}
extern "C" {
    /**
 * Release KNI interface according to the context. It will also release the
 * paired KNI interface in kernel space. All processing on the specific KNI
 * context need to be stopped before calling this interface.
 *
 * rte_kni_release is thread safe.
 *
 * @param kni
 *  The pointer to the context of an existent KNI interface.
 *
 * @return
 *  - 0 indicates success.
 *  - negative value indicates failure.
 */
    pub fn rte_kni_release(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * It is used to handle the request mbufs sent from kernel space.
 * Then analyzes it and calls the specific actions for the specific requests.
 * Finally constructs the response mbuf and puts it back to the resp_q.
 *
 * @param kni
 *  The pointer to the context of an existent KNI interface.
 *
 * @return
 *  - 0
 *  - negative value indicates failure.
 */
    pub fn rte_kni_handle_request(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Retrieve a burst of packets from a KNI interface. The retrieved packets are
 * stored in rte_mbuf structures whose pointers are supplied in the array of
 * mbufs, and the maximum number is indicated by num. It handles allocating
 * the mbufs for KNI interface alloc queue.
 *
 * @param kni
 *  The KNI interface context.
 * @param mbufs
 *  The array to store the pointers of mbufs.
 * @param num
 *  The maximum number per burst.
 *
 * @return
 *  The actual number of packets retrieved.
 */
    pub fn rte_kni_rx_burst(kni: *mut rte_kni, mbufs: *mut *mut rte_mbuf,
                            num: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * Send a burst of packets to a KNI interface. The packets to be sent out are
 * stored in rte_mbuf structures whose pointers are supplied in the array of
 * mbufs, and the maximum number is indicated by num. It handles the freeing of
 * the mbufs in the free queue of KNI interface.
 *
 * @param kni
 *  The KNI interface context.
 * @param mbufs
 *  The array to store the pointers of mbufs.
 * @param num
 *  The maximum number per burst.
 *
 * @return
 *  The actual number of packets sent.
 */
    pub fn rte_kni_tx_burst(kni: *mut rte_kni, mbufs: *mut *mut rte_mbuf,
                            num: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * Get the KNI context of its name.
 *
 * @param name
 *  pointer to the KNI device name.
 *
 * @return
 *  On success: Pointer to KNI interface.
 *  On failure: NULL.
 */
    pub fn rte_kni_get(name: *const ::std::os::raw::c_char) -> *mut rte_kni;
}
extern "C" {
    /**
 * Get the name given to a KNI device
 *
 * @param kni
 *   The KNI instance to query
 * @return
 *   The pointer to the KNI name
 */
    pub fn rte_kni_get_name(kni: *const rte_kni)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Register KNI request handling for a specified port,and it can
 * be called by master process or slave process.
 *
 * @param kni
 *  pointer to struct rte_kni.
 * @param ops
 *  ponter to struct rte_kni_ops.
 *
 * @return
 *  On success: 0
 *  On failure: -1
 */
    pub fn rte_kni_register_handlers(kni: *mut rte_kni, ops: *mut rte_kni_ops)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *  Unregister KNI request handling for a specified port.
 *
 *  @param kni
 *   pointer to struct rte_kni.
 *
 *  @return
 *   On success: 0
 *   On failure: -1
 */
    pub fn rte_kni_unregister_handlers(kni: *mut rte_kni)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *  Close KNI device.
 */
    pub fn rte_kni_close();
}
/** @internal Tbl24 entry structure. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_tbl_entry_v20 {
    pub __bindgen_anon_1: rte_lpm_tbl_entry_v20__bindgen_ty_1,
    pub _bitfield_1: u8,
}
/**
	 * Stores Next hop (tbl8 or tbl24 when valid_group is not set) or
	 * a group index pointing to a tbl8 structure (tbl24 only, when
	 * valid_group is set)
	 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_tbl_entry_v20__bindgen_ty_1 {
    pub next_hop: __BindgenUnionField<u8>,
    pub group_idx: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[test]
fn bindgen_test_layout_rte_lpm_tbl_entry_v20__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_lpm_tbl_entry_v20__bindgen_ty_1>() ,
               1usize);
    assert_eq! (::std::mem::align_of::<rte_lpm_tbl_entry_v20__bindgen_ty_1>()
                , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_tbl_entry_v20__bindgen_ty_1 ) ) .
                next_hop as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_tbl_entry_v20__bindgen_ty_1 ) ) .
                group_idx as * const _ as usize } , 0usize);
}
impl Clone for rte_lpm_tbl_entry_v20__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_lpm_tbl_entry_v20() {
    assert_eq!(::std::mem::size_of::<rte_lpm_tbl_entry_v20>() , 2usize);
    assert_eq! (::std::mem::align_of::<rte_lpm_tbl_entry_v20>() , 1usize);
}
impl Clone for rte_lpm_tbl_entry_v20 {
    fn clone(&self) -> Self { *self }
}
impl rte_lpm_tbl_entry_v20 {
    #[inline]
    pub fn valid(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u8)
        }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u8) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 0u32) & (1usize as u8);
    }
    #[inline]
    pub fn valid_group(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u8)) >>
                                       1u32) as u8)
        }
    }
    #[inline]
    pub fn set_valid_group(&mut self, val: u8) {
        self._bitfield_1 &= !(2usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 1u32) & (2usize as u8);
    }
    #[inline]
    pub fn depth(&self) -> u8 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (252usize as u8)) >>
                                       2u32) as u8)
        }
    }
    #[inline]
    pub fn set_depth(&mut self, val: u8) {
        self._bitfield_1 &= !(252usize as u8);
        self._bitfield_1 |= ((val as u8 as u8) << 2u32) & (252usize as u8);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_tbl_entry {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_rte_lpm_tbl_entry() {
    assert_eq!(::std::mem::size_of::<rte_lpm_tbl_entry>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_lpm_tbl_entry>() , 4usize);
}
impl Clone for rte_lpm_tbl_entry {
    fn clone(&self) -> Self { *self }
}
impl rte_lpm_tbl_entry {
    #[inline]
    pub fn next_hop(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16777215usize as u32))
                                       >> 0u32) as u32)
        }
    }
    #[inline]
    pub fn set_next_hop(&mut self, val: u32) {
        self._bitfield_1 &= !(16777215usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (16777215usize as u32);
    }
    #[inline]
    pub fn valid(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16777216usize as u32))
                                       >> 24u32) as u32)
        }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32) {
        self._bitfield_1 &= !(16777216usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (16777216usize as u32);
    }
    #[inline]
    pub fn valid_group(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (33554432usize as u32))
                                       >> 25u32) as u32)
        }
    }
    #[inline]
    pub fn set_valid_group(&mut self, val: u32) {
        self._bitfield_1 &= !(33554432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 25u32) & (33554432usize as u32);
    }
    #[inline]
    pub fn depth(&self) -> u32 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4227858432usize as u32)) >> 26u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_depth(&mut self, val: u32) {
        self._bitfield_1 &= !(4227858432usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 26u32) & (4227858432usize as u32);
    }
}
/** LPM configuration structure. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_config {
    /**< Max number of rules. */
    pub max_rules: u32,
    /**< Number of tbl8s to allocate. */
    pub number_tbl8s: u32,
    /**< This field is currently unused. */
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_lpm_config() {
    assert_eq!(::std::mem::size_of::<rte_lpm_config>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_lpm_config>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_config ) ) . max_rules as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_config ) ) . number_tbl8s as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_config ) ) . flags as * const _
                as usize } , 8usize);
}
impl Clone for rte_lpm_config {
    fn clone(&self) -> Self { *self }
}
/** @internal Rule structure. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_rule_v20 {
    /**< Rule IP address. */
    pub ip: u32,
    /**< Rule next hop. */
    pub next_hop: u8,
}
#[test]
fn bindgen_test_layout_rte_lpm_rule_v20() {
    assert_eq!(::std::mem::size_of::<rte_lpm_rule_v20>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_lpm_rule_v20>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_v20 ) ) . ip as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_v20 ) ) . next_hop as *
                const _ as usize } , 4usize);
}
impl Clone for rte_lpm_rule_v20 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_rule {
    /**< Rule IP address. */
    pub ip: u32,
    /**< Rule next hop. */
    pub next_hop: u32,
}
#[test]
fn bindgen_test_layout_rte_lpm_rule() {
    assert_eq!(::std::mem::size_of::<rte_lpm_rule>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_lpm_rule>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule ) ) . ip as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule ) ) . next_hop as * const _
                as usize } , 4usize);
}
impl Clone for rte_lpm_rule {
    fn clone(&self) -> Self { *self }
}
/** @internal Contains metadata about the rules table. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm_rule_info {
    /**< Used rules so far. */
    pub used_rules: u32,
    /**< Indexes the first rule of a given depth. */
    pub first_rule: u32,
}
#[test]
fn bindgen_test_layout_rte_lpm_rule_info() {
    assert_eq!(::std::mem::size_of::<rte_lpm_rule_info>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_lpm_rule_info>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_info ) ) . used_rules as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm_rule_info ) ) . first_rule as *
                const _ as usize } , 4usize);
}
impl Clone for rte_lpm_rule_info {
    fn clone(&self) -> Self { *self }
}
/** @internal LPM structure. */
#[repr(C)]
pub struct rte_lpm_v20 {
    /**< Name of the lpm. */
    pub name: [::std::os::raw::c_char; 32usize],
    /**< Max. balanced rules per lpm. */
    pub max_rules: u32,
    /**< Rule info table. */
    pub rule_info: [rte_lpm_rule_info; 32usize],
    pub tbl24: [rte_lpm_tbl_entry_v20; 16777216usize],
    pub tbl8: [rte_lpm_tbl_entry_v20; 65536usize],
    pub rules_tbl: __IncompleteArrayField<rte_lpm_rule_v20>,
    pub __bindgen_padding_0: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_rte_lpm_v20() {
    assert_eq!(::std::mem::size_of::<rte_lpm_v20>() , 33685824usize);
}
#[repr(C)]
pub struct rte_lpm {
    /**< Name of the lpm. */
    pub name: [::std::os::raw::c_char; 32usize],
    /**< Max. balanced rules per lpm. */
    pub max_rules: u32,
    /**< Number of tbl8s. */
    pub number_tbl8s: u32,
    /**< Rule info table. */
    pub rule_info: [rte_lpm_rule_info; 32usize],
    pub __bindgen_padding_0: [u32; 6usize],
    pub tbl24: [rte_lpm_tbl_entry; 16777216usize],
    /**< LPM tbl8 table. */
    pub tbl8: *mut rte_lpm_tbl_entry,
    /**< LPM rules. */
    pub rules_tbl: *mut rte_lpm_rule,
    pub __bindgen_padding_1: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_rte_lpm() {
    assert_eq!(::std::mem::size_of::<rte_lpm>() , 67109248usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . name as * const _ as usize
                } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . max_rules as * const _ as
                usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . number_tbl8s as * const _
                as usize } , 36usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . rule_info as * const _ as
                usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . tbl24 as * const _ as usize
                } , 320usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . tbl8 as * const _ as usize
                } , 67109184usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm ) ) . rules_tbl as * const _ as
                usize } , 67109192usize);
}
extern "C" {
    /**
 * Create an LPM object.
 *
 * @param name
 *   LPM object name
 * @param socket_id
 *   NUMA socket ID for LPM table memory allocation
 * @param config
 *   Structure containing the configuration
 * @return
 *   Handle to LPM object on success, NULL otherwise with rte_errno set
 *   to an appropriate values. Possible rte_errno values include:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - EINVAL - invalid parameter passed to function
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */
    pub fn rte_lpm_create(name: *const ::std::os::raw::c_char,
                          socket_id: ::std::os::raw::c_int,
                          config: *const rte_lpm_config) -> *mut rte_lpm;
}
extern "C" {
    pub fn rte_lpm_create_v20(name: *const ::std::os::raw::c_char,
                              socket_id: ::std::os::raw::c_int,
                              max_rules: ::std::os::raw::c_int,
                              flags: ::std::os::raw::c_int)
     -> *mut rte_lpm_v20;
}
extern "C" {
    pub fn rte_lpm_create_v1604(name: *const ::std::os::raw::c_char,
                                socket_id: ::std::os::raw::c_int,
                                config: *const rte_lpm_config)
     -> *mut rte_lpm;
}
extern "C" {
    /**
 * Find an existing LPM object and return a pointer to it.
 *
 * @param name
 *   Name of the lpm object as passed to rte_lpm_create()
 * @return
 *   Pointer to lpm object or NULL if object not found with rte_errno
 *   set appropriately. Possible rte_errno values include:
 *    - ENOENT - required entry not available to return.
 */
    pub fn rte_lpm_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm;
}
extern "C" {
    pub fn rte_lpm_find_existing_v20(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm_v20;
}
extern "C" {
    pub fn rte_lpm_find_existing_v1604(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm;
}
extern "C" {
    /**
 * Free an LPM object.
 *
 * @param lpm
 *   LPM object handle
 * @return
 *   None
 */
    pub fn rte_lpm_free(lpm: *mut rte_lpm);
}
extern "C" {
    pub fn rte_lpm_free_v20(lpm: *mut rte_lpm_v20);
}
extern "C" {
    pub fn rte_lpm_free_v1604(lpm: *mut rte_lpm);
}
extern "C" {
    /**
 * Add a rule to the LPM table.
 *
 * @param lpm
 *   LPM object handle
 * @param ip
 *   IP of the rule to be added to the LPM table
 * @param depth
 *   Depth of the rule to be added to the LPM table
 * @param next_hop
 *   Next hop of the rule to be added to the LPM table
 * @return
 *   0 on success, negative value otherwise
 */
    pub fn rte_lpm_add(lpm: *mut rte_lpm, ip: u32, depth: u8, next_hop: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_add_v20(lpm: *mut rte_lpm_v20, ip: u32, depth: u8,
                           next_hop: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_add_v1604(lpm: *mut rte_lpm, ip: u32, depth: u8,
                             next_hop: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Check if a rule is present in the LPM table,
 * and provide its next hop if it is.
 *
 * @param lpm
 *   LPM object handle
 * @param ip
 *   IP of the rule to be searched
 * @param depth
 *   Depth of the rule to searched
 * @param next_hop
 *   Next hop of the rule (valid only if it is found)
 * @return
 *   1 if the rule exists, 0 if it does not, a negative value on failure
 */
    pub fn rte_lpm_is_rule_present(lpm: *mut rte_lpm, ip: u32, depth: u8,
                                   next_hop: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_is_rule_present_v20(lpm: *mut rte_lpm_v20, ip: u32,
                                       depth: u8, next_hop: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_is_rule_present_v1604(lpm: *mut rte_lpm, ip: u32,
                                         depth: u8, next_hop: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete a rule from the LPM table.
 *
 * @param lpm
 *   LPM object handle
 * @param ip
 *   IP of the rule to be deleted from the LPM table
 * @param depth
 *   Depth of the rule to be deleted from the LPM table
 * @return
 *   0 on success, negative value otherwise
 */
    pub fn rte_lpm_delete(lpm: *mut rte_lpm, ip: u32, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_delete_v20(lpm: *mut rte_lpm_v20, ip: u32, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lpm_delete_v1604(lpm: *mut rte_lpm, ip: u32, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete all rules from the LPM table.
 *
 * @param lpm
 *   LPM object handle
 */
    pub fn rte_lpm_delete_all(lpm: *mut rte_lpm);
}
extern "C" {
    pub fn rte_lpm_delete_all_v20(lpm: *mut rte_lpm_v20);
}
extern "C" {
    pub fn rte_lpm_delete_all_v1604(lpm: *mut rte_lpm);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_lpm6([u8; 0]);
/** LPM configuration structure. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_lpm6_config {
    /**< Max number of rules. */
    pub max_rules: u32,
    /**< Number of tbl8s to allocate. */
    pub number_tbl8s: u32,
    /**< This field is currently unused. */
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_lpm6_config() {
    assert_eq!(::std::mem::size_of::<rte_lpm6_config>() , 12usize);
    assert_eq! (::std::mem::align_of::<rte_lpm6_config>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm6_config ) ) . max_rules as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm6_config ) ) . number_tbl8s as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_lpm6_config ) ) . flags as * const _
                as usize } , 8usize);
}
impl Clone for rte_lpm6_config {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Create an LPM object.
 *
 * @param name
 *   LPM object name
 * @param socket_id
 *   NUMA socket ID for LPM table memory allocation
 * @param config
 *   Structure containing the configuration
 * @return
 *   Handle to LPM object on success, NULL otherwise with rte_errno set
 *   to an appropriate values. Possible rte_errno values include:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - EINVAL - invalid parameter passed to function
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */
    pub fn rte_lpm6_create(name: *const ::std::os::raw::c_char,
                           socket_id: ::std::os::raw::c_int,
                           config: *const rte_lpm6_config) -> *mut rte_lpm6;
}
extern "C" {
    /**
 * Find an existing LPM object and return a pointer to it.
 *
 * @param name
 *   Name of the lpm object as passed to rte_lpm6_create()
 * @return
 *   Pointer to lpm object or NULL if object not found with rte_errno
 *   set appropriately. Possible rte_errno values include:
 *    - ENOENT - required entry not available to return.
 */
    pub fn rte_lpm6_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_lpm6;
}
extern "C" {
    /**
 * Free an LPM object.
 *
 * @param lpm
 *   LPM object handle
 * @return
 *   None
 */
    pub fn rte_lpm6_free(lpm: *mut rte_lpm6);
}
extern "C" {
    /**
 * Add a rule to the LPM table.
 *
 * @param lpm
 *   LPM object handle
 * @param ip
 *   IP of the rule to be added to the LPM table
 * @param depth
 *   Depth of the rule to be added to the LPM table
 * @param next_hop
 *   Next hop of the rule to be added to the LPM table
 * @return
 *   0 on success, negative value otherwise
 */
    pub fn rte_lpm6_add(lpm: *mut rte_lpm6, ip: *mut u8, depth: u8,
                        next_hop: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Check if a rule is present in the LPM table,
 * and provide its next hop if it is.
 *
 * @param lpm
 *   LPM object handle
 * @param ip
 *   IP of the rule to be searched
 * @param depth
 *   Depth of the rule to searched
 * @param next_hop
 *   Next hop of the rule (valid only if it is found)
 * @return
 *   1 if the rule exists, 0 if it does not, a negative value on failure
 */
    pub fn rte_lpm6_is_rule_present(lpm: *mut rte_lpm6, ip: *mut u8,
                                    depth: u8, next_hop: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete a rule from the LPM table.
 *
 * @param lpm
 *   LPM object handle
 * @param ip
 *   IP of the rule to be deleted from the LPM table
 * @param depth
 *   Depth of the rule to be deleted from the LPM table
 * @return
 *   0 on success, negative value otherwise
 */
    pub fn rte_lpm6_delete(lpm: *mut rte_lpm6, ip: *mut u8, depth: u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete a rule from the LPM table.
 *
 * @param lpm
 *   LPM object handle
 * @param ips
 *   Array of IPs to be deleted from the LPM table
 * @param depths
 *   Array of depths of the rules to be deleted from the LPM table
 * @param n
 *   Number of rules to be deleted from the LPM table
 * @return
 *   0 on success, negative value otherwise.
 */
    pub fn rte_lpm6_delete_bulk_func(lpm: *mut rte_lpm6,
                                     ips: *mut [u8; 16usize], depths: *mut u8,
                                     n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Delete all rules from the LPM table.
 *
 * @param lpm
 *   LPM object handle
 */
    pub fn rte_lpm6_delete_all(lpm: *mut rte_lpm6);
}
extern "C" {
    /**
 * Lookup an IP into the LPM table.
 *
 * @param lpm
 *   LPM object handle
 * @param ip
 *   IP to be looked up in the LPM table
 * @param next_hop
 *   Next hop of the most specific rule found for IP (valid on lookup hit only)
 * @return
 *   -EINVAL for incorrect arguments, -ENOENT on lookup miss, 0 on lookup hit
 */
    pub fn rte_lpm6_lookup(lpm: *const rte_lpm6, ip: *mut u8,
                           next_hop: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Lookup multiple IP addresses in an LPM table.
 *
 * @param lpm
 *   LPM object handle
 * @param ips
 *   Array of IPs to be looked up in the LPM table
 * @param next_hops
 *   Next hop of the most specific rule found for IP (valid on lookup hit only).
 *   This is an array of two byte values. The next hop will be stored on
 *   each position on success; otherwise the position will be set to -1.
 * @param n
 *   Number of elements in ips (and next_hops) array to lookup.
 *  @return
 *   -EINVAL for incorrect arguments, otherwise 0
 */
    pub fn rte_lpm6_lookup_bulk_func(lpm: *const rte_lpm6,
                                     ips: *mut [u8; 16usize],
                                     next_hops: *mut i16,
                                     n: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/** Packet Color Set */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_meter_color {
    e_RTE_METER_GREEN = 0,
    e_RTE_METER_YELLOW = 1,
    e_RTE_METER_RED = 2,
    e_RTE_METER_COLORS = 3,
}
/** srTCM parameters per metered traffic flow. The CIR, CBS and EBS parameters only
count bytes of IP packets and do not include link specific headers. At least one of
the CBS or EBS parameters has to be greater than zero. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_srtcm_params {
    /**< Committed Information Rate (CIR). Measured in bytes per second. */
    pub cir: u64,
    /**< Committed Burst Size (CBS).  Measured in bytes. */
    pub cbs: u64,
    /**< Excess Burst Size (EBS).  Measured in bytes. */
    pub ebs: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_srtcm_params() {
    assert_eq!(::std::mem::size_of::<rte_meter_srtcm_params>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_meter_srtcm_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm_params ) ) . cir as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm_params ) ) . cbs as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm_params ) ) . ebs as *
                const _ as usize } , 16usize);
}
impl Clone for rte_meter_srtcm_params {
    fn clone(&self) -> Self { *self }
}
/** trTCM parameters per metered traffic flow. The CIR, PIR, CBS and PBS parameters
only count bytes of IP packets and do not include link specific headers. PIR has to
be greater than or equal to CIR. Both CBS or EBS have to be greater than zero. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_trtcm_params {
    /**< Committed Information Rate (CIR). Measured in bytes per second. */
    pub cir: u64,
    /**< Peak Information Rate (PIR). Measured in bytes per second. */
    pub pir: u64,
    /**< Committed Burst Size (CBS). Measured in byes. */
    pub cbs: u64,
    /**< Peak Burst Size (PBS). Measured in bytes. */
    pub pbs: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_trtcm_params() {
    assert_eq!(::std::mem::size_of::<rte_meter_trtcm_params>() , 32usize);
    assert_eq! (::std::mem::align_of::<rte_meter_trtcm_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . cir as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . pir as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . cbs as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm_params ) ) . pbs as *
                const _ as usize } , 24usize);
}
impl Clone for rte_meter_trtcm_params {
    fn clone(&self) -> Self { *self }
}
/** Internal data structure storing the srTCM run-time context per metered traffic flow. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_srtcm {
    pub time: u64,
    pub tc: u64,
    pub te: u64,
    pub cbs: u64,
    pub ebs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_srtcm() {
    assert_eq!(::std::mem::size_of::<rte_meter_srtcm>() , 56usize);
    assert_eq! (::std::mem::align_of::<rte_meter_srtcm>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . time as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . tc as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . te as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . cbs as * const _ as
                usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . ebs as * const _ as
                usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) . cir_period as *
                const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_srtcm ) ) .
                cir_bytes_per_period as * const _ as usize } , 48usize);
}
impl Clone for rte_meter_srtcm {
    fn clone(&self) -> Self { *self }
}
/** Internal data structure storing the trTCM run-time context per metered traffic flow. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_meter_trtcm {
    pub time_tc: u64,
    pub time_tp: u64,
    pub tc: u64,
    pub tp: u64,
    pub cbs: u64,
    pub pbs: u64,
    pub cir_period: u64,
    pub cir_bytes_per_period: u64,
    pub pir_period: u64,
    pub pir_bytes_per_period: u64,
}
#[test]
fn bindgen_test_layout_rte_meter_trtcm() {
    assert_eq!(::std::mem::size_of::<rte_meter_trtcm>() , 80usize);
    assert_eq! (::std::mem::align_of::<rte_meter_trtcm>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . time_tc as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . time_tp as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . tc as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . tp as * const _ as
                usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . cbs as * const _ as
                usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . pbs as * const _ as
                usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . cir_period as *
                const _ as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) .
                cir_bytes_per_period as * const _ as usize } , 56usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) . pir_period as *
                const _ as usize } , 64usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_meter_trtcm ) ) .
                pir_bytes_per_period as * const _ as usize } , 72usize);
}
impl Clone for rte_meter_trtcm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * srTCM configuration per metered traffic flow
 *
 * @param m
 *    Pointer to pre-allocated srTCM data structure
 * @param params
 *    User parameters per srTCM metered traffic flow
 * @return
 *    0 upon success, error code otherwise
 */
    pub fn rte_meter_srtcm_config(m: *mut rte_meter_srtcm,
                                  params: *mut rte_meter_srtcm_params)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * trTCM configuration per metered traffic flow
 *
 * @param m
 *    Pointer to pre-allocated trTCM data structure
 * @param params
 *    User parameters per trTCM metered traffic flow
 * @return
 *    0 upon success, error code otherwise
 */
    pub fn rte_meter_trtcm_config(m: *mut rte_meter_trtcm,
                                  params: *mut rte_meter_trtcm_params)
     -> ::std::os::raw::c_int;
}
/**
 * ARP header IPv4 payload.
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct arp_ipv4 {
    /**< sender hardware address */
    pub arp_sha: ether_addr,
    /**< sender IP address */
    pub arp_sip: u32,
    /**< target hardware address */
    pub arp_tha: ether_addr,
    /**< target IP address */
    pub arp_tip: u32,
}
#[test]
fn bindgen_test_layout_arp_ipv4() {
    assert_eq!(::std::mem::size_of::<arp_ipv4>() , 20usize);
    assert_eq! (::std::mem::align_of::<arp_ipv4>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_sha as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_sip as * const _ as
                usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_tha as * const _ as
                usize } , 10usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_ipv4 ) ) . arp_tip as * const _ as
                usize } , 16usize);
}
impl Clone for arp_ipv4 {
    fn clone(&self) -> Self { *self }
}
/**
 * ARP header.
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct arp_hdr {
    pub arp_hrd: u16,
    pub arp_pro: u16,
    pub arp_hln: u8,
    pub arp_pln: u8,
    pub arp_op: u16,
    pub arp_data: arp_ipv4,
}
#[test]
fn bindgen_test_layout_arp_hdr() {
    assert_eq!(::std::mem::size_of::<arp_hdr>() , 28usize);
    assert_eq! (::std::mem::align_of::<arp_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_hrd as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_pro as * const _ as
                usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_hln as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_pln as * const _ as
                usize } , 5usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_op as * const _ as
                usize } , 6usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const arp_hdr ) ) . arp_data as * const _ as
                usize } , 8usize);
}
impl Clone for arp_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * ICMP Header
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: u16,
    pub icmp_ident: u16,
    pub icmp_seq_nb: u16,
}
#[test]
fn bindgen_test_layout_icmp_hdr() {
    assert_eq!(::std::mem::size_of::<icmp_hdr>() , 8usize);
    assert_eq! (::std::mem::align_of::<icmp_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_type as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_code as * const _ as
                usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_cksum as * const _ as
                usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_ident as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const icmp_hdr ) ) . icmp_seq_nb as * const _
                as usize } , 6usize);
}
impl Clone for icmp_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * GRE Header
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct gre_hdr {
    pub _bitfield_1: u16,
    /**< Protocol Type */
    pub proto: u16,
}
#[test]
fn bindgen_test_layout_gre_hdr() {
    assert_eq!(::std::mem::size_of::<gre_hdr>() , 4usize);
    assert_eq! (::std::mem::align_of::<gre_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const gre_hdr ) ) . proto as * const _ as usize
                } , 2usize);
}
impl Clone for gre_hdr {
    fn clone(&self) -> Self { *self }
}
impl gre_hdr {
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (15usize as u16)) >>
                                       0u32) as u16)
        }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        self._bitfield_1 &= !(15usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (15usize as u16);
    }
    #[inline]
    pub fn s(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u16)
        }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn k(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u16)
        }
    }
    #[inline]
    pub fn set_k(&mut self, val: u16) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u16)
        }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn c(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u16)
        }
    }
    #[inline]
    pub fn set_c(&mut self, val: u16) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn ver(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1792usize as u16)) >>
                                       8u32) as u16)
        }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u16) {
        self._bitfield_1 &= !(1792usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 8u32) & (1792usize as u16);
    }
    #[inline]
    pub fn res3(&self) -> u16 {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (63488usize as u16)) >>
                                       11u32) as u16)
        }
    }
    #[inline]
    pub fn set_res3(&mut self, val: u16) {
        self._bitfield_1 &= !(63488usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (63488usize as u16);
    }
}
/**
 * TCP Header
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct tcp_hdr {
    /**< TCP source port. */
    pub src_port: u16,
    /**< TCP destination port. */
    pub dst_port: u16,
    /**< TX data sequence number. */
    pub sent_seq: u32,
    /**< RX data acknowledgement sequence number. */
    pub recv_ack: u32,
    /**< Data offset. */
    pub data_off: u8,
    /**< TCP flags */
    pub tcp_flags: u8,
    /**< RX flow control window. */
    pub rx_win: u16,
    /**< TCP checksum. */
    pub cksum: u16,
    /**< TCP urgent pointer, if any. */
    pub tcp_urp: u16,
}
#[test]
fn bindgen_test_layout_tcp_hdr() {
    assert_eq!(::std::mem::size_of::<tcp_hdr>() , 20usize);
    assert_eq! (::std::mem::align_of::<tcp_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . src_port as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . dst_port as * const _ as
                usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . sent_seq as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . recv_ack as * const _ as
                usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . data_off as * const _ as
                usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . tcp_flags as * const _ as
                usize } , 13usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . rx_win as * const _ as
                usize } , 14usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . cksum as * const _ as usize
                } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_hdr ) ) . tcp_urp as * const _ as
                usize } , 18usize);
}
impl Clone for tcp_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * UDP Header
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct udp_hdr {
    /**< UDP source port. */
    pub src_port: u16,
    /**< UDP destination port. */
    pub dst_port: u16,
    /**< UDP datagram length */
    pub dgram_len: u16,
    /**< UDP datagram checksum */
    pub dgram_cksum: u16,
}
#[test]
fn bindgen_test_layout_udp_hdr() {
    assert_eq!(::std::mem::size_of::<udp_hdr>() , 8usize);
    assert_eq! (::std::mem::align_of::<udp_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . src_port as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . dst_port as * const _ as
                usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . dgram_len as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const udp_hdr ) ) . dgram_cksum as * const _ as
                usize } , 6usize);
}
impl Clone for udp_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * SCTP Header
 */
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct sctp_hdr {
    /**< Source port. */
    pub src_port: u16,
    /**< Destin port. */
    pub dst_port: u16,
    /**< Validation tag. */
    pub tag: u32,
    /**< Checksum. */
    pub cksum: u32,
}
#[test]
fn bindgen_test_layout_sctp_hdr() {
    assert_eq!(::std::mem::size_of::<sctp_hdr>() , 12usize);
    assert_eq! (::std::mem::align_of::<sctp_hdr>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . src_port as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . dst_port as * const _ as
                usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . tag as * const _ as usize
                } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const sctp_hdr ) ) . cksum as * const _ as
                usize } , 8usize);
}
impl Clone for sctp_hdr {
    fn clone(&self) -> Self { *self }
}
/**
 * Structure containing header lengths associated to a packet, filled
 * by rte_net_get_ptype().
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_net_hdr_lens {
    pub l2_len: u8,
    pub l3_len: u8,
    pub l4_len: u8,
    pub tunnel_len: u8,
    pub inner_l2_len: u8,
    pub inner_l3_len: u8,
    pub inner_l4_len: u8,
}
#[test]
fn bindgen_test_layout_rte_net_hdr_lens() {
    assert_eq!(::std::mem::size_of::<rte_net_hdr_lens>() , 7usize);
    assert_eq! (::std::mem::align_of::<rte_net_hdr_lens>() , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . l2_len as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . l3_len as * const
                _ as usize } , 1usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . l4_len as * const
                _ as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . tunnel_len as *
                const _ as usize } , 3usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . inner_l2_len as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . inner_l3_len as *
                const _ as usize } , 5usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_net_hdr_lens ) ) . inner_l4_len as *
                const _ as usize } , 6usize);
}
impl Clone for rte_net_hdr_lens {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Parse an Ethernet packet to get its packet type.
 *
 * This function parses the network headers in mbuf data and return its
 * packet type.
 *
 * If it is provided by the user, it also fills a rte_net_hdr_lens
 * structure that contains the lengths of the parsed network
 * headers. Each length field is valid only if the associated packet
 * type is set. For instance, hdr_lens->l2_len is valid only if
 * (retval & RTE_PTYPE_L2_MASK) != RTE_PTYPE_UNKNOWN.
 *
 * Supported packet types are:
 *   L2: Ether, Vlan, QinQ
 *   L3: IPv4, IPv6
 *   L4: TCP, UDP, SCTP
 *   Tunnels: IPv4, IPv6, Gre, Nvgre
 *
 * @param m
 *   The packet mbuf to be parsed.
 * @param hdr_lens
 *   A pointer to a structure where the header lengths will be returned,
 *   or NULL.
 * @param layers
 *   List of layers to parse. The function will stop at the first
 *   empty layer. Examples:
 *   - To parse all known layers, use RTE_PTYPE_ALL_MASK.
 *   - To parse only L2 and L3, use RTE_PTYPE_L2_MASK | RTE_PTYPE_L3_MASK
 * @return
 *   The packet type of the packet.
 */
    pub fn rte_net_get_ptype(m: *const rte_mbuf,
                             hdr_lens: *mut rte_net_hdr_lens, layers: u32)
     -> u32;
}
pub const RTE_PDUMP_FLAG_RX: _bindgen_ty_52 =
    _bindgen_ty_52::RTE_PDUMP_FLAG_RX;
pub const RTE_PDUMP_FLAG_TX: _bindgen_ty_52 =
    _bindgen_ty_52::RTE_PDUMP_FLAG_TX;
pub const RTE_PDUMP_FLAG_RXTX: _bindgen_ty_52 =
    _bindgen_ty_52::RTE_PDUMP_FLAG_RXTX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_52 {
    RTE_PDUMP_FLAG_RX = 1,
    RTE_PDUMP_FLAG_TX = 2,
    RTE_PDUMP_FLAG_RXTX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pdump_socktype {
    RTE_PDUMP_SOCKET_SERVER = 1,
    RTE_PDUMP_SOCKET_CLIENT = 2,
}
extern "C" {
    /**
 * Initialize packet capturing handling
 *
 * Creates pthread and server socket for handling clients
 * requests to enable/disable rxtx callbacks.
 *
 * @param path
 * directory path for server socket.
 *
 * @return
 *    0 on success, -1 on error
 */
    pub fn rte_pdump_init(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Un initialize packet capturing handling
 *
 * Cancels pthread, close server socket, removes server socket address.
 *
 * @return
 *    0 on success, -1 on error
 */
    pub fn rte_pdump_uninit() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Enables packet capturing on given port and queue.
 *
 * @param port
 *  port on which packet capturing should be enabled.
 * @param queue
 *  queue of a given port on which packet capturing should be enabled.
 *  users should pass on value UINT16_MAX to enable packet capturing on all
 *  queues of a given port.
 * @param flags
 *  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
 *  on which packet capturing should be enabled for a given port and queue.
 * @param ring
 *  ring on which captured packets will be enqueued for user.
 * @param mp
 *  mempool on to which original packets will be mirrored or duplicated.
 * @param filter
 *  place holder for packet filtering.
 *
 * @return
 *    0 on success, -1 on error, rte_errno is set accordingly.
 */
    pub fn rte_pdump_enable(port: u8, queue: u16, flags: u32,
                            ring: *mut rte_ring,
                            mp: *mut rte_mempool_objhdr_rte_mempool,
                            filter: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Disables packet capturing on given port and queue.
 *
 * @param port
 *  port on which packet capturing should be disabled.
 * @param queue
 *  queue of a given port on which packet capturing should be disabled.
 *  users should pass on value UINT16_MAX to disable packet capturing on all
 *  queues of a given port.
 * @param flags
 *  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
 *  on which packet capturing should be enabled for a given port and queue.
 *
 * @return
 *    0 on success, -1 on error, rte_errno is set accordingly.
 */
    pub fn rte_pdump_disable(port: u8, queue: u16, flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Enables packet capturing on given device id and queue.
 * device_id can be name or pci address of device.
 *
 * @param device_id
 *  device id on which packet capturing should be enabled.
 * @param queue
 *  queue of a given device id on which packet capturing should be enabled.
 *  users should pass on value UINT16_MAX to enable packet capturing on all
 *  queues of a given device id.
 * @param flags
 *  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
 *  on which packet capturing should be enabled for a given port and queue.
 * @param ring
 *  ring on which captured packets will be enqueued for user.
 * @param mp
 *  mempool on to which original packets will be mirrored or duplicated.
 * @param filter
 *  place holder for packet filtering.
 *
 * @return
 *    0 on success, -1 on error, rte_errno is set accordingly.
 */
    pub fn rte_pdump_enable_by_deviceid(device_id:
                                            *mut ::std::os::raw::c_char,
                                        queue: u16, flags: u32,
                                        ring: *mut rte_ring,
                                        mp:
                                            *mut rte_mempool_objhdr_rte_mempool,
                                        filter: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Disables packet capturing on given device_id and queue.
 * device_id can be name or pci address of device.
 *
 * @param device_id
 *  pci address or name of the device on which packet capturing
 *  should be disabled.
 * @param queue
 *  queue of a given device on which packet capturing should be disabled.
 *  users should pass on value UINT16_MAX to disable packet capturing on all
 *  queues of a given device id.
 * @param flags
 *  flags specifies RTE_PDUMP_FLAG_RX/RTE_PDUMP_FLAG_TX/RTE_PDUMP_FLAG_RXTX
 *  on which packet capturing should be enabled for a given port and queue.
 *
 * @return
 *    0 on success, -1 on error, rte_errno is set accordingly.
 */
    pub fn rte_pdump_disable_by_deviceid(device_id:
                                             *mut ::std::os::raw::c_char,
                                         queue: u16, flags: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Allows applications to set server and client socket paths.
 * If specified path is null default path will be selected, i.e.
 *"/var/run/" for root user and "$HOME" for non root user.
 * Clients also need to call this API to set their server path if the
 * server path is different from default path.
 * This API is not thread-safe.
 *
 * @param path
 * directory path for server or client socket.
 * @type
 * specifies RTE_PDUMP_SOCKET_SERVER if socket path is for server.
 * (or)
 * specifies RTE_PDUMP_SOCKET_CLIENT if socket path is for client.
 *
 * @return
 * 0 on success, -EINVAL on error
 *
 */
    pub fn rte_pdump_set_socket_dir(path: *const ::std::os::raw::c_char,
                                    type_: rte_pdump_socktype)
     -> ::std::os::raw::c_int;
}
/** Input port statistics */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_in_stats {
    pub n_pkts_in: u64,
    pub n_pkts_drop: u64,
}
#[test]
fn bindgen_test_layout_rte_port_in_stats() {
    assert_eq!(::std::mem::size_of::<rte_port_in_stats>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_port_in_stats>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_stats ) ) . n_pkts_in as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_stats ) ) . n_pkts_drop as *
                const _ as usize } , 8usize);
}
impl Clone for rte_port_in_stats {
    fn clone(&self) -> Self { *self }
}
/**
 * Input port create
 *
 * @param params
 *   Parameters for input port creation
 * @param socket_id
 *   CPU socket ID (e.g. for memory allocation purpose)
 * @return
 *   Handle to input port instance
 */
pub type rte_port_in_op_create =
    ::std::option::Option<unsafe extern "C" fn(params:
                                                   *mut ::std::os::raw::c_void,
                                               socket_id:
                                                   ::std::os::raw::c_int)
                              -> *mut ::std::os::raw::c_void>;
/**
 * Input port free
 *
 * @param port
 *   Handle to input port instance
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_port_in_op_free =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Input port packet burst RX
 *
 * @param port
 *   Handle to input port instance
 * @param pkts
 *   Burst of input packets
 * @param n_pkts
 *   Number of packets in the input burst
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_port_in_op_rx =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               pkts: *mut *mut rte_mbuf,
                                               n_pkts: u32)
                              -> ::std::os::raw::c_int>;
/**
 * Input port stats get
 *
 * @param port
 *   Handle to output port instance
 * @param stats
 *   Handle to port_in stats struct to copy data
 * @param clear
 *   Flag indicating that stats should be cleared after read
 *
 * @return
 *   Error code or 0 on success.
 */
pub type rte_port_in_op_stats_read =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               stats: *mut rte_port_in_stats,
                                               clear: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
/** Input port interface defining the input port operation */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_in_ops {
    /**< Create */
    pub f_create: rte_port_in_op_create,
    /**< Free */
    pub f_free: rte_port_in_op_free,
    /**< Packet RX (packet burst) */
    pub f_rx: rte_port_in_op_rx,
    /**< Stats */
    pub f_stats: rte_port_in_op_stats_read,
}
#[test]
fn bindgen_test_layout_rte_port_in_ops() {
    assert_eq!(::std::mem::size_of::<rte_port_in_ops>() , 32usize);
    assert_eq! (::std::mem::align_of::<rte_port_in_ops>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_create as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_free as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_rx as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_in_ops ) ) . f_stats as * const
                _ as usize } , 24usize);
}
impl Clone for rte_port_in_ops {
    fn clone(&self) -> Self { *self }
}
/** Output port statistics */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_out_stats {
    pub n_pkts_in: u64,
    pub n_pkts_drop: u64,
}
#[test]
fn bindgen_test_layout_rte_port_out_stats() {
    assert_eq!(::std::mem::size_of::<rte_port_out_stats>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_port_out_stats>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_stats ) ) . n_pkts_in as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_stats ) ) . n_pkts_drop as *
                const _ as usize } , 8usize);
}
impl Clone for rte_port_out_stats {
    fn clone(&self) -> Self { *self }
}
/**
 * Output port create
 *
 * @param params
 *   Parameters for output port creation
 * @param socket_id
 *   CPU socket ID (e.g. for memory allocation purpose)
 * @return
 *   Handle to output port instance
 */
pub type rte_port_out_op_create =
    ::std::option::Option<unsafe extern "C" fn(params:
                                                   *mut ::std::os::raw::c_void,
                                               socket_id:
                                                   ::std::os::raw::c_int)
                              -> *mut ::std::os::raw::c_void>;
/**
 * Output port free
 *
 * @param port
 *   Handle to output port instance
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_port_out_op_free =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Output port single packet TX
 *
 * @param port
 *   Handle to output port instance
 * @param pkt
 *   Input packet
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_port_out_op_tx =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               pkt: *mut rte_mbuf)
                              -> ::std::os::raw::c_int>;
/**
 * Output port packet burst TX
 *
 * @param port
 *   Handle to output port instance
 * @param pkts
 *   Burst of input packets specified as array of up to 64 pointers to struct
 *   rte_mbuf
 * @param pkts_mask
 *   64-bit bitmask specifying which packets in the input burst are valid. When
 *   pkts_mask bit n is set, then element n of pkts array is pointing to a
 *   valid packet. Otherwise, element n of pkts array will not be accessed.
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_port_out_op_tx_bulk =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               pkt: *mut *mut rte_mbuf,
                                               pkts_mask: u64)
                              -> ::std::os::raw::c_int>;
/**
 * Output port flush
 *
 * @param port
 *   Handle to output port instance
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_port_out_op_flush =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Output port stats read
 *
 * @param port
 *   Handle to output port instance
 * @param stats
 *   Handle to port_out stats struct to copy data
 * @param clear
 *   Flag indicating that stats should be cleared after read
 *
 * @return
 *   Error code or 0 on success.
 */
pub type rte_port_out_op_stats_read =
    ::std::option::Option<unsafe extern "C" fn(port:
                                                   *mut ::std::os::raw::c_void,
                                               stats: *mut rte_port_out_stats,
                                               clear: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
/** Output port interface defining the output port operation */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_port_out_ops {
    /**< Create */
    pub f_create: rte_port_out_op_create,
    /**< Free */
    pub f_free: rte_port_out_op_free,
    /**< Packet TX (single packet) */
    pub f_tx: rte_port_out_op_tx,
    /**< Packet TX (packet burst) */
    pub f_tx_bulk: rte_port_out_op_tx_bulk,
    /**< Flush */
    pub f_flush: rte_port_out_op_flush,
    /**< Stats */
    pub f_stats: rte_port_out_op_stats_read,
}
#[test]
fn bindgen_test_layout_rte_port_out_ops() {
    assert_eq!(::std::mem::size_of::<rte_port_out_ops>() , 48usize);
    assert_eq! (::std::mem::align_of::<rte_port_out_ops>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_create as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_free as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_tx as * const _
                as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_tx_bulk as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_flush as * const
                _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_port_out_ops ) ) . f_stats as * const
                _ as usize } , 40usize);
}
impl Clone for rte_port_out_ops {
    fn clone(&self) -> Self { *self }
}
/** Lookup table statistics */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_stats {
    pub n_pkts_in: u64,
    pub n_pkts_lookup_miss: u64,
}
#[test]
fn bindgen_test_layout_rte_table_stats() {
    assert_eq!(::std::mem::size_of::<rte_table_stats>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_table_stats>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_stats ) ) . n_pkts_in as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_stats ) ) . n_pkts_lookup_miss
                as * const _ as usize } , 8usize);
}
impl Clone for rte_table_stats {
    fn clone(&self) -> Self { *self }
}
/**
 * Lookup table create
 *
 * @param params
 *   Parameters for lookup table creation. The underlying data structure is
 *   different for each lookup table type.
 * @param socket_id
 *   CPU socket ID (e.g. for memory allocation purpose)
 * @param entry_size
 *   Data size of each lookup table entry (measured in bytes)
 * @return
 *   Handle to lookup table instance
 */
pub type rte_table_op_create =
    ::std::option::Option<unsafe extern "C" fn(params:
                                                   *mut ::std::os::raw::c_void,
                                               socket_id:
                                                   ::std::os::raw::c_int,
                                               entry_size: u32)
                              -> *mut ::std::os::raw::c_void>;
/**
 * Lookup table free
 *
 * @param table
 *   Handle to lookup table instance
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_table_op_free =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Lookup table entry add
 *
 * @param table
 *   Handle to lookup table instance
 * @param key
 *   Lookup key
 * @param entry
 *   Data to be associated with the current key. This parameter has to point to
 *   a valid memory buffer where the first entry_size bytes (table create
 *   parameter) are populated with the data.
 * @param key_found
 *   After successful invocation, *key_found is set to a value different than 0
 *   if the current key is already present in the table and to 0 if not. This
 *   pointer has to be set to a valid memory location before the table entry add
 *   function is called.
 * @param entry_ptr
 *   After successful invocation, *entry_ptr stores the handle to the table
 *   entry containing the data associated with the current key. This handle can
 *   be used to perform further read-write accesses to this entry. This handle
 *   is valid until the key is deleted from the table or the same key is
 *   re-added to the table, typically to associate it with different data. This
 *   pointer has to be set to a valid memory location before the function is
 *   called.
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_table_op_entry_add =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               key:
                                                   *mut ::std::os::raw::c_void,
                                               entry:
                                                   *mut ::std::os::raw::c_void,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entry_ptr:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Lookup table entry delete
 *
 * @param table
 *   Handle to lookup table instance
 * @param key
 *   Lookup key
 * @param key_found
 *   After successful invocation, *key_found is set to a value different than 0
 *   if the current key was present in the table before the delete operation
 *   was performed and to 0 if not. This pointer has to be set to a valid
 *   memory location before the table entry delete function is called.
 * @param entry
 *   After successful invocation, if the key is found in the table (*key found
 *   is different than 0 after function call is completed) and entry points to
 *   a valid buffer (entry is set to a value different than NULL before the
 *   function is called), then the first entry_size bytes (table create
 *   parameter) in *entry store a copy of table entry that contained the data
 *   associated with the current key before the key was deleted.
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_table_op_entry_delete =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               key:
                                                   *mut ::std::os::raw::c_void,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entry:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Lookup table entry add bulk
 *
 * @param table
 *   Handle to lookup table instance
 * @param key
 *   Array containing lookup keys
 * @param entries
 *   Array containing data to be associated with each key. Every item in the
 *   array has to point to a valid memory buffer where the first entry_size
 *   bytes (table create parameter) are populated with the data.
 * @param n_keys
 *   Number of keys to add
 * @param key_found
 *   After successful invocation, key_found for every item in the array is set
 *   to a value different than 0 if the current key is already present in the
 *   table and to 0 if not. This pointer has to be set to a valid memory
 *   location before the table entry add function is called.
 * @param entries_ptr
 *   After successful invocation, array *entries_ptr stores the handle to the
 *   table entry containing the data associated with every key. This handle can
 *   be used to perform further read-write accesses to this entry. This handle
 *   is valid until the key is deleted from the table or the same key is
 *   re-added to the table, typically to associate it with different data. This
 *   pointer has to be set to a valid memory location before the function is
 *   called.
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_table_op_entry_add_bulk =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               keys:
                                                   *mut *mut ::std::os::raw::c_void,
                                               entries:
                                                   *mut *mut ::std::os::raw::c_void,
                                               n_keys: u32,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entries_ptr:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Lookup table entry delete bulk
 *
 * @param table
 *   Handle to lookup table instance
 * @param key
 *   Array containing lookup keys
 * @param n_keys
 *   Number of keys to delete
 * @param key_found
 *   After successful invocation, key_found for every item in the array is set
 *   to a value different than 0if the current key was present in the table
 *   before the delete operation was performed and to 0 if not. This pointer
 *   has to be set to a valid memory location before the table entry delete
 *   function is called.
 * @param entries
 *   If entries pointer is NULL, this pointer is ignored for every entry found.
 *   Else, after successful invocation, if specific key is found in the table
 *   (key_found is different than 0 for this item after function call is
 *   completed) and item of entry array points to a valid buffer (entry is set
 *   to a value different than NULL before the function is called), then the
 *   first entry_size bytes (table create parameter) in *entry store a copy of
 *   table entry that contained the data associated with the current key before
 *   the key was deleted.
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_table_op_entry_delete_bulk =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               keys:
                                                   *mut *mut ::std::os::raw::c_void,
                                               n_keys: u32,
                                               key_found:
                                                   *mut ::std::os::raw::c_int,
                                               entries:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Lookup table lookup
 *
 * @param table
 *   Handle to lookup table instance
 * @param pkts
 *   Burst of input packets specified as array of up to 64 pointers to struct
 *   rte_mbuf
 * @param pkts_mask
 *   64-bit bitmask specifying which packets in the input burst are valid. When
 *   pkts_mask bit n is set, then element n of pkts array is pointing to a
 *   valid packet. Otherwise, element n of pkts array does not point to a valid
 *   packet, therefore it will not be accessed.
 * @param lookup_hit_mask
 *   Once the table lookup operation is completed, this 64-bit bitmask
 *   specifies which of the valid packets in the input burst resulted in lookup
 *   hit. For each valid input packet (pkts_mask bit n is set), the following
 *   are true on lookup hit: lookup_hit_mask bit n is set, element n of entries
 *   array is valid and it points to the lookup table entry that was hit. For
 *   each valid input packet (pkts_mask bit n is set), the following are true
 *   on lookup miss: lookup_hit_mask bit n is not set and element n of entries
 *   array is not valid.
 * @param entries
 *   Once the table lookup operation is completed, this array provides the
 *   lookup table entries that were hit, as described above. It is required
 *   that this array is always pre-allocated by the caller of this function
 *   with exactly 64 elements. The implementation is allowed to speculatively
 *   modify the elements of this array, so elements marked as invalid in
 *   lookup_hit_mask once the table lookup operation is completed might have
 *   been modified by this function.
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_table_op_lookup =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               lookup_hit_mask: *mut u64,
                                               entries:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Lookup table stats read
 *
 * @param table
 *   Handle to lookup table instance
 * @param stats
 *   Handle to table stats struct to copy data
 * @param clear
 *   Flag indicating that stats should be cleared after read
 *
 * @return
 *   Error code or 0 on success.
 */
pub type rte_table_op_stats_read =
    ::std::option::Option<unsafe extern "C" fn(table:
                                                   *mut ::std::os::raw::c_void,
                                               stats: *mut rte_table_stats,
                                               clear: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
/** Lookup table interface defining the lookup table operation */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_ops {
    /**< Create */
    pub f_create: rte_table_op_create,
    /**< Free */
    pub f_free: rte_table_op_free,
    /**< Entry add */
    pub f_add: rte_table_op_entry_add,
    /**< Entry delete */
    pub f_delete: rte_table_op_entry_delete,
    /**< Add entry bulk */
    pub f_add_bulk: rte_table_op_entry_add_bulk,
    /**< Delete entry bulk */
    pub f_delete_bulk: rte_table_op_entry_delete_bulk,
    /**< Lookup */
    pub f_lookup: rte_table_op_lookup,
    /**< Stats */
    pub f_stats: rte_table_op_stats_read,
}
#[test]
fn bindgen_test_layout_rte_table_ops() {
    assert_eq!(::std::mem::size_of::<rte_table_ops>() , 64usize);
    assert_eq! (::std::mem::align_of::<rte_table_ops>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_create as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_free as * const _
                as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_add as * const _ as
                usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_delete as * const _
                as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_add_bulk as * const
                _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_delete_bulk as *
                const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_lookup as * const _
                as usize } , 48usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_ops ) ) . f_stats as * const _
                as usize } , 56usize);
}
impl Clone for rte_table_ops {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pipeline([u8; 0]);
/** Parameters for pipeline creation  */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_params {
    /** Pipeline name */
    pub name: *const ::std::os::raw::c_char,
    /** CPU socket ID where memory for the pipeline and its elements (ports
	and tables) should be allocated */
    pub socket_id: ::std::os::raw::c_int,
    /** Offset within packet meta-data to port_id to be used by action
	"Send packet to output port read from packet meta-data". Has to be
	4-byte aligned. */
    pub offset_port_id: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_params>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_params ) ) . name as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_params ) ) . socket_id as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_params ) ) . offset_port_id
                as * const _ as usize } , 12usize);
}
impl Clone for rte_pipeline_params {
    fn clone(&self) -> Self { *self }
}
/** Pipeline port in stats. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_in_stats {
    /** Port in stats. */
    pub stats: rte_port_in_stats,
    /** Number of packets dropped by action handler. */
    pub n_pkts_dropped_by_ah: u64,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_in_stats() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_in_stats>() , 24usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_in_stats>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_stats ) ) . stats as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_stats ) ) .
                n_pkts_dropped_by_ah as * const _ as usize } , 16usize);
}
impl Clone for rte_pipeline_port_in_stats {
    fn clone(&self) -> Self { *self }
}
/** Pipeline port out stats. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_out_stats {
    /** Port out stats. */
    pub stats: rte_port_out_stats,
    /** Number of packets dropped by action handler. */
    pub n_pkts_dropped_by_ah: u64,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_out_stats() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_out_stats>() ,
               24usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_out_stats>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_stats ) ) . stats
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_stats ) ) .
                n_pkts_dropped_by_ah as * const _ as usize } , 16usize);
}
impl Clone for rte_pipeline_port_out_stats {
    fn clone(&self) -> Self { *self }
}
/** Pipeline table stats. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_stats {
    /** Table stats. */
    pub stats: rte_table_stats,
    /** Number of packets dropped by lookup hit action handler. */
    pub n_pkts_dropped_by_lkp_hit_ah: u64,
    /** Number of packets dropped by lookup miss action handler. */
    pub n_pkts_dropped_by_lkp_miss_ah: u64,
    /** Number of packets dropped by pipeline in behalf of this
	 * table based on action specified in table entry. */
    pub n_pkts_dropped_lkp_hit: u64,
    /** Number of packets dropped by pipeline in behalf of this
	 *  table based on action specified in table entry. */
    pub n_pkts_dropped_lkp_miss: u64,
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_stats() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_stats>() , 48usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_stats>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) . stats as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_by_lkp_hit_ah as * const _ as usize } ,
                16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_by_lkp_miss_ah as * const _ as usize } ,
                24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_lkp_hit as * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_stats ) ) .
                n_pkts_dropped_lkp_miss as * const _ as usize } , 40usize);
}
impl Clone for rte_pipeline_table_stats {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Pipeline create
 *
 * @param params
 *   Parameters for pipeline creation
 * @return
 *   Handle to pipeline instance on success or NULL otherwise
 */
    pub fn rte_pipeline_create(params: *mut rte_pipeline_params)
     -> *mut rte_pipeline;
}
extern "C" {
    /**
 * Pipeline free
 *
 * @param p
 *   Handle to pipeline instance
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_free(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline consistency check
 *
 * @param p
 *   Handle to pipeline instance
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_check(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline run
 *
 * @param p
 *   Handle to pipeline instance
 * @return
 *   Number of packets read and processed
 */
    pub fn rte_pipeline_run(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline flush
 *
 * @param p
 *   Handle to pipeline instance
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_flush(p: *mut rte_pipeline) -> ::std::os::raw::c_int;
}
#[repr(u32)]
/** Reserved actions */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rte_pipeline_action {
    RTE_PIPELINE_ACTION_DROP = 0,
    RTE_PIPELINE_ACTION_PORT = 1,
    RTE_PIPELINE_ACTION_PORT_META = 2,
    RTE_PIPELINE_ACTION_TABLE = 3,
    RTE_PIPELINE_ACTIONS = 4,
}
/**
 * Head format for the table entry of any pipeline table. For any given
 * pipeline table, all table entries should have the same size and format. For
 * any given pipeline table, the table entry has to start with a head of this
 * structure, which contains the reserved actions and their associated
 * meta-data, and then optionally continues with user actions and their
 * associated meta-data. As all the currently defined reserved actions are
 * mutually exclusive, only one reserved action can be set per table entry.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_entry {
    /** Reserved action */
    pub action: rte_pipeline_action,
    pub __bindgen_anon_1: rte_pipeline_table_entry__bindgen_ty_1,
    /** Start of table entry area for user defined actions and meta-data */
    pub action_data: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_entry__bindgen_ty_1 {
    /** Output port ID (meta-data for "Send packet to output port"
		action) */
    pub port_id: __BindgenUnionField<u32>,
    /** Table ID (meta-data for "Send packet to table" action) */
    pub table_id: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_entry__bindgen_ty_1>()
               , 4usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_entry__bindgen_ty_1>()
                , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry__bindgen_ty_1 )
                ) . port_id as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry__bindgen_ty_1 )
                ) . table_id as * const _ as usize } , 0usize);
}
impl Clone for rte_pipeline_table_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_entry() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_entry>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_entry>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry ) ) . action as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_entry ) ) .
                action_data as * const _ as usize } , 8usize);
}
impl Clone for rte_pipeline_table_entry {
    fn clone(&self) -> Self { *self }
}
/**
 * Pipeline table action handler on lookup hit
 *
 * The action handler can decide to drop packets by resetting the associated
 * packet bit in the pkts_mask parameter. In this case, the action handler is
 * required not to free the packet buffer, which will be freed eventually by
 * the pipeline.
 *
 * @param p
 *   Handle to pipeline instance
 * @param pkts
 *   Burst of input packets specified as array of up to 64 pointers to struct
 *   rte_mbuf
 * @param pkts_mask
 *   64-bit bitmask specifying which packets in the input burst are valid. When
 *   pkts_mask bit n is set, then element n of pkts array is pointing to a
 *   valid packet and element n of entries array is pointing to a valid table
 *   entry associated with the packet, with the association typically done by
 *   the table lookup operation. Otherwise, element n of pkts array and element
 *   n of entries array will not be accessed.
 * @param entries
 *   Set of table entries specified as array of up to 64 pointers to struct
 *   rte_pipeline_table_entry
 * @param arg
 *   Opaque parameter registered by the user at the pipeline table creation
 *   time
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_pipeline_table_action_handler_hit =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               entries:
                                                   *mut *mut rte_pipeline_table_entry,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/**
 * Pipeline table action handler on lookup miss
 *
 * The action handler can decide to drop packets by resetting the associated
 * packet bit in the pkts_mask parameter. In this case, the action handler is
 * required not to free the packet buffer, which will be freed eventually by
 * the pipeline.
 *
 * @param p
 *   Handle to pipeline instance
 * @param pkts
 *   Burst of input packets specified as array of up to 64 pointers to struct
 *   rte_mbuf
 * @param pkts_mask
 *   64-bit bitmask specifying which packets in the input burst are valid. When
 *   pkts_mask bit n is set, then element n of pkts array is pointing to a
 *   valid packet. Otherwise, element n of pkts array will not be accessed.
 * @param entry
 *   Single table entry associated with all the valid packets from the input
 *   burst, specified as pointer to struct rte_pipeline_table_entry.
 *   This entry is the pipeline table default entry that is associated by the
 *   table lookup operation with the input packets that have resulted in lookup
 *   miss.
 * @param arg
 *   Opaque parameter registered by the user at the pipeline table creation
 *   time
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_pipeline_table_action_handler_miss =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               entry:
                                                   *mut rte_pipeline_table_entry,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/** Parameters for pipeline table creation. Action handlers have to be either
    both enabled or both disabled (they can be disabled by setting them to
    NULL). */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_table_params {
    /** Table operations (specific to each table type) */
    pub ops: *mut rte_table_ops,
    /** Opaque param to be passed to the table create operation when
	invoked */
    pub arg_create: *mut ::std::os::raw::c_void,
    /** Callback function to execute the user actions on input packets in
	case of lookup hit */
    pub f_action_hit: rte_pipeline_table_action_handler_hit,
    /** Callback function to execute the user actions on input packets in
	case of lookup miss */
    pub f_action_miss: rte_pipeline_table_action_handler_miss,
    /** Opaque parameter to be passed to lookup hit and/or lookup miss
	action handlers when invoked */
    pub arg_ah: *mut ::std::os::raw::c_void,
    /** Memory size to be reserved per table entry for storing the user
	actions and their meta-data */
    pub action_data_size: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_table_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_table_params>() , 48usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_table_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) . ops as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                arg_create as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                f_action_hit as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                f_action_miss as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) . arg_ah as
                * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_table_params ) ) .
                action_data_size as * const _ as usize } , 40usize);
}
impl Clone for rte_pipeline_table_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Pipeline table create
 *
 * @param p
 *   Handle to pipeline instance
 * @param params
 *   Parameters for pipeline table creation
 * @param table_id
 *   Table ID. Valid only within the scope of table IDs of the current
 *   pipeline. Only returned after a successful invocation.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_create(p: *mut rte_pipeline,
                                     params: *mut rte_pipeline_table_params,
                                     table_id: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline table default entry add
 *
 * The contents of the table default entry is updated with the provided actions
 * and meta-data. When the default entry is not configured (by using this
 * function), the built-in default entry has the action "Drop" and meta-data
 * set to all-zeros.
 *
 * @param p
 *   Handle to pipeline instance
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @param default_entry
 *   New contents for the table default entry
 * @param default_entry_ptr
 *   On successful invocation, pointer to the default table entry which can be
 *   used for further read-write accesses to this table entry. This pointer
 *   is valid until the default entry is deleted or re-added.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_default_entry_add(p: *mut rte_pipeline,
                                                table_id: u32,
                                                default_entry:
                                                    *mut rte_pipeline_table_entry,
                                                default_entry_ptr:
                                                    *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline table default entry delete
 *
 * The new contents of the table default entry is set to reserved action "Drop
 * the packet" with meta-data cleared (i.e. set to all-zeros).
 *
 * @param p
 *   Handle to pipeline instance
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @param entry
 *   On successful invocation, when entry points to a valid buffer, the
 *   previous contents of the table default entry (as it was just before the
 *   delete operation) is copied to this buffer
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_default_entry_delete(p: *mut rte_pipeline,
                                                   table_id: u32,
                                                   entry:
                                                       *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline table entry add
 *
 * @param p
 *   Handle to pipeline instance
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @param key
 *   Table entry key
 * @param entry
 *   New contents for the table entry identified by key
 * @param key_found
 *   On successful invocation, set to TRUE (value different than 0) if key was
 *   already present in the table before the add operation and to FALSE (value
 *   0) if not
 * @param entry_ptr
 *   On successful invocation, pointer to the table entry associated with key.
 *   This can be used for further read-write accesses to this table entry and
 *   is valid until the key is deleted from the table or re-added (usually for
 *   associating different actions and/or action meta-data to the current key)
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_entry_add(p: *mut rte_pipeline, table_id: u32,
                                        key: *mut ::std::os::raw::c_void,
                                        entry: *mut rte_pipeline_table_entry,
                                        key_found: *mut ::std::os::raw::c_int,
                                        entry_ptr:
                                            *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline table entry delete
 *
 * @param p
 *   Handle to pipeline instance
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @param key
 *   Table entry key
 * @param key_found
 *   On successful invocation, set to TRUE (value different than 0) if key was
 *   found in the table before the delete operation and to FALSE (value 0) if
 *   not
 * @param entry
 *   On successful invocation, when key is found in the table and entry points
 *   to a valid buffer, the table entry contents (as it was before the delete
 *   was performed) is copied to this buffer
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_entry_delete(p: *mut rte_pipeline,
                                           table_id: u32,
                                           key: *mut ::std::os::raw::c_void,
                                           key_found:
                                               *mut ::std::os::raw::c_int,
                                           entry:
                                               *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline table entry add bulk
 *
 * @param p
 *   Handle to pipeline instance
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @param keys
 *   Array containing table entry keys
 * @param entries
 *   Array containung new contents for every table entry identified by key
 * @param n_keys
 *   Number of keys to add
 * @param key_found
 *   On successful invocation, key_found for every item in the array is set to
 *   TRUE (value different than 0) if key was already present in the table
 *   before the add operation and to FALSE (value 0) if not
 * @param entries_ptr
 *   On successful invocation, array *entries_ptr stores pointer to every table
 *   entry associated with key. This can be used for further read-write accesses
 *   to this table entry and is valid until the key is deleted from the table or
 *   re-added (usually for associating different actions and/or action meta-data
 *   to the current key)
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_entry_add_bulk(p: *mut rte_pipeline,
                                             table_id: u32,
                                             keys:
                                                 *mut *mut ::std::os::raw::c_void,
                                             entries:
                                                 *mut *mut rte_pipeline_table_entry,
                                             n_keys: u32,
                                             key_found:
                                                 *mut ::std::os::raw::c_int,
                                             entries_ptr:
                                                 *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline table entry delete bulk
 *
 * @param p
 *   Handle to pipeline instance
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @param keys
 *   Array containing table entry keys
 * @param n_keys
 *   Number of keys to delete
 * @param key_found
 *   On successful invocation, key_found for every item in the array is set to
 *   TRUE (value different than 0) if key was found in the table before the
 *   delete operation and to FALSE (value 0) if not
 * @param entries
 *   If entries pointer is NULL, this pointer is ignored for every entry found.
 *   Else, after successful invocation, if specific key is found in the table
 *   and entry points to a valid buffer, the table entry contents (as it was
 *   before the delete was performed) is copied to this buffer.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_entry_delete_bulk(p: *mut rte_pipeline,
                                                table_id: u32,
                                                keys:
                                                    *mut *mut ::std::os::raw::c_void,
                                                n_keys: u32,
                                                key_found:
                                                    *mut ::std::os::raw::c_int,
                                                entries:
                                                    *mut *mut rte_pipeline_table_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read pipeline table stats.
 *
 * This function reads table statistics identified by *table_id* of given
 * pipeline *p*.
 *
 * @param p
 *   Handle to pipeline instance.
 * @param table_id
 *   Port ID what stats will be returned.
 * @param stats
 *   Statistics buffer.
 * @param clear
 *   If not 0 clear stats after reading.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_table_stats_read(p: *mut rte_pipeline, table_id: u32,
                                         stats: *mut rte_pipeline_table_stats,
                                         clear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
/**
 * Pipeline input port action handler
 *
 * The action handler can decide to drop packets by resetting the associated
 * packet bit in the pkts_mask parameter. In this case, the action handler is
 * required not to free the packet buffer, which will be freed eventually by
 * the pipeline.
 *
 * @param p
 *   Handle to pipeline instance
 * @param pkts
 *   Burst of input packets specified as array of up to 64 pointers to struct
 *   rte_mbuf
 * @param n
 *   Number of packets in the input burst. This parameter specifies that
 *   elements 0 to (n-1) of pkts array are valid.
 * @param arg
 *   Opaque parameter registered by the user at the pipeline table creation
 *   time
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_pipeline_port_in_action_handler =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               n: u32,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/** Parameters for pipeline input port creation */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_in_params {
    /** Input port operations (specific to each table type) */
    pub ops: *mut rte_port_in_ops,
    /** Opaque parameter to be passed to create operation when invoked */
    pub arg_create: *mut ::std::os::raw::c_void,
    /** Callback function to execute the user actions on input packets.
		Disabled if set to NULL. */
    pub f_action: rte_pipeline_port_in_action_handler,
    /** Opaque parameter to be passed to the action handler when invoked */
    pub arg_ah: *mut ::std::os::raw::c_void,
    /** Recommended burst size for the RX operation(in number of pkts) */
    pub burst_size: u32,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_in_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_in_params>() ,
               40usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_in_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) . ops as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) .
                arg_create as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) .
                f_action as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) . arg_ah
                as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_in_params ) ) .
                burst_size as * const _ as usize } , 32usize);
}
impl Clone for rte_pipeline_port_in_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Pipeline input port create
 *
 * @param p
 *   Handle to pipeline instance
 * @param params
 *   Parameters for pipeline input port creation
 * @param port_id
 *   Input port ID. Valid only within the scope of input port IDs of the
 *   current pipeline. Only returned after a successful invocation.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_in_create(p: *mut rte_pipeline,
                                       params:
                                           *mut rte_pipeline_port_in_params,
                                       port_id: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline input port connect to table
 *
 * @param p
 *   Handle to pipeline instance
 * @param port_id
 *   Port ID (returned by previous invocation of pipeline input port create)
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_in_connect_to_table(p: *mut rte_pipeline,
                                                 port_id: u32, table_id: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline input port enable
 *
 * @param p
 *   Handle to pipeline instance
 * @param port_id
 *   Port ID (returned by previous invocation of pipeline input port create)
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_in_enable(p: *mut rte_pipeline, port_id: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Pipeline input port disable
 *
 * @param p
 *   Handle to pipeline instance
 * @param port_id
 *   Port ID (returned by previous invocation of pipeline input port create)
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_in_disable(p: *mut rte_pipeline, port_id: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read pipeline port in stats.
 *
 * This function reads port in statistics identified by *port_id* of given
 * pipeline *p*.
 *
 * @param p
 *   Handle to pipeline instance.
 * @param port_id
 *   Port ID what stats will be returned.
 * @param stats
 *   Statistics buffer.
 * @param clear
 *   If not 0 clear stats after reading.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_in_stats_read(p: *mut rte_pipeline, port_id: u32,
                                           stats:
                                               *mut rte_pipeline_port_in_stats,
                                           clear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
/**
 * Pipeline output port action handler
 *
 * The action handler can decide to drop packets by resetting the associated
 * packet bit in the pkts_mask parameter. In this case, the action handler is
 * required not to free the packet buffer, which will be freed eventually by
 * the pipeline.
 *
 * @param p
 *   Handle to pipeline instance
 * @param pkts
 *   Burst of input packets specified as array of up to 64 pointers to struct
 *   rte_mbuf
 * @param pkts_mask
 *   64-bit bitmask specifying which packets in the input burst are valid. When
 *   pkts_mask bit n is set, then element n of pkts array is pointing to a
 *   valid packet. Otherwise, element n of pkts array will not be accessed.
 * @param arg
 *   Opaque parameter registered by the user at the pipeline table creation
 *   time
 * @return
 *   0 on success, error code otherwise
 */
pub type rte_pipeline_port_out_action_handler =
    ::std::option::Option<unsafe extern "C" fn(p: *mut rte_pipeline,
                                               pkts: *mut *mut rte_mbuf,
                                               pkts_mask: u64,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
/** Parameters for pipeline output port creation. The action handlers have to
be either both enabled or both disabled (by setting them to NULL). When
enabled, the pipeline selects between them at different moments, based on the
number of packets that have to be sent to the same output port. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_pipeline_port_out_params {
    /** Output port operations (specific to each table type) */
    pub ops: *mut rte_port_out_ops,
    /** Opaque parameter to be passed to create operation when invoked */
    pub arg_create: *mut ::std::os::raw::c_void,
    /** Callback function executing the user actions on bust of input
	packets */
    pub f_action: rte_pipeline_port_out_action_handler,
    /** Opaque parameter to be passed to the action handler when invoked */
    pub arg_ah: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_pipeline_port_out_params() {
    assert_eq!(::std::mem::size_of::<rte_pipeline_port_out_params>() ,
               32usize);
    assert_eq! (::std::mem::align_of::<rte_pipeline_port_out_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) . ops as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) .
                arg_create as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) .
                f_action as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_pipeline_port_out_params ) ) . arg_ah
                as * const _ as usize } , 24usize);
}
impl Clone for rte_pipeline_port_out_params {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Pipeline output port create
 *
 * @param p
 *   Handle to pipeline instance
 * @param params
 *   Parameters for pipeline output port creation
 * @param port_id
 *   Output port ID. Valid only within the scope of output port IDs of the
 *   current pipeline. Only returned after a successful invocation.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_out_create(p: *mut rte_pipeline,
                                        params:
                                            *mut rte_pipeline_port_out_params,
                                        port_id: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Read pipeline port out stats.
 *
 * This function reads port out statistics identified by *port_id* of given
 * pipeline *p*.
 *
 * @param p
 *   Handle to pipeline instance.
 * @param port_id
 *   Port ID what stats will be returned.
 * @param stats
 *   Statistics buffer.
 * @param clear
 *   If not 0 clear stats after reading.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_out_stats_read(p: *mut rte_pipeline,
                                            port_id: u32,
                                            stats:
                                                *mut rte_pipeline_port_out_stats,
                                            clear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Action handler packet insert to output port
 *
 * This function can be called by any input/output port or table action handler
 * to send a packet out through one of the pipeline output ports. This packet is
 * generated by the action handler, i.e. this packet is not part of the burst of
 * packets read from one of the pipeline input ports and currently processed by
 * the pipeline (this packet is not an element of the pkts array input parameter
 * of the action handler).
 *
 * @param p
 *   Handle to pipeline instance
 * @param port_id
 *   Output port ID (returned by previous invocation of pipeline output port
 *   create) to send the packet specified by pkt
 * @param pkt
 *   New packet generated by the action handler
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_port_out_packet_insert(p: *mut rte_pipeline,
                                               port_id: u32,
                                               pkt: *mut rte_mbuf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Action handler packet hijack
 *
 * This function can be called by any input/output port or table action handler
 * to hijack selected packets from the burst of packets read from one of the
 * pipeline input ports and currently processed by the pipeline. The hijacked
 * packets are removed from any further pipeline processing, with the action
 * handler now having the full ownership for these packets.
 *
 * The action handler can further send the hijacked packets out through any
 * pipeline output port by calling the rte_pipeline_ah_port_out_packet_insert()
 * function. The action handler can also drop these packets by calling the
 * rte_pktmbuf_free() function, although a better alternative is provided by
 * the action handler using the rte_pipeline_ah_packet_drop() function.
 *
 * @param p
 *   Handle to pipeline instance
 * @param pkts_mask
 *   64-bit bitmask specifying which of the packets handed over for processing
 *   to the action handler is to be hijacked by the action handler. When
 *   pkts_mask bit n is set, then element n of the pkts array (input argument to
 *   the action handler) is hijacked.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_ah_packet_hijack(p: *mut rte_pipeline, pkts_mask: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Action handler packet drop
 *
 * This function is called by the pipeline action handlers (port in/out, table)
 * to drop the packets selected using packet mask.
 *
 * This function can be called by any input/output port or table action handler
 * to drop selected packets from the burst of packets read from one of the
 * pipeline input ports and currently processed by the pipeline. The dropped
 * packets are removed from any further pipeline processing and the packet
 * buffers are eventually freed to their buffer pool.
 *
 * This function updates the drop statistics counters correctly, therefore the
 * recommended approach for dropping packets by the action handlers is to call
 * this function as opposed to the action handler hijacking the packets first
 * and then dropping them invisibly to the pipeline (by using the
 * rte_pktmbuf_free() function).
 *
 * @param p
 *   Handle to pipeline instance
 * @param pkts_mask
 *   64-bit bitmask specifying which of the packets handed over for processing
 *   to the action handler is to be dropped by the action handler. When
 *   pkts_mask bit n is set, then element n of the pkts array (input argument to
 *   the action handler) is dropped.
 * @return
 *   0 on success, error code otherwise
 */
    pub fn rte_pipeline_ah_packet_drop(p: *mut rte_pipeline, pkts_mask: u64)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum power_management_env {
    PM_ENV_NOT_SET = 0,
    PM_ENV_ACPI_CPUFREQ = 1,
    PM_ENV_KVM_VM = 2,
}
extern "C" {
    /**
 * Set the default power management implementation. If this is not called prior
 * to rte_power_init(), then auto-detect of the environment will take place.
 * It is not thread safe.
 *
 * @param env
 *  env. The environment in which to initialise Power Management for.
 *
 * @return
 *  - 0 on success.
 *  - Negative on error.
 */
    pub fn rte_power_set_env(env: power_management_env)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Unset the global environment configuration.
 * This can only be called after all threads have completed.
 */
    pub fn rte_power_unset_env();
}
extern "C" {
    /**
 * Get the default power management implementation.
 *
 * @return
 *  power_management_env The configured environment.
 */
    pub fn rte_power_get_env() -> power_management_env;
}
extern "C" {
    /**
 * Initialize power management for a specific lcore. If rte_power_set_env() has
 * not been called then an auto-detect of the environment will start and
 * initialise the corresponding resources.
 *
 * @param lcore_id
 *  lcore id.
 *
 * @return
 *  - 0 on success.
 *  - Negative on error.
 */
    pub fn rte_power_init(lcore_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Exit power management on a specific lcore. This will call the environment
 * dependent exit function.
 *
 * @param lcore_id
 *  lcore id.
 *
 * @return
 *  - 0 on success.
 *  - Negative on error.
 */
    pub fn rte_power_exit(lcore_id: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
/**
 * Get the available frequencies of a specific lcore.
 * Function pointer definition. Review each environments
 * specific documentation for usage.
 *
 * @param lcore_id
 *  lcore id.
 * @param freqs
 *  The buffer array to save the frequencies.
 * @param num
 *  The number of frequencies to get.
 *
 * @return
 *  The number of available frequencies.
 */
pub type rte_power_freqs_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint,
                                               freqs: *mut u32, num: u32)
                              -> ::std::os::raw::c_uint>;
/**
 * Return the current index of available frequencies of a specific lcore.
 * Function pointer definition. Review each environments
 * specific documentation for usage.
 *
 * @param lcore_id
 *  lcore id.
 *
 * @return
 *  The current index of available frequencies.
 */
pub type rte_power_get_freq_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_uint>;
/**
 * Set the new frequency for a specific lcore by indicating the index of
 * available frequencies.
 * Function pointer definition. Review each environments
 * specific documentation for usage.
 *
 * @param lcore_id
 *  lcore id.
 * @param index
 *  The index of available frequencies.
 *
 * @return
 *  - 1 on success with frequency changed.
 *  - 0 on success without frequency changed.
 *  - Negative on error.
 */
pub type rte_power_set_freq_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint,
                                               index: u32)
                              -> ::std::os::raw::c_int>;
/**
 * Function pointer definition for generic frequency change functions. Review
 * each environments specific documentation for usage.
 *
 * @param lcore_id
 *  lcore id.
 *
 * @return
 *  - 1 on success with frequency changed.
 *  - 0 on success without frequency changed.
 *  - Negative on error.
 */
pub type rte_power_freq_change_t =
    ::std::option::Option<unsafe extern "C" fn(lcore_id:
                                                   ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_reorder_buffer([u8; 0]);
extern "C" {
    /**
 * Create a new reorder buffer instance
 *
 * Allocate memory and initialize a new reorder buffer in that
 * memory, returning the reorder buffer pointer to the user
 *
 * @param name
 *   The name to be given to the reorder buffer instance.
 * @param socket_id
 *   The NUMA node on which the memory for the reorder buffer
 *   instance is to be reserved.
 * @param size
 *   Max number of elements that can be stored in the reorder buffer
 * @return
 *   The initialized reorder buffer instance, or NULL on error
 *   On error case, rte_errno will be set appropriately:
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 *    - EINVAL - invalid parameters
 */
    pub fn rte_reorder_create(name: *const ::std::os::raw::c_char,
                              socket_id: ::std::os::raw::c_uint,
                              size: ::std::os::raw::c_uint)
     -> *mut rte_reorder_buffer;
}
extern "C" {
    /**
 * Initializes given reorder buffer instance
 *
 * @param b
 *   Reorder buffer instance to initialize
 * @param bufsize
 *   Size of the reorder buffer
 * @param name
 *   The name to be given to the reorder buffer
 * @param size
 *   Number of elements that can be stored in reorder buffer
 * @return
 *   The initialized reorder buffer instance, or NULL on error
 *   On error case, rte_errno will be set appropriately:
 *    - EINVAL - invalid parameters
 */
    pub fn rte_reorder_init(b: *mut rte_reorder_buffer,
                            bufsize: ::std::os::raw::c_uint,
                            name: *const ::std::os::raw::c_char,
                            size: ::std::os::raw::c_uint)
     -> *mut rte_reorder_buffer;
}
extern "C" {
    /**
 * Find an existing reorder buffer instance
 * and return a pointer to it.
 *
 * @param name
 *   Name of the reorder buffer instacne as passed to rte_reorder_create()
 * @return
 *   Pointer to reorder buffer instance or NULL if object not found with rte_errno
 *   set appropriately. Possible rte_errno values include:
 *    - ENOENT - required entry not available to return.
 *    reorder instance list
 */
    pub fn rte_reorder_find_existing(name: *const ::std::os::raw::c_char)
     -> *mut rte_reorder_buffer;
}
extern "C" {
    /**
 * Reset the given reorder buffer instance with initial values.
 *
 * @param b
 *   Reorder buffer instance which has to be reset
 */
    pub fn rte_reorder_reset(b: *mut rte_reorder_buffer);
}
extern "C" {
    /**
 * Free reorder buffer instance.
 *
 * @param b
 *   reorder buffer instance
 * @return
 *   None
 */
    pub fn rte_reorder_free(b: *mut rte_reorder_buffer);
}
extern "C" {
    /**
 * Insert given mbuf in reorder buffer in its correct position
 *
 * The given mbuf is to be reordered relative to other mbufs in the system.
 * The mbuf must contain a sequence number which is then used to place
 * the buffer in the correct position in the reorder buffer. Reordered
 * packets can later be taken from the buffer using the rte_reorder_drain()
 * API.
 *
 * @param b
 *   Reorder buffer where the mbuf has to be inserted.
 * @param mbuf
 *   mbuf of packet that needs to be inserted in reorder buffer.
 * @return
 *   0 on success
 *   -1 on error
 *   On error case, rte_errno will be set appropriately:
 *    - ENOSPC - Cannot move existing mbufs from reorder buffer to accommodate
 *      ealry mbuf, but it can be accomodated by performing drain and then insert.
 *    - ERANGE - Too early or late mbuf which is vastly out of range of expected
 *      window should be ingnored without any handling.
 */
    pub fn rte_reorder_insert(b: *mut rte_reorder_buffer, mbuf: *mut rte_mbuf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Fetch reordered buffers
 *
 * Returns a set of in-order buffers from the reorder buffer structure. Gaps
 * may be present in the sequence numbers of the mbuf if packets have been
 * delayed too long before reaching the reorder window, or have been previously
 * dropped by the system.
 *
 * @param b
 *   Reorder buffer instance from which packets are to be drained
 * @param mbufs
 *   array of mbufs where reordered packets will be inserted from reorder buffer
 * @param max_mbufs
 *   the number of elements in the mbufs array.
 * @return
 *   number of mbuf pointers written to mbufs. 0 <= N < max_mbufs.
 */
    pub fn rte_reorder_drain(b: *mut rte_reorder_buffer,
                             mbufs: *mut *mut rte_mbuf,
                             max_mbufs: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_subport_params {
    /**< Rate (measured in bytes per second) */
    pub tb_rate: u32,
    /**< Size (measured in credits) */
    pub tb_size: u32,
    pub tc_rate: [u32; 4usize],
    pub tc_period: u32,
}
#[test]
fn bindgen_test_layout_rte_sched_subport_params() {
    assert_eq!(::std::mem::size_of::<rte_sched_subport_params>() , 28usize);
    assert_eq! (::std::mem::align_of::<rte_sched_subport_params>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tb_rate as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tb_size as
                * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tc_rate as
                * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_params ) ) . tc_period
                as * const _ as usize } , 24usize);
}
impl Clone for rte_sched_subport_params {
    fn clone(&self) -> Self { *self }
}
/** Subport statistics */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_subport_stats {
    pub n_pkts_tc: [u32; 4usize],
    pub n_pkts_tc_dropped: [u32; 4usize],
    pub n_bytes_tc: [u32; 4usize],
    pub n_bytes_tc_dropped: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_sched_subport_stats() {
    assert_eq!(::std::mem::size_of::<rte_sched_subport_stats>() , 64usize);
    assert_eq! (::std::mem::align_of::<rte_sched_subport_stats>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) . n_pkts_tc
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) .
                n_pkts_tc_dropped as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) . n_bytes_tc
                as * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_subport_stats ) ) .
                n_bytes_tc_dropped as * const _ as usize } , 48usize);
}
impl Clone for rte_sched_subport_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_pipe_params {
    /**< Rate (measured in bytes per second) */
    pub tb_rate: u32,
    /**< Size (measured in credits) */
    pub tb_size: u32,
    pub tc_rate: [u32; 4usize],
    pub tc_period: u32,
    /**< WRR weights */
    pub wrr_weights: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_sched_pipe_params() {
    assert_eq!(::std::mem::size_of::<rte_sched_pipe_params>() , 44usize);
    assert_eq! (::std::mem::align_of::<rte_sched_pipe_params>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tb_rate as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tb_size as *
                const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tc_rate as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . tc_period as
                * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_pipe_params ) ) . wrr_weights
                as * const _ as usize } , 28usize);
}
impl Clone for rte_sched_pipe_params {
    fn clone(&self) -> Self { *self }
}
/** Queue statistics */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_queue_stats {
    /**< Packets successfully written */
    pub n_pkts: u32,
    /**< Packets dropped */
    pub n_pkts_dropped: u32,
    /**< Bytes successfully written */
    pub n_bytes: u32,
    /**< Bytes dropped */
    pub n_bytes_dropped: u32,
}
#[test]
fn bindgen_test_layout_rte_sched_queue_stats() {
    assert_eq!(::std::mem::size_of::<rte_sched_queue_stats>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_sched_queue_stats>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) . n_pkts as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) .
                n_pkts_dropped as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) . n_bytes as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_queue_stats ) ) .
                n_bytes_dropped as * const _ as usize } , 12usize);
}
impl Clone for rte_sched_queue_stats {
    fn clone(&self) -> Self { *self }
}
/** Port configuration parameters. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_sched_port_params {
    /**< String to be associated */
    pub name: *const ::std::os::raw::c_char,
    /**< CPU socket ID */
    pub socket: ::std::os::raw::c_int,
    /**< Output port rate
					  * (measured in bytes per second) */
    pub rate: u32,
    /**< Maximum Ethernet frame size
					  * (measured in bytes).
					  * Should not include the framing overhead. */
    pub mtu: u32,
    /**< Framing overhead per packet
					  * (measured in bytes) */
    pub frame_overhead: u32,
    /**< Number of subports */
    pub n_subports_per_port: u32,
    /**< Number of pipes per subport */
    pub n_pipes_per_subport: u32,
    pub qsize: [u16; 4usize],
    pub pipe_profiles: *mut rte_sched_pipe_params,
    /**< Profiles in the pipe profile table */
    pub n_pipe_profiles: u32,
}
#[test]
fn bindgen_test_layout_rte_sched_port_params() {
    assert_eq!(::std::mem::size_of::<rte_sched_port_params>() , 56usize);
    assert_eq! (::std::mem::align_of::<rte_sched_port_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . name as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . socket as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . rate as *
                const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . mtu as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                frame_overhead as * const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                n_subports_per_port as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                n_pipes_per_subport as * const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . qsize as *
                const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) . pipe_profiles
                as * const _ as usize } , 40usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_sched_port_params ) ) .
                n_pipe_profiles as * const _ as usize } , 48usize);
}
impl Clone for rte_sched_port_params {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sched_port([u8; 0]);
extern "C" {
    /**
 * Hierarchical scheduler port configuration
 *
 * @param params
 *   Port scheduler configuration parameter structure
 * @return
 *   Handle to port scheduler instance upon success or NULL otherwise.
 */
    pub fn rte_sched_port_config(params: *mut rte_sched_port_params)
     -> *mut rte_sched_port;
}
extern "C" {
    /**
 * Hierarchical scheduler port free
 *
 * @param port
 *   Handle to port scheduler instance
 */
    pub fn rte_sched_port_free(port: *mut rte_sched_port);
}
extern "C" {
    /**
 * Hierarchical scheduler subport configuration
 *
 * @param port
 *   Handle to port scheduler instance
 * @param subport_id
 *   Subport ID
 * @param params
 *   Subport configuration parameters
 * @return
 *   0 upon success, error code otherwise
 */
    pub fn rte_sched_subport_config(port: *mut rte_sched_port,
                                    subport_id: u32,
                                    params: *mut rte_sched_subport_params)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Hierarchical scheduler pipe configuration
 *
 * @param port
 *   Handle to port scheduler instance
 * @param subport_id
 *   Subport ID
 * @param pipe_id
 *   Pipe ID within subport
 * @param pipe_profile
 *   ID of port-level pre-configured pipe profile
 * @return
 *   0 upon success, error code otherwise
 */
    pub fn rte_sched_pipe_config(port: *mut rte_sched_port, subport_id: u32,
                                 pipe_id: u32, pipe_profile: i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Hierarchical scheduler memory footprint size per port
 *
 * @param params
 *   Port scheduler configuration parameter structure
 * @return
 *   Memory footprint size in bytes upon success, 0 otherwise
 */
    pub fn rte_sched_port_get_memory_footprint(params:
                                                   *mut rte_sched_port_params)
     -> u32;
}
extern "C" {
    /**
 * Hierarchical scheduler subport statistics read
 *
 * @param port
 *   Handle to port scheduler instance
 * @param subport_id
 *   Subport ID
 * @param stats
 *   Pointer to pre-allocated subport statistics structure where the statistics
 *   counters should be stored
 * @param tc_ov
 *   Pointer to pre-allocated 4-entry array where the oversubscription status for
 *   each of the 4 subport traffic classes should be stored.
 * @return
 *   0 upon success, error code otherwise
 */
    pub fn rte_sched_subport_read_stats(port: *mut rte_sched_port,
                                        subport_id: u32,
                                        stats: *mut rte_sched_subport_stats,
                                        tc_ov: *mut u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Hierarchical scheduler queue statistics read
 *
 * @param port
 *   Handle to port scheduler instance
 * @param queue_id
 *   Queue ID within port scheduler
 * @param stats
 *   Pointer to pre-allocated subport statistics structure where the statistics
 *   counters should be stored
 * @param qlen
 *   Pointer to pre-allocated variable where the current queue length
 *   should be stored.
 * @return
 *   0 upon success, error code otherwise
 */
    pub fn rte_sched_queue_read_stats(port: *mut rte_sched_port,
                                      queue_id: u32,
                                      stats: *mut rte_sched_queue_stats,
                                      qlen: *mut u16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Scheduler hierarchy path write to packet descriptor. Typically
 * called by the packet classification stage.
 *
 * @param pkt
 *   Packet descriptor handle
 * @param subport
 *   Subport ID
 * @param pipe
 *   Pipe ID within subport
 * @param traffic_class
 *   Traffic class ID within pipe (0 .. 3)
 * @param queue
 *   Queue ID within pipe traffic class (0 .. 3)
 * @param color
 *   Packet color set
 */
    pub fn rte_sched_port_pkt_write(pkt: *mut rte_mbuf, subport: u32,
                                    pipe: u32, traffic_class: u32, queue: u32,
                                    color: rte_meter_color);
}
extern "C" {
    /**
 * Scheduler hierarchy path read from packet descriptor (struct
 * rte_mbuf). Typically called as part of the hierarchical scheduler
 * enqueue operation. The subport, pipe, traffic class and queue
 * parameters need to be pre-allocated by the caller.
 *
 * @param pkt
 *   Packet descriptor handle
 * @param subport
 *   Subport ID
 * @param pipe
 *   Pipe ID within subport
 * @param traffic_class
 *   Traffic class ID within pipe (0 .. 3)
 * @param queue
 *   Queue ID within pipe traffic class (0 .. 3)
 *
 */
    pub fn rte_sched_port_pkt_read_tree_path(pkt: *const rte_mbuf,
                                             subport: *mut u32,
                                             pipe: *mut u32,
                                             traffic_class: *mut u32,
                                             queue: *mut u32);
}
extern "C" {
    pub fn rte_sched_port_pkt_read_color(pkt: *const rte_mbuf)
     -> rte_meter_color;
}
extern "C" {
    /**
 * Hierarchical scheduler port enqueue. Writes up to n_pkts to port
 * scheduler and returns the number of packets actually written. For
 * each packet, the port scheduler queue to write the packet to is
 * identified by reading the hierarchy path from the packet
 * descriptor; if the queue is full or congested and the packet is not
 * written to the queue, then the packet is automatically dropped
 * without any action required from the caller.
 *
 * @param port
 *   Handle to port scheduler instance
 * @param pkts
 *   Array storing the packet descriptor handles
 * @param n_pkts
 *   Number of packets to enqueue from the pkts array into the port scheduler
 * @return
 *   Number of packets successfully enqueued
 */
    pub fn rte_sched_port_enqueue(port: *mut rte_sched_port,
                                  pkts: *mut *mut rte_mbuf, n_pkts: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Hierarchical scheduler port dequeue. Reads up to n_pkts from the
 * port scheduler and stores them in the pkts array and returns the
 * number of packets actually read.  The pkts array needs to be
 * pre-allocated by the caller with at least n_pkts entries.
 *
 * @param port
 *   Handle to port scheduler instance
 * @param pkts
 *   Pre-allocated packet descriptor array where the packets dequeued
 *   from the port
 *   scheduler should be stored
 * @param n_pkts
 *   Number of packets to dequeue from the port scheduler
 * @return
 *   Number of packets successfully dequeued and placed in the pkts array
 */
    pub fn rte_sched_port_dequeue(port: *mut rte_sched_port,
                                  pkts: *mut *mut rte_mbuf, n_pkts: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * Find best rational approximation
 *
 * @param alpha
 *   Rational number to approximate
 * @param d
 *   Precision for the rational approximation
 * @param p
 *   Pointer to pre-allocated space where the numerator of the rational
 *   approximation will be stored when operation is successful
 * @param q
 *   Pointer to pre-allocated space where the denominator of the rational
 *   approximation will be stored when operation is successful
 * @return
 *   0 upon success, error code otherwise
 */
    pub fn rte_approx(alpha: f64, d: f64, p: *mut u32, q: *mut u32)
     -> ::std::os::raw::c_int;
}
/** Bitmap data structure */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_bitmap {
    /**< Bitmap array1 */
    pub array1: *mut u64,
    /**< Bitmap array2 */
    pub array2: *mut u64,
    /**< Number of 64-bit slabs in array1 that are actually used */
    pub array1_size: u32,
    /**< Number of 64-bit slabs in array2 */
    pub array2_size: u32,
    /**< Bitmap scan: Index of current array1 slab */
    pub index1: u32,
    /**< Bitmap scan: Offset of current bit within current array1 slab */
    pub offset1: u32,
    /**< Bitmap scan: Index of current array2 slab */
    pub index2: u32,
    /**< Bitmap scan: Go/stop condition for current array2 cache line */
    pub go2: u32,
    pub memory: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_rte_bitmap() {
    assert_eq!(::std::mem::size_of::<rte_bitmap>() , 40usize);
    assert_eq! (::std::mem::align_of::<rte_bitmap>() , 8usize);
}
impl Clone for rte_bitmap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_reciprocal {
    pub m: u32,
    pub sh1: u8,
    pub sh2: u8,
}
#[test]
fn bindgen_test_layout_rte_reciprocal() {
    assert_eq!(::std::mem::size_of::<rte_reciprocal>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_reciprocal>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_reciprocal ) ) . m as * const _ as
                usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_reciprocal ) ) . sh1 as * const _ as
                usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_reciprocal ) ) . sh2 as * const _ as
                usize } , 5usize);
}
impl Clone for rte_reciprocal {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z20rte_reciprocal_valuej"]
    pub fn rte_reciprocal_value(d: u32) -> rte_reciprocal;
}
/**
 * RED configuration parameters passed by user
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_red_params {
    /**< Minimum threshold for queue (max_th) */
    pub min_th: u16,
    /**< Maximum threshold for queue (max_th) */
    pub max_th: u16,
    /**< Inverse of packet marking probability maximum value (maxp = 1 / maxp_inv) */
    pub maxp_inv: u16,
    /**< Negated log2 of queue weight (wq = 1 / (2 ^ wq_log2)) */
    pub wq_log2: u16,
}
#[test]
fn bindgen_test_layout_rte_red_params() {
    assert_eq!(::std::mem::size_of::<rte_red_params>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_red_params>() , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . min_th as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . max_th as * const _
                as usize } , 2usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . maxp_inv as * const
                _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_params ) ) . wq_log2 as * const _
                as usize } , 6usize);
}
impl Clone for rte_red_params {
    fn clone(&self) -> Self { *self }
}
/**
 * RED configuration parameters
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_red_config {
    /**< min_th scaled in fixed-point format */
    pub min_th: u32,
    /**< max_th scaled in fixed-point format */
    pub max_th: u32,
    /**< Precomputed constant value used for pa calculation (scaled in fixed-point format) */
    pub pa_const: u32,
    /**< maxp_inv */
    pub maxp_inv: u8,
    /**< wq_log2 */
    pub wq_log2: u8,
}
#[test]
fn bindgen_test_layout_rte_red_config() {
    assert_eq!(::std::mem::size_of::<rte_red_config>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_red_config>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . min_th as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . max_th as * const _
                as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . pa_const as * const
                _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . maxp_inv as * const
                _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red_config ) ) . wq_log2 as * const _
                as usize } , 13usize);
}
impl Clone for rte_red_config {
    fn clone(&self) -> Self { *self }
}
/**
 * RED run-time data
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_red {
    /**< Average queue size (avg), scaled in fixed-point format */
    pub avg: u32,
    /**< Number of packets since last marked packet (count) */
    pub count: u32,
    /**< Start of the queue idle time (q_time) */
    pub q_time: u64,
}
#[test]
fn bindgen_test_layout_rte_red() {
    assert_eq!(::std::mem::size_of::<rte_red>() , 16usize);
    assert_eq! (::std::mem::align_of::<rte_red>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red ) ) . avg as * const _ as usize }
                , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red ) ) . count as * const _ as usize
                } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_red ) ) . q_time as * const _ as
                usize } , 8usize);
}
impl Clone for rte_red {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * @brief Initialises run-time data
 *
 * @param red [in,out] data pointer to RED runtime data
 *
 * @return Operation status
 * @retval 0 success
 * @retval !0 error
 */
    pub fn rte_red_rt_data_init(red: *mut rte_red) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Configures a single RED configuration parameter structure.
 *
 * @param red_cfg [in,out] config pointer to a RED configuration parameter structure
 * @param wq_log2 [in]  log2 of the filter weight, valid range is:
 *             RTE_RED_WQ_LOG2_MIN <= wq_log2 <= RTE_RED_WQ_LOG2_MAX
 * @param min_th [in] queue minimum threshold in number of packets
 * @param max_th [in] queue maximum threshold in number of packets
 * @param maxp_inv [in] inverse maximum mark probability
 *
 * @return Operation status
 * @retval 0 success
 * @retval !0 error
 */
    pub fn rte_red_config_init(red_cfg: *mut rte_red_config, wq_log2: u16,
                               min_th: u16, max_th: u16, maxp_inv: u16)
     -> ::std::os::raw::c_int;
}
/** ACL table parameters */
#[repr(C)]
pub struct rte_table_acl_params {
    /** Name */
    pub name: *const ::std::os::raw::c_char,
    /** Maximum number of ACL rules in the table */
    pub n_rules: u32,
    /** Number of fields in the ACL rule specification */
    pub n_rule_fields: u32,
    /** Format specification of the fields of the ACL rule */
    pub field_format: [rte_acl_field_def; 64usize],
}
#[test]
fn bindgen_test_layout_rte_table_acl_params() {
    assert_eq!(::std::mem::size_of::<rte_table_acl_params>() , 528usize);
    assert_eq! (::std::mem::align_of::<rte_table_acl_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . name as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . n_rules as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . n_rule_fields
                as * const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_params ) ) . field_format
                as * const _ as usize } , 16usize);
}
/** ACL rule specification for entry add operation */
#[repr(C)]
pub struct rte_table_acl_rule_add_params {
    /** ACL rule priority, with 0 as the highest priority */
    pub priority: i32,
    /** Values for the fields of the ACL rule to be added to the table */
    pub field_value: [rte_acl_field; 64usize],
}
#[test]
fn bindgen_test_layout_rte_table_acl_rule_add_params() {
    assert_eq!(::std::mem::size_of::<rte_table_acl_rule_add_params>() ,
               1032usize);
    assert_eq! (::std::mem::align_of::<rte_table_acl_rule_add_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_rule_add_params ) ) .
                priority as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_rule_add_params ) ) .
                field_value as * const _ as usize } , 8usize);
}
/** ACL rule specification for entry delete operation */
#[repr(C)]
pub struct rte_table_acl_rule_delete_params {
    /** Values for the fields of the ACL rule to be deleted from table */
    pub field_value: [rte_acl_field; 64usize],
}
#[test]
fn bindgen_test_layout_rte_table_acl_rule_delete_params() {
    assert_eq!(::std::mem::size_of::<rte_table_acl_rule_delete_params>() ,
               1024usize);
    assert_eq! (::std::mem::align_of::<rte_table_acl_rule_delete_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_acl_rule_delete_params ) ) .
                field_value as * const _ as usize } , 0usize);
}
/** Array table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_array_params {
    /** Number of array entries. Has to be a power of two. */
    pub n_entries: u32,
    /** Byte offset within input packet meta-data where lookup key (i.e. the
	    array entry index) is located. */
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_array_params() {
    assert_eq!(::std::mem::size_of::<rte_table_array_params>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_table_array_params>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_array_params ) ) . n_entries as
                * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_array_params ) ) . offset as *
                const _ as usize } , 4usize);
}
impl Clone for rte_table_array_params {
    fn clone(&self) -> Self { *self }
}
/** Array table key format */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_array_key {
    /** Array entry index */
    pub pos: u32,
}
#[test]
fn bindgen_test_layout_rte_table_array_key() {
    assert_eq!(::std::mem::size_of::<rte_table_array_key>() , 4usize);
    assert_eq! (::std::mem::align_of::<rte_table_array_key>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_array_key ) ) . pos as * const
                _ as usize } , 0usize);
}
impl Clone for rte_table_array_key {
    fn clone(&self) -> Self { *self }
}
/** Hash function */
pub type rte_table_hash_op_hash =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *mut ::std::os::raw::c_void,
                                               key_size: u32, seed: u64)
                              -> ::std::os::raw::c_ulong>;
/**
 * Hash tables with configurable key size
 *
 */
/** Extendible bucket hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_ext_params {
    /** Key size (number of bytes) */
    pub key_size: u32,
    /** Maximum number of keys */
    pub n_keys: u32,
    /** Number of hash table buckets. Each bucket stores up to 4 keys. */
    pub n_buckets: u32,
    /** Number of hash table bucket extensions. Each bucket extension has
	space for 4 keys and each bucket can have 0, 1 or more extensions. */
    pub n_buckets_ext: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed value for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_ext_params>() , 40usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_ext_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . key_size
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . n_keys as
                * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . n_buckets
                as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) .
                n_buckets_ext as * const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . f_hash as
                * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) . seed as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) .
                signature_offset as * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_ext_params ) ) .
                key_offset as * const _ as usize } , 36usize);
}
impl Clone for rte_table_hash_ext_params {
    fn clone(&self) -> Self { *self }
}
/** LRU hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_lru_params {
    /** Key size (number of bytes) */
    pub key_size: u32,
    /** Maximum number of keys */
    pub n_keys: u32,
    /** Number of hash table buckets. Each bucket stores up to 4 keys. */
    pub n_buckets: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed value for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_lru_params>() , 40usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_lru_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . key_size
                as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . n_keys as
                * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . n_buckets
                as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . f_hash as
                * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) . seed as *
                const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) .
                signature_offset as * const _ as usize } , 32usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_lru_params ) ) .
                key_offset as * const _ as usize } , 36usize);
}
impl Clone for rte_table_hash_lru_params {
    fn clone(&self) -> Self { *self }
}
/**
 * 8-byte key hash tables
 *
 */
/** LRU hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key8_lru_params {
    /** Maximum number of entries (and keys) in the table */
    pub n_entries: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
    /** Bit-mask to be AND-ed to the key on lookup */
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key8_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key8_lru_params>() ,
               40usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_key8_lru_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                n_entries as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                f_hash as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) . seed
                as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                signature_offset as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                key_offset as * const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_lru_params ) ) .
                key_mask as * const _ as usize } , 32usize);
}
impl Clone for rte_table_hash_key8_lru_params {
    fn clone(&self) -> Self { *self }
}
/** Extendible bucket hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key8_ext_params {
    /** Maximum number of entries (and keys) in the table */
    pub n_entries: u32,
    /** Number of entries (and keys) for hash table bucket extensions. Each
		bucket is extended in increments of 4 keys. */
    pub n_entries_ext: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
    /** Bit-mask to be AND-ed to the key on lookup */
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key8_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key8_ext_params>() ,
               40usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_key8_ext_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                n_entries as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                n_entries_ext as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                f_hash as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) . seed
                as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                signature_offset as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                key_offset as * const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key8_ext_params ) ) .
                key_mask as * const _ as usize } , 32usize);
}
impl Clone for rte_table_hash_key8_ext_params {
    fn clone(&self) -> Self { *self }
}
/**
 * 16-byte key hash tables
 *
 */
/** LRU hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key16_lru_params {
    /** Maximum number of entries (and keys) in the table */
    pub n_entries: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
    /** Bit-mask to be AND-ed to the key on lookup */
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key16_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key16_lru_params>() ,
               40usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_key16_lru_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                n_entries as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                f_hash as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                seed as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                signature_offset as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                key_offset as * const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_lru_params ) ) .
                key_mask as * const _ as usize } , 32usize);
}
impl Clone for rte_table_hash_key16_lru_params {
    fn clone(&self) -> Self { *self }
}
/** Extendible bucket hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key16_ext_params {
    /** Maximum number of entries (and keys) in the table */
    pub n_entries: u32,
    /** Number of entries (and keys) for hash table bucket extensions. Each
	bucket is extended in increments of 4 keys. */
    pub n_entries_ext: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
    /** Bit-mask to be AND-ed to the key on lookup */
    pub key_mask: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key16_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key16_ext_params>() ,
               40usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_key16_ext_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                n_entries as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                n_entries_ext as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                f_hash as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                seed as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                signature_offset as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                key_offset as * const _ as usize } , 28usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key16_ext_params ) ) .
                key_mask as * const _ as usize } , 32usize);
}
impl Clone for rte_table_hash_key16_ext_params {
    fn clone(&self) -> Self { *self }
}
/**
 * 32-byte key hash tables
 *
 */
/** LRU hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key32_lru_params {
    /** Maximum number of entries (and keys) in the table */
    pub n_entries: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key32_lru_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key32_lru_params>() ,
               32usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_key32_lru_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                n_entries as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                f_hash as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                seed as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                signature_offset as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_lru_params ) ) .
                key_offset as * const _ as usize } , 28usize);
}
impl Clone for rte_table_hash_key32_lru_params {
    fn clone(&self) -> Self { *self }
}
/** Extendible bucket hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_key32_ext_params {
    /** Maximum number of entries (and keys) in the table */
    pub n_entries: u32,
    /** Number of entries (and keys) for hash table bucket extensions. Each
		bucket is extended in increments of 4 keys. */
    pub n_entries_ext: u32,
    /** Hash function */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed for the hash function */
    pub seed: u64,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_hash_key32_ext_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_key32_ext_params>() ,
               32usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_key32_ext_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                n_entries as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                n_entries_ext as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                f_hash as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                seed as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                signature_offset as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_key32_ext_params ) ) .
                key_offset as * const _ as usize } , 28usize);
}
impl Clone for rte_table_hash_key32_ext_params {
    fn clone(&self) -> Self { *self }
}
/** Cuckoo hash table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_hash_cuckoo_params {
    /** Key size (number of bytes */
    pub key_size: u32,
    /** Maximum number of hash table entries */
    pub n_keys: u32,
    /** Hash function used to calculate hash */
    pub f_hash: rte_table_hash_op_hash,
    /** Seed value or Init value used by f_hash */
    pub seed: u32,
    /** Byte offset within packet meta-data where the 4-byte key signature
	is located. Valid for pre-computed key signature tables, ignored for
	do-sig tables. */
    pub signature_offset: u32,
    /** Byte offset within packet meta-data where the key is located */
    pub key_offset: u32,
    /** Hash table name */
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_table_hash_cuckoo_params() {
    assert_eq!(::std::mem::size_of::<rte_table_hash_cuckoo_params>() ,
               40usize);
    assert_eq! (::std::mem::align_of::<rte_table_hash_cuckoo_params>() ,
                8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) .
                key_size as * const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . n_keys
                as * const _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . f_hash
                as * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . seed
                as * const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) .
                signature_offset as * const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) .
                key_offset as * const _ as usize } , 24usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_hash_cuckoo_params ) ) . name
                as * const _ as usize } , 32usize);
}
impl Clone for rte_table_hash_cuckoo_params {
    fn clone(&self) -> Self { *self }
}
/** LPM table parameters */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_lpm_params {
    /** Table name */
    pub name: *const ::std::os::raw::c_char,
    /** Maximum number of LPM rules (i.e. IP routes) */
    pub n_rules: u32,
    pub number_tbl8s: u32,
    pub flags: ::std::os::raw::c_int,
    /** Number of bytes at the start of the table entry that uniquely
	identify the entry. Cannot be bigger than table entry size. */
    pub entry_unique_size: u32,
    /** Byte offset within input packet meta-data where lookup key (i.e.
	the destination IP address) is located. */
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_rte_table_lpm_params() {
    assert_eq!(::std::mem::size_of::<rte_table_lpm_params>() , 32usize);
    assert_eq! (::std::mem::align_of::<rte_table_lpm_params>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . name as *
                const _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . n_rules as *
                const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . number_tbl8s
                as * const _ as usize } , 12usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . flags as *
                const _ as usize } , 16usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) .
                entry_unique_size as * const _ as usize } , 20usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_params ) ) . offset as *
                const _ as usize } , 24usize);
}
impl Clone for rte_table_lpm_params {
    fn clone(&self) -> Self { *self }
}
/** LPM table rule (i.e. route), specified as IP prefix. While the key used by
the lookup operation is the destination IP address (read from the input packet
meta-data), the entry add and entry delete operations work with LPM rules, with
each rule covering for a multitude of lookup keys (destination IP addresses)
that share the same data (next hop). */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rte_table_lpm_key {
    /** IP address */
    pub ip: u32,
    /** IP address depth. The most significant "depth" bits of the IP
	address specify the network part of the IP address, while the rest of
	the bits specify the host part of the address and are ignored for the
	purpose of route specification. */
    pub depth: u8,
}
#[test]
fn bindgen_test_layout_rte_table_lpm_key() {
    assert_eq!(::std::mem::size_of::<rte_table_lpm_key>() , 8usize);
    assert_eq! (::std::mem::align_of::<rte_table_lpm_key>() , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_key ) ) . ip as * const _
                as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const rte_table_lpm_key ) ) . depth as * const
                _ as usize } , 4usize);
}
impl Clone for rte_table_lpm_key {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize);
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize);
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize);
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
