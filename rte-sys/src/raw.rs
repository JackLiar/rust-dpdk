/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
pub const RTE_EXEC_ENV: &'static [u8; 9usize] = b"linuxapp\0";
pub const RTE_ARCH: &'static [u8; 7usize] = b"x86_64\0";
pub const RTE_MACHINE: &'static [u8; 7usize] = b"native\0";
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\0";
pub const RTE_NEXT_ABI: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_LIBRTE_EAL: u32 = 1;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_NUMA_NODES: u32 = 8;
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 64;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 131072;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_LOG_HISTORY: u32 = 256;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_EAL_IGB_UIO: u32 = 1;
pub const RTE_EAL_VFIO: u32 = 1;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_ENABLE_AVX: u32 = 1;
pub const RTE_EAL_PMD_PATH: &'static [u8; 1usize] = b"\0";
pub const RTE_LIBRTE_EAL_VMWARE_TSC_MAP_SUPPORT: u32 = 1;
pub const RTE_LIBRTE_PCI: u32 = 1;
pub const RTE_LIBRTE_KVARGS: u32 = 1;
pub const RTE_LIBRTE_ETHER: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_LIBRTE_COMMON_DPAAX: u32 = 1;
pub const RTE_LIBRTE_IFPGA_BUS: u32 = 1;
pub const RTE_LIBRTE_PCI_BUS: u32 = 1;
pub const RTE_LIBRTE_VDEV_BUS: u32 = 1;
pub const RTE_LIBRTE_ARK_PMD: u32 = 1;
pub const RTE_LIBRTE_ARK_PAD_TX: u32 = 1;
pub const RTE_LIBRTE_ATLANTIC_PMD: u32 = 1;
pub const RTE_LIBRTE_AXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_BNXT_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_TPUT: u32 = 1;
pub const RTE_LIBRTE_DPAA_BUS: u32 = 1;
pub const RTE_LIBRTE_DPAA_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA_PMD: u32 = 1;
pub const RTE_LIBRTE_FSLMC_BUS: u32 = 1;
pub const RTE_LIBRTE_DPAA2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA2_USE_PHYS_IOVA: u32 = 1;
pub const RTE_LIBRTE_DPAA2_PMD: u32 = 1;
pub const RTE_LIBRTE_ENETC_PMD: u32 = 1;
pub const RTE_LIBRTE_ENA_PMD: u32 = 1;
pub const RTE_LIBRTE_ENIC_PMD: u32 = 1;
pub const RTE_LIBRTE_EM_PMD: u32 = 1;
pub const RTE_LIBRTE_IGB_PMD: u32 = 1;
pub const RTE_LIBRTE_IXGBE_PMD: u32 = 1;
pub const RTE_IXGBE_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_PMD: u32 = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_LIBRTE_FM10K_PMD: u32 = 1;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_AVF_PMD: u32 = 1;
pub const RTE_LIBRTE_AVF_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_NFP_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\0";
pub const RTE_LIBRTE_SFC_EFX_PMD: u32 = 1;
pub const RTE_LIBRTE_THUNDERX_NICVF_PMD: u32 = 1;
pub const RTE_LIBRTE_LIO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_PMD: u32 = 1;
pub const RTE_LIBRTE_AVP_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: u32 = 1;
pub const RTE_VIRTIO_USER: u32 = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: u32 = 1;
pub const RTE_LIBRTE_PMD_AF_PACKET: u32 = 1;
pub const RTE_LIBRTE_PMD_BOND: u32 = 1;
pub const RTE_LIBRTE_PMD_FAILSAFE: u32 = 1;
pub const RTE_LIBRTE_VMBUS: u32 = 1;
pub const RTE_LIBRTE_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_VDEV_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_PMD_NULL: u32 = 1;
pub const RTE_LIBRTE_PMD_RING: u32 = 1;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_PMD_SOFTNIC: u32 = 1;
pub const RTE_LIBRTE_PMD_TAP: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_LIBRTE_BBDEV: u32 = 1;
pub const RTE_BBDEV_MAX_DEVS: u32 = 128;
pub const RTE_LIBRTE_PMD_BBDEV_NULL: u32 = 1;
pub const RTE_LIBRTE_CRYPTODEV: u32 = 1;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_PMD_CAAM_JR: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_SEC: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA_SEC: u32 = 1;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_PMD_OCTEONTX_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_PMD_QAT: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_LIBRTE_PMD_VIRTIO_CRYPTO: u32 = 1;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_PMD_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_LIBRTE_PMD_NULL_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_SECURITY: u32 = 1;
pub const RTE_LIBRTE_COMPRESSDEV: u32 = 1;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_PMD_OCTEONTX_ZIPVF: u32 = 1;
pub const RTE_LIBRTE_EVENTDEV: u32 = 1;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 64;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_LIBRTE_PMD_SKELETON_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SW_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DSW_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX_SSOVF: u32 = 1;
pub const RTE_LIBRTE_PMD_OPDL_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_RAWDEV: u32 = 1;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 10;
pub const RTE_LIBRTE_PMD_SKELETON_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_CMDIF_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_QDMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_IFPGA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_RING: u32 = 1;
pub const RTE_LIBRTE_MEMPOOL: u32 = 1;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_DRIVER_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_DRIVER_MEMPOOL_RING: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_STACK: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_MBUF: u32 = 1;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] = b"ring_mp_mc\0";
pub const RTE_MBUF_REFCNT_ATOMIC: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_LIBRTE_TIMER: u32 = 1;
pub const RTE_LIBRTE_CFGFILE: u32 = 1;
pub const RTE_LIBRTE_CMDLINE: u32 = 1;
pub const RTE_LIBRTE_HASH: u32 = 1;
pub const RTE_LIBRTE_EFD: u32 = 1;
pub const RTE_LIBRTE_MEMBER: u32 = 1;
pub const RTE_LIBRTE_JOBSTATS: u32 = 1;
pub const RTE_LIBRTE_METRICS: u32 = 1;
pub const RTE_LIBRTE_BITRATE: u32 = 1;
pub const RTE_LIBRTE_LATENCY_STATS: u32 = 1;
pub const RTE_LIBRTE_LPM: u32 = 1;
pub const RTE_LIBRTE_ACL: u32 = 1;
pub const RTE_LIBRTE_POWER: u32 = 1;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_LIBRTE_NET: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 4;
pub const RTE_LIBRTE_GRO: u32 = 1;
pub const RTE_LIBRTE_GSO: u32 = 1;
pub const RTE_LIBRTE_METER: u32 = 1;
pub const RTE_LIBRTE_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIBRTE_SCHED: u32 = 1;
pub const RTE_SCHED_PORT_N_GRINDERS: u32 = 8;
pub const RTE_LIBRTE_DISTRIBUTOR: u32 = 1;
pub const RTE_LIBRTE_REORDER: u32 = 1;
pub const RTE_LIBRTE_PORT: u32 = 1;
pub const RTE_LIBRTE_TABLE: u32 = 1;
pub const RTE_LIBRTE_PIPELINE: u32 = 1;
pub const RTE_LIBRTE_KNI: u32 = 1;
pub const RTE_LIBRTE_PMD_KNI: u32 = 1;
pub const RTE_KNI_KMOD: u32 = 1;
pub const RTE_KNI_PREEMPT_DEFAULT: u32 = 1;
pub const RTE_LIBRTE_PDUMP: u32 = 1;
pub const RTE_LIBRTE_VHOST: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIBRTE_PMD_VHOST: u32 = 1;
pub const RTE_LIBRTE_IFC_PMD: u32 = 1;
pub const RTE_LIBRTE_BPF: u32 = 1;
pub const RTE_APP_TEST: u32 = 1;
pub const RTE_PROC_INFO: u32 = 1;
pub const RTE_TEST_PMD: u32 = 1;
pub const RTE_TEST_BBDEV: u32 = 1;
pub const RTE_APP_CRYPTO_PERF: u32 = 1;
pub const RTE_APP_EVENTDEV: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_64: u32 = 1;
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const RTE_VER_PREFIX: &'static [u8; 5usize] = b"DPDK\0";
pub const RTE_VER_YEAR: u32 = 18;
pub const RTE_VER_MONTH: u32 = 11;
pub const RTE_VER_MINOR: u32 = 0;
pub const RTE_VER_SUFFIX: &'static [u8; 1usize] = b"\0";
pub const RTE_VER_RELEASE: u32 = 16;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_KNI: u32 = 8;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_GSO: u32 = 20;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_MEMSEG_FLAG_DO_NOT_FREE: u32 = 1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const ALIGNMENT_MASK: u32 = 31;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const __ELASTERROR: u32 = 1000;
pub const MPLOCKED: &'static [u8; 8usize] = b"lock ; \0";
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_MP_MAX_FD_NUM: u32 = 8;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const LCORE_ID_ANY: u32 = 4294967295;
pub const _RTE_RTM_H_: u32 = 1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &'static [u8; 9usize] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &'static [u8; 4usize] = b"RG_\0";
pub const RING_F_SP_ENQ: u32 = 1;
pub const RING_F_SC_DEQ: u32 = 2;
pub const RING_F_EXACT_SZ: u32 = 4;
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const __IS_SP: u32 = 1;
pub const __IS_MP: u32 = 0;
pub const __IS_SC: u32 = 1;
pub const __IS_MC: u32 = 0;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &'static [u8; 4usize] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &'static [u8; 6usize] = b"MP_%s\0";
pub const MEMPOOL_PG_NUM_DEFAULT: u32 = 1;
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const MEMPOOL_F_NO_PHYS_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const PKT_RX_VLAN: u32 = 1;
pub const PKT_RX_RSS_HASH: u32 = 2;
pub const PKT_RX_FDIR: u32 = 4;
pub const PKT_RX_L4_CKSUM_BAD: u32 = 8;
pub const PKT_RX_IP_CKSUM_BAD: u32 = 16;
pub const PKT_RX_EIP_CKSUM_BAD: u32 = 32;
pub const PKT_RX_VLAN_STRIPPED: u32 = 64;
pub const PKT_RX_IP_CKSUM_MASK: u32 = 144;
pub const PKT_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_IP_CKSUM_GOOD: u32 = 128;
pub const PKT_RX_IP_CKSUM_NONE: u32 = 144;
pub const PKT_RX_L4_CKSUM_MASK: u32 = 264;
pub const PKT_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_L4_CKSUM_GOOD: u32 = 256;
pub const PKT_RX_L4_CKSUM_NONE: u32 = 264;
pub const PKT_RX_IEEE1588_PTP: u32 = 512;
pub const PKT_RX_IEEE1588_TMST: u32 = 1024;
pub const PKT_RX_FDIR_ID: u32 = 8192;
pub const PKT_RX_FDIR_FLX: u32 = 16384;
pub const PKT_RX_QINQ_STRIPPED: u32 = 32768;
pub const PKT_RX_LRO: u32 = 65536;
pub const PKT_RX_TIMESTAMP: u32 = 131072;
pub const PKT_RX_SEC_OFFLOAD: u32 = 262144;
pub const PKT_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const PKT_RX_QINQ: u32 = 1048576;
pub const PKT_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const PKT_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const PKT_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const PKT_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const PKT_TX_METADATA: u64 = 1099511627776;
pub const PKT_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const PKT_TX_UDP_SEG: u64 = 4398046511104;
pub const PKT_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const PKT_TX_MACSEC: u64 = 17592186044416;
pub const PKT_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const PKT_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const PKT_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const PKT_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const PKT_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const PKT_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const PKT_TX_TUNNEL_IP: u64 = 457396837154816;
pub const PKT_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const PKT_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const PKT_TX_QINQ: u64 = 562949953421312;
pub const PKT_TX_QINQ_PKT: u64 = 562949953421312;
pub const PKT_TX_TCP_SEG: u64 = 1125899906842624;
pub const PKT_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const PKT_TX_L4_NO_CKSUM: u32 = 0;
pub const PKT_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const PKT_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const PKT_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const PKT_TX_L4_MASK: u64 = 13510798882111488;
pub const PKT_TX_IP_CKSUM: u64 = 18014398509481984;
pub const PKT_TX_IPV4: u64 = 36028797018963968;
pub const PKT_TX_IPV6: u64 = 72057594037927936;
pub const PKT_TX_VLAN: u64 = 144115188075855872;
pub const PKT_TX_VLAN_PKT: u64 = 144115188075855872;
pub const PKT_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const PKT_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const PKT_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const PKT_TX_OFFLOAD_MASK: u64 = 2305841909702066176;
pub const EXT_ATTACHED_MBUF: u64 = 2305843009213693952;
pub const IND_ATTACHED_MBUF: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const MBUF_INVALID_PORT: u32 = 65535;
pub const RTE_TIMER_STOP: u32 = 0;
pub const RTE_TIMER_PENDING: u32 = 1;
pub const RTE_TIMER_RUNNING: u32 = 2;
pub const RTE_TIMER_CONFIG: u32 = 3;
pub const RTE_TIMER_NO_OWNER: i32 = -2;
pub const MAX_SKIPLIST_DEPTH: u32 = 10;
pub const RTE_TAILQ_NAMESIZE: u32 = 32;
pub const RTE_HEAP_NUM_FREELISTS: u32 = 13;
pub const RTE_HEAP_NAME_MAX_LEN: u32 = 32;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 32;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const PCI_PRI_FMT: &'static [u8; 18usize] = b"%.4x:%.2x:%.2x.%x\0";
pub const PCI_SHORT_PRI_FMT: &'static [u8; 13usize] = b"%.2x:%.2x.%x\0";
pub const PCI_FMT_NVAL: u32 = 4;
pub const PCI_RESOURCE_FMT_NVAL: u32 = 3;
pub const PCI_MAX_RESOURCE: u32 = 6;
pub const PCI_ANY_ID: u32 = 65535;
pub const RTE_CLASS_ANY_ID: u32 = 16777215;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const ETHER_ADDR_LEN: u32 = 6;
pub const ETHER_TYPE_LEN: u32 = 2;
pub const ETHER_CRC_LEN: u32 = 4;
pub const ETHER_HDR_LEN: u32 = 14;
pub const ETHER_MIN_LEN: u32 = 64;
pub const ETHER_MAX_LEN: u32 = 1518;
pub const ETHER_MTU: u32 = 1500;
pub const ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const ETHER_MAX_VLAN_ID: u32 = 4095;
pub const ETHER_MIN_MTU: u32 = 68;
pub const ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const ETHER_GROUP_ADDR: u32 = 1;
pub const ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const ETHER_TYPE_IPv4: u32 = 2048;
pub const ETHER_TYPE_IPv6: u32 = 34525;
pub const ETHER_TYPE_ARP: u32 = 2054;
pub const ETHER_TYPE_RARP: u32 = 32821;
pub const ETHER_TYPE_VLAN: u32 = 33024;
pub const ETHER_TYPE_QINQ: u32 = 34984;
pub const ETHER_TYPE_ETAG: u32 = 35135;
pub const ETHER_TYPE_1588: u32 = 35063;
pub const ETHER_TYPE_SLOW: u32 = 34825;
pub const ETHER_TYPE_TEB: u32 = 25944;
pub const ETHER_TYPE_LLDP: u32 = 35020;
pub const ETHER_TYPE_MPLS: u32 = 34887;
pub const ETHER_TYPE_MPLSM: u32 = 34888;
pub const VXLAN_GPE_TYPE_IPV4: u32 = 1;
pub const VXLAN_GPE_TYPE_IPV6: u32 = 2;
pub const VXLAN_GPE_TYPE_ETH: u32 = 3;
pub const VXLAN_GPE_TYPE_NSH: u32 = 4;
pub const VXLAN_GPE_TYPE_MPLS: u32 = 5;
pub const VXLAN_GPE_TYPE_GBP: u32 = 6;
pub const VXLAN_GPE_TYPE_VBNG: u32 = 7;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_MAX: u32 = 23;
pub const RTE_ETHTYPE_FLAGS_MAC: u32 = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: u32 = 2;
pub const RTE_FLEX_FILTER_MAXLEN: u32 = 128;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const TCP_URG_FLAG: u32 = 32;
pub const TCP_ACK_FLAG: u32 = 16;
pub const TCP_PSH_FLAG: u32 = 8;
pub const TCP_RST_FLAG: u32 = 4;
pub const TCP_SYN_FLAG: u32 = 2;
pub const TCP_FIN_FLAG: u32 = 1;
pub const TCP_FLAG_ALL: u32 = 63;
pub const ETH_TUNNEL_FILTER_OMAC: u32 = 1;
pub const ETH_TUNNEL_FILTER_OIP: u32 = 2;
pub const ETH_TUNNEL_FILTER_TENID: u32 = 4;
pub const ETH_TUNNEL_FILTER_IMAC: u32 = 8;
pub const ETH_TUNNEL_FILTER_IVLAN: u32 = 16;
pub const ETH_TUNNEL_FILTER_IIP: u32 = 32;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN: u32 = 24;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID: u32 = 28;
pub const RTE_TUNNEL_FILTER_IMAC_TENID: u32 = 12;
pub const RTE_TUNNEL_FILTER_OMAC_TENID_IMAC: u32 = 13;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const RTE_ETH_MODULE_SFF_8079: u32 = 1;
pub const RTE_ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8472: u32 = 2;
pub const RTE_ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const RTE_ETH_MODULE_SFF_8636: u32 = 3;
pub const RTE_ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8436: u32 = 4;
pub const RTE_ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const ETH_LINK_SPEED_FIXED: u32 = 1;
pub const ETH_LINK_SPEED_10M_HD: u32 = 2;
pub const ETH_LINK_SPEED_10M: u32 = 4;
pub const ETH_LINK_SPEED_100M_HD: u32 = 8;
pub const ETH_LINK_SPEED_100M: u32 = 16;
pub const ETH_LINK_SPEED_1G: u32 = 32;
pub const ETH_LINK_SPEED_2_5G: u32 = 64;
pub const ETH_LINK_SPEED_5G: u32 = 128;
pub const ETH_LINK_SPEED_10G: u32 = 256;
pub const ETH_LINK_SPEED_20G: u32 = 512;
pub const ETH_LINK_SPEED_25G: u32 = 1024;
pub const ETH_LINK_SPEED_40G: u32 = 2048;
pub const ETH_LINK_SPEED_50G: u32 = 4096;
pub const ETH_LINK_SPEED_56G: u32 = 8192;
pub const ETH_LINK_SPEED_100G: u32 = 16384;
pub const ETH_SPEED_NUM_NONE: u32 = 0;
pub const ETH_SPEED_NUM_10M: u32 = 10;
pub const ETH_SPEED_NUM_100M: u32 = 100;
pub const ETH_SPEED_NUM_1G: u32 = 1000;
pub const ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const ETH_SPEED_NUM_5G: u32 = 5000;
pub const ETH_SPEED_NUM_10G: u32 = 10000;
pub const ETH_SPEED_NUM_20G: u32 = 20000;
pub const ETH_SPEED_NUM_25G: u32 = 25000;
pub const ETH_SPEED_NUM_40G: u32 = 40000;
pub const ETH_SPEED_NUM_50G: u32 = 50000;
pub const ETH_SPEED_NUM_56G: u32 = 56000;
pub const ETH_SPEED_NUM_100G: u32 = 100000;
pub const ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const ETH_LINK_DOWN: u32 = 0;
pub const ETH_LINK_UP: u32 = 1;
pub const ETH_LINK_FIXED: u32 = 0;
pub const ETH_LINK_AUTONEG: u32 = 1;
pub const ETH_MQ_RX_RSS_FLAG: u32 = 1;
pub const ETH_MQ_RX_DCB_FLAG: u32 = 2;
pub const ETH_MQ_RX_VMDQ_FLAG: u32 = 4;
pub const ETH_RSS_IPV4: u32 = 4;
pub const ETH_RSS_FRAG_IPV4: u32 = 8;
pub const ETH_RSS_NONFRAG_IPV4_TCP: u32 = 16;
pub const ETH_RSS_NONFRAG_IPV4_UDP: u32 = 32;
pub const ETH_RSS_NONFRAG_IPV4_SCTP: u32 = 64;
pub const ETH_RSS_NONFRAG_IPV4_OTHER: u32 = 128;
pub const ETH_RSS_IPV6: u32 = 256;
pub const ETH_RSS_FRAG_IPV6: u32 = 512;
pub const ETH_RSS_NONFRAG_IPV6_TCP: u32 = 1024;
pub const ETH_RSS_NONFRAG_IPV6_UDP: u32 = 2048;
pub const ETH_RSS_NONFRAG_IPV6_SCTP: u32 = 4096;
pub const ETH_RSS_NONFRAG_IPV6_OTHER: u32 = 8192;
pub const ETH_RSS_L2_PAYLOAD: u32 = 16384;
pub const ETH_RSS_IPV6_EX: u32 = 32768;
pub const ETH_RSS_IPV6_TCP_EX: u32 = 65536;
pub const ETH_RSS_IPV6_UDP_EX: u32 = 131072;
pub const ETH_RSS_PORT: u32 = 262144;
pub const ETH_RSS_VXLAN: u32 = 524288;
pub const ETH_RSS_GENEVE: u32 = 1048576;
pub const ETH_RSS_NVGRE: u32 = 2097152;
pub const ETH_RSS_IP: u32 = 41868;
pub const ETH_RSS_UDP: u32 = 133152;
pub const ETH_RSS_TCP: u32 = 66576;
pub const ETH_RSS_SCTP: u32 = 4160;
pub const ETH_RSS_TUNNEL: u32 = 3670016;
pub const ETH_RSS_PROTO_MASK: u32 = 4194300;
pub const ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_RETA_GROUP_SIZE: u32 = 64;
pub const ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_PG_SUPPORT: u32 = 1;
pub const ETH_DCB_PFC_SUPPORT: u32 = 2;
pub const ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const ETH_VLAN_STRIP_MASK: u32 = 1;
pub const ETH_VLAN_FILTER_MASK: u32 = 2;
pub const ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const ETH_VLAN_ID_MAX: u32 = 4095;
pub const ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const ETH_VMDQ_ACCEPT_UNTAG: u32 = 1;
pub const ETH_VMDQ_ACCEPT_HASH_MC: u32 = 2;
pub const ETH_VMDQ_ACCEPT_HASH_UC: u32 = 4;
pub const ETH_VMDQ_ACCEPT_BROADCAST: u32 = 8;
pub const ETH_VMDQ_ACCEPT_MULTICAST: u32 = 16;
pub const ETH_MIRROR_MAX_VLANS: u32 = 64;
pub const ETH_MIRROR_VIRTUAL_POOL_UP: u32 = 1;
pub const ETH_MIRROR_UPLINK_PORT: u32 = 2;
pub const ETH_MIRROR_DOWNLINK_PORT: u32 = 4;
pub const ETH_MIRROR_VLAN: u32 = 8;
pub const ETH_MIRROR_VIRTUAL_POOL_DOWN: u32 = 16;
pub const DEV_RX_OFFLOAD_VLAN_STRIP: u32 = 1;
pub const DEV_RX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_RX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_RX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_RX_OFFLOAD_TCP_LRO: u32 = 16;
pub const DEV_RX_OFFLOAD_QINQ_STRIP: u32 = 32;
pub const DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 64;
pub const DEV_RX_OFFLOAD_MACSEC_STRIP: u32 = 128;
pub const DEV_RX_OFFLOAD_HEADER_SPLIT: u32 = 256;
pub const DEV_RX_OFFLOAD_VLAN_FILTER: u32 = 512;
pub const DEV_RX_OFFLOAD_VLAN_EXTEND: u32 = 1024;
pub const DEV_RX_OFFLOAD_JUMBO_FRAME: u32 = 2048;
pub const DEV_RX_OFFLOAD_SCATTER: u32 = 8192;
pub const DEV_RX_OFFLOAD_TIMESTAMP: u32 = 16384;
pub const DEV_RX_OFFLOAD_SECURITY: u32 = 32768;
pub const DEV_RX_OFFLOAD_KEEP_CRC: u32 = 65536;
pub const DEV_RX_OFFLOAD_SCTP_CKSUM: u32 = 131072;
pub const DEV_RX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 262144;
pub const DEV_RX_OFFLOAD_CHECKSUM: u32 = 14;
pub const DEV_RX_OFFLOAD_VLAN: u32 = 1537;
pub const DEV_TX_OFFLOAD_VLAN_INSERT: u32 = 1;
pub const DEV_TX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_TX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_TX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_TX_OFFLOAD_SCTP_CKSUM: u32 = 16;
pub const DEV_TX_OFFLOAD_TCP_TSO: u32 = 32;
pub const DEV_TX_OFFLOAD_UDP_TSO: u32 = 64;
pub const DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 128;
pub const DEV_TX_OFFLOAD_QINQ_INSERT: u32 = 256;
pub const DEV_TX_OFFLOAD_VXLAN_TNL_TSO: u32 = 512;
pub const DEV_TX_OFFLOAD_GRE_TNL_TSO: u32 = 1024;
pub const DEV_TX_OFFLOAD_IPIP_TNL_TSO: u32 = 2048;
pub const DEV_TX_OFFLOAD_GENEVE_TNL_TSO: u32 = 4096;
pub const DEV_TX_OFFLOAD_MACSEC_INSERT: u32 = 8192;
pub const DEV_TX_OFFLOAD_MT_LOCKFREE: u32 = 16384;
pub const DEV_TX_OFFLOAD_MULTI_SEGS: u32 = 32768;
pub const DEV_TX_OFFLOAD_MBUF_FAST_FREE: u32 = 65536;
pub const DEV_TX_OFFLOAD_SECURITY: u32 = 131072;
pub const DEV_TX_OFFLOAD_UDP_TNL_TSO: u32 = 262144;
pub const DEV_TX_OFFLOAD_IP_TNL_TSO: u32 = 524288;
pub const DEV_TX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 1048576;
pub const DEV_TX_OFFLOAD_MATCH_METADATA: u32 = 2097152;
pub const RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP: u32 = 1;
pub const RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP: u32 = 2;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 0;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const ETH_DCB_NUM_TCS: u32 = 8;
pub const ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_QUEUE_STATE_STOPPED: u32 = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: u32 = 1;
pub const RTE_ETH_ALL: u32 = 32;
pub const ETH_L2_TUNNEL_ENABLE_MASK: u32 = 1;
pub const ETH_L2_TUNNEL_INSERTION_MASK: u32 = 2;
pub const ETH_L2_TUNNEL_STRIPPING_MASK: u32 = 4;
pub const ETH_L2_TUNNEL_FORWARDING_MASK: u32 = 8;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 64;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_DEV_CLOSE_REMOVE: u32 = 1;
pub const RTE_ETH_DEV_INTR_LSC: u32 = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: u32 = 4;
pub const RTE_ETH_DEV_INTR_RMV: u32 = 8;
pub const RTE_ETH_DEV_REPRESENTOR: u32 = 16;
pub const RTE_ETH_DEV_NOLIVE_MAC_ADDR: u32 = 32;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub const RTE_KNI_NAMESIZE: u32 = 32;
pub const KNI_DEVICE: &'static [u8; 4usize] = b"kni\0";
pub const BONDING_MODE_ROUND_ROBIN: u32 = 0;
pub const BONDING_MODE_ACTIVE_BACKUP: u32 = 1;
pub const BONDING_MODE_BALANCE: u32 = 2;
pub const BONDING_MODE_BROADCAST: u32 = 3;
pub const BONDING_MODE_8023AD: u32 = 4;
pub const BONDING_MODE_TLB: u32 = 5;
pub const BONDING_MODE_ALB: u32 = 6;
pub const BALANCE_XMIT_POLICY_LAYER2: u32 = 0;
pub const BALANCE_XMIT_POLICY_LAYER23: u32 = 1;
pub const BALANCE_XMIT_POLICY_LAYER34: u32 = 2;
pub const ARP_HRD_ETHER: u32 = 1;
pub const ARP_OP_REQUEST: u32 = 1;
pub const ARP_OP_REPLY: u32 = 2;
pub const ARP_OP_REVREQUEST: u32 = 3;
pub const ARP_OP_REVREPLY: u32 = 4;
pub const ARP_OP_INVREQUEST: u32 = 8;
pub const ARP_OP_INVREPLY: u32 = 9;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_MAX: u32 = 44;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_MAX: u32 = 44;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOMAXCONN: u32 = 128;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SO_MARK: u32 = 36;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const __osockaddr_defined: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const IPV4_MAX_PKT_LEN: u32 = 65535;
pub const IPV4_HDR_IHL_MASK: u32 = 15;
pub const IPV4_IHL_MULTIPLIER: u32 = 4;
pub const IPV4_HDR_DF_SHIFT: u32 = 14;
pub const IPV4_HDR_MF_SHIFT: u32 = 13;
pub const IPV4_HDR_FO_SHIFT: u32 = 3;
pub const IPV4_HDR_DF_FLAG: u32 = 16384;
pub const IPV4_HDR_MF_FLAG: u32 = 8192;
pub const IPV4_HDR_OFFSET_MASK: u32 = 8191;
pub const IPV4_HDR_OFFSET_UNITS: u32 = 8;
pub const IPV6_HDR_FL_SHIFT: u32 = 0;
pub const IPV6_HDR_TC_SHIFT: u32 = 20;
pub const IPV6_HDR_FL_MASK: u32 = 1048575;
pub const IPV6_HDR_TC_MASK: u32 = 15728640;
pub const IP_ICMP_ECHO_REPLY: u32 = 0;
pub const IP_ICMP_ECHO_REQUEST: u32 = 8;
pub const vt100_bell: &'static [u8; 2usize] = b"\x07\0";
pub const vt100_bs: &'static [u8; 2usize] = b"\x08\0";
pub const vt100_bs_clear: &'static [u8; 7usize] = b"\x08 \\010\0";
pub const vt100_tab: &'static [u8; 2usize] = b"\t\0";
pub const vt100_crnl: &'static [u8; 3usize] = b"\n\r\0";
pub const vt100_clear_right: &'static [u8; 5usize] = b"\x1B[0K\0";
pub const vt100_clear_left: &'static [u8; 5usize] = b"\x1B[1K\0";
pub const vt100_clear_down: &'static [u8; 5usize] = b"\x1B[0J\0";
pub const vt100_clear_up: &'static [u8; 5usize] = b"\x1B[1J\0";
pub const vt100_clear_line: &'static [u8; 5usize] = b"\x1B[2K\0";
pub const vt100_clear_screen: &'static [u8; 5usize] = b"\x1B[2J\0";
pub const vt100_up_arr: &'static [u8; 4usize] = b"\x1B[A\0";
pub const vt100_down_arr: &'static [u8; 4usize] = b"\x1B[B\0";
pub const vt100_right_arr: &'static [u8; 4usize] = b"\x1B[C\0";
pub const vt100_left_arr: &'static [u8; 4usize] = b"\x1B[D\0";
pub const vt100_multi_right: &'static [u8; 6usize] = b"\x1B[%uC\0";
pub const vt100_multi_left: &'static [u8; 6usize] = b"\x1B[%uD\0";
pub const vt100_suppr: &'static [u8; 5usize] = b"\x1B[3~\0";
pub const vt100_home: &'static [u8; 8usize] = b"\x1BM\\033E\0";
pub const vt100_word_left: &'static [u8; 3usize] = b"\x1Bb\0";
pub const vt100_word_right: &'static [u8; 3usize] = b"\x1Bf\0";
pub const CMDLINE_KEY_UP_ARR: u32 = 0;
pub const CMDLINE_KEY_DOWN_ARR: u32 = 1;
pub const CMDLINE_KEY_RIGHT_ARR: u32 = 2;
pub const CMDLINE_KEY_LEFT_ARR: u32 = 3;
pub const CMDLINE_KEY_BKSPACE: u32 = 4;
pub const CMDLINE_KEY_RETURN: u32 = 5;
pub const CMDLINE_KEY_CTRL_A: u32 = 6;
pub const CMDLINE_KEY_CTRL_E: u32 = 7;
pub const CMDLINE_KEY_CTRL_K: u32 = 8;
pub const CMDLINE_KEY_CTRL_Y: u32 = 9;
pub const CMDLINE_KEY_CTRL_C: u32 = 10;
pub const CMDLINE_KEY_CTRL_F: u32 = 11;
pub const CMDLINE_KEY_CTRL_B: u32 = 12;
pub const CMDLINE_KEY_SUPPR: u32 = 13;
pub const CMDLINE_KEY_TAB: u32 = 14;
pub const CMDLINE_KEY_CTRL_D: u32 = 15;
pub const CMDLINE_KEY_CTRL_L: u32 = 16;
pub const CMDLINE_KEY_RETURN2: u32 = 17;
pub const CMDLINE_KEY_META_BKSPACE: u32 = 18;
pub const CMDLINE_KEY_WLEFT: u32 = 19;
pub const CMDLINE_KEY_WRIGHT: u32 = 20;
pub const CMDLINE_KEY_HELP: u32 = 21;
pub const CMDLINE_KEY_CTRL_W: u32 = 22;
pub const CMDLINE_KEY_CTRL_P: u32 = 23;
pub const CMDLINE_KEY_CTRL_N: u32 = 24;
pub const CMDLINE_KEY_META_D: u32 = 25;
pub const CMDLINE_KEY_BKSPACE2: u32 = 26;
pub const CMDLINE_VT100_BUF_SIZE: u32 = 8;
pub const RDLINE_BUF_SIZE: u32 = 512;
pub const RDLINE_PROMPT_SIZE: u32 = 32;
pub const RDLINE_VT100_BUF_SIZE: u32 = 8;
pub const RDLINE_HISTORY_BUF_SIZE: u32 = 8192;
pub const RDLINE_HISTORY_MAX_LINE: u32 = 64;
pub const RDLINE_RES_SUCCESS: u32 = 0;
pub const RDLINE_RES_VALIDATED: u32 = 1;
pub const RDLINE_RES_COMPLETE: u32 = 2;
pub const RDLINE_RES_NOT_RUNNING: i32 = -1;
pub const RDLINE_RES_EOF: i32 = -2;
pub const RDLINE_RES_EXITED: i32 = -3;
pub const CMDLINE_PARSE_SUCCESS: u32 = 0;
pub const CMDLINE_PARSE_AMBIGUOUS: i32 = -1;
pub const CMDLINE_PARSE_NOMATCH: i32 = -2;
pub const CMDLINE_PARSE_BAD_ARGS: i32 = -3;
pub const CMDLINE_PARSE_COMPLETE_FINISHED: u32 = 0;
pub const CMDLINE_PARSE_COMPLETE_AGAIN: u32 = 1;
pub const CMDLINE_PARSE_COMPLETED_BUFFER: u32 = 2;
pub const CMDLINE_PARSE_RESULT_BUFSIZE: u32 = 8192;
pub const CMDLINE_IPADDR_V4: u32 = 1;
pub const CMDLINE_IPADDR_V6: u32 = 2;
pub const CMDLINE_IPADDR_NETWORK: u32 = 4;
pub const PORTLIST_TOKEN_SIZE: u32 = 128;
pub const PORTLIST_MAX_TOKENS: u32 = 32;
pub const STR_TOKEN_SIZE: u32 = 128;
pub const STR_MULTI_TOKEN_SIZE: u32 = 4096;
pub const TOKEN_STRING_MULTI: &'static [u8; 1usize] = b"\0";
pub const _TERMIOS_H: u32 = 1;
pub const NCCS: u32 = 32;
pub const _HAVE_STRUCT_TERMIOS_C_ISPEED: u32 = 1;
pub const _HAVE_STRUCT_TERMIOS_C_OSPEED: u32 = 1;
pub const VINTR: u32 = 0;
pub const VQUIT: u32 = 1;
pub const VERASE: u32 = 2;
pub const VKILL: u32 = 3;
pub const VEOF: u32 = 4;
pub const VTIME: u32 = 5;
pub const VMIN: u32 = 6;
pub const VSWTC: u32 = 7;
pub const VSTART: u32 = 8;
pub const VSTOP: u32 = 9;
pub const VSUSP: u32 = 10;
pub const VEOL: u32 = 11;
pub const VREPRINT: u32 = 12;
pub const VDISCARD: u32 = 13;
pub const VWERASE: u32 = 14;
pub const VLNEXT: u32 = 15;
pub const VEOL2: u32 = 16;
pub const IGNBRK: u32 = 1;
pub const BRKINT: u32 = 2;
pub const IGNPAR: u32 = 4;
pub const PARMRK: u32 = 8;
pub const INPCK: u32 = 16;
pub const ISTRIP: u32 = 32;
pub const INLCR: u32 = 64;
pub const IGNCR: u32 = 128;
pub const ICRNL: u32 = 256;
pub const IUCLC: u32 = 512;
pub const IXON: u32 = 1024;
pub const IXANY: u32 = 2048;
pub const IXOFF: u32 = 4096;
pub const IMAXBEL: u32 = 8192;
pub const IUTF8: u32 = 16384;
pub const OPOST: u32 = 1;
pub const OLCUC: u32 = 2;
pub const ONLCR: u32 = 4;
pub const OCRNL: u32 = 8;
pub const ONOCR: u32 = 16;
pub const ONLRET: u32 = 32;
pub const OFILL: u32 = 64;
pub const OFDEL: u32 = 128;
pub const NLDLY: u32 = 256;
pub const NL0: u32 = 0;
pub const NL1: u32 = 256;
pub const CRDLY: u32 = 1536;
pub const CR0: u32 = 0;
pub const CR1: u32 = 512;
pub const CR2: u32 = 1024;
pub const CR3: u32 = 1536;
pub const TABDLY: u32 = 6144;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 2048;
pub const TAB2: u32 = 4096;
pub const TAB3: u32 = 6144;
pub const BSDLY: u32 = 8192;
pub const BS0: u32 = 0;
pub const BS1: u32 = 8192;
pub const FFDLY: u32 = 32768;
pub const FF0: u32 = 0;
pub const FF1: u32 = 32768;
pub const VTDLY: u32 = 16384;
pub const VT0: u32 = 0;
pub const VT1: u32 = 16384;
pub const XTABS: u32 = 6144;
pub const CBAUD: u32 = 4111;
pub const B0: u32 = 0;
pub const B50: u32 = 1;
pub const B75: u32 = 2;
pub const B110: u32 = 3;
pub const B134: u32 = 4;
pub const B150: u32 = 5;
pub const B200: u32 = 6;
pub const B300: u32 = 7;
pub const B600: u32 = 8;
pub const B1200: u32 = 9;
pub const B1800: u32 = 10;
pub const B2400: u32 = 11;
pub const B4800: u32 = 12;
pub const B9600: u32 = 13;
pub const B19200: u32 = 14;
pub const B38400: u32 = 15;
pub const EXTA: u32 = 14;
pub const EXTB: u32 = 15;
pub const CSIZE: u32 = 48;
pub const CS5: u32 = 0;
pub const CS6: u32 = 16;
pub const CS7: u32 = 32;
pub const CS8: u32 = 48;
pub const CSTOPB: u32 = 64;
pub const CREAD: u32 = 128;
pub const PARENB: u32 = 256;
pub const PARODD: u32 = 512;
pub const HUPCL: u32 = 1024;
pub const CLOCAL: u32 = 2048;
pub const CBAUDEX: u32 = 4096;
pub const B57600: u32 = 4097;
pub const B115200: u32 = 4098;
pub const B230400: u32 = 4099;
pub const B460800: u32 = 4100;
pub const B500000: u32 = 4101;
pub const B576000: u32 = 4102;
pub const B921600: u32 = 4103;
pub const B1000000: u32 = 4104;
pub const B1152000: u32 = 4105;
pub const B1500000: u32 = 4106;
pub const B2000000: u32 = 4107;
pub const B2500000: u32 = 4108;
pub const B3000000: u32 = 4109;
pub const B3500000: u32 = 4110;
pub const B4000000: u32 = 4111;
pub const __MAX_BAUD: u32 = 4111;
pub const CIBAUD: u32 = 269418496;
pub const CMSPAR: u32 = 1073741824;
pub const CRTSCTS: u32 = 2147483648;
pub const ISIG: u32 = 1;
pub const ICANON: u32 = 2;
pub const XCASE: u32 = 4;
pub const ECHO: u32 = 8;
pub const ECHOE: u32 = 16;
pub const ECHOK: u32 = 32;
pub const ECHONL: u32 = 64;
pub const NOFLSH: u32 = 128;
pub const TOSTOP: u32 = 256;
pub const ECHOCTL: u32 = 512;
pub const ECHOPRT: u32 = 1024;
pub const ECHOKE: u32 = 2048;
pub const FLUSHO: u32 = 4096;
pub const PENDIN: u32 = 16384;
pub const IEXTEN: u32 = 32768;
pub const EXTPROC: u32 = 65536;
pub const TCOOFF: u32 = 0;
pub const TCOON: u32 = 1;
pub const TCIOFF: u32 = 2;
pub const TCION: u32 = 3;
pub const TCIFLUSH: u32 = 0;
pub const TCOFLUSH: u32 = 1;
pub const TCIOFLUSH: u32 = 2;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const TTYDEF_IFLAG: u32 = 11554;
pub const TTYDEF_OFLAG: u32 = 6149;
pub const TTYDEF_LFLAG: u32 = 35355;
pub const TTYDEF_CFLAG: u32 = 1440;
pub const TTYDEF_SPEED: u32 = 13;
pub const CEOL: u8 = 0u8;
pub const CERASE: u32 = 127;
pub const CSTATUS: u8 = 0u8;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u8 = 0u8;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
pub mod idtype_t {
    pub type Type = u32;
    pub const P_ALL: Type = 0;
    pub const P_PID: Type = 1;
    pub const P_PGID: Type = 2;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub mod _bindgen_ty_1 {
    pub type Type = u32;
    pub const _ISupper: Type = 256;
    pub const _ISlower: Type = 512;
    pub const _ISalpha: Type = 1024;
    pub const _ISdigit: Type = 2048;
    pub const _ISxdigit: Type = 4096;
    pub const _ISspace: Type = 8192;
    pub const _ISprint: Type = 16384;
    pub const _ISgraph: Type = 32768;
    pub const _ISblank: Type = 1;
    pub const _IScntrl: Type = 2;
    pub const _ISpunct: Type = 4;
    pub const _ISalnum: Type = 8;
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
extern "C" {
    /// Function to terminate the application immediately, printing an error
    /// message and returning the exit_code back to the shell.
    ///
    /// This function never returns
    ///
    /// @param exit_code
    ///     The exit code to be returned by the application
    /// @param format
    ///     The format string to be used for printing the message. This can include
    ///     printf format characters which will be expanded using any further parameters
    ///     to the function.
    pub fn rte_exit(exit_code: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
impl Default for _IO_marker {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod __codecvt_result {
    pub type Type = u32;
    pub const __codecvt_ok: Type = 0;
    pub const __codecvt_partial: Type = 1;
    pub const __codecvt_error: Type = 2;
    pub const __codecvt_noconv: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_log_dynamic_type {
    _unused: [u8; 0],
}
/// The rte_log structure.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_logs {
    ///< Bitfield with enabled logs.
    pub type_: u32,
    ///< Log level.
    pub level: u32,
    ///< Output file set by rte_openlog_stream, or NULL.
    pub file: *mut FILE,
    pub dynamic_types_len: usize,
    pub dynamic_types: *mut rte_log_dynamic_type,
}
#[test]
fn bindgen_test_layout_rte_logs() {
    assert_eq!(
        ::std::mem::size_of::<rte_logs>(),
        32usize,
        concat!("Size of: ", stringify!(rte_logs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_logs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_logs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types)
        )
    );
}
impl Default for rte_logs {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}rte_logs"]
    pub static mut rte_logs: rte_logs;
}
extern "C" {
    /// Change the stream that will be used by the logging system.
    ///
    /// This can be done at any time. The f argument represents the stream
    /// to be used to send the logs. If f is NULL, the default output is
    /// used (stderr).
    ///
    /// @param f
    ///   Pointer to the stream.
    /// @return
    ///   - 0 on success.
    ///   - Negative on error.
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the global log level.
    ///
    /// After this call, logs with a level lower or equal than the level
    /// passed as argument will be displayed.
    ///
    /// @param level
    ///   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    /// Get the global log level.
    ///
    /// @return
    ///   The current global log level.
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    /// Get the log level for a given type.
    ///
    /// @param logtype
    ///   The log type identifier.
    /// @return
    ///   0 on success, a negative value if logtype is invalid.
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the log level for a given type based on shell pattern.
    ///
    /// @param pattern
    ///   The match pattern identifying the log type.
    /// @param level
    ///   The level to be set.
    /// @return
    ///   0 on success, a negative value if level is invalid.
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the log level for a given type based on regular expression.
    ///
    /// @param regex
    ///   The regular expression identifying the log type.
    /// @param level
    ///   The level to be set.
    /// @return
    ///   0 on success, a negative value if level is invalid.
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the log level for a given type.
    ///
    /// @param logtype
    ///   The log type identifier.
    /// @param level
    ///   The level to be set.
    /// @return
    ///   0 on success, a negative value if logtype or level is invalid.
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current loglevel for the message being processed.
    ///
    /// Before calling the user-defined stream for logging, the log
    /// subsystem sets a per-lcore variable containing the loglevel and the
    /// logtype of the message being processed. This information can be
    /// accessed by the user-defined log output function through this
    /// function.
    ///
    /// @return
    ///   The loglevel of the message being processed.
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current logtype for the message being processed.
    ///
    /// Before calling the user-defined stream for logging, the log
    /// subsystem sets a per-lcore variable containing the loglevel and the
    /// logtype of the message being processed. This information can be
    /// accessed by the user-defined log output function through this
    /// function.
    ///
    /// @return
    ///   The logtype of the message being processed.
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register a dynamic log type
    ///
    /// If a log is already registered with the same type, the returned value
    /// is the same than the previous one.
    ///
    /// @param name
    ///   The string identifying the log type.
    /// @return
    ///   - >0: success, the returned value is the log type identifier.
    ///   - (-ENOMEM): cannot allocate memory.
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Register a dynamic log type and try to pick its level from EAL options
    ///
    /// rte_log_register() is called inside. If successful, the function tries
    /// to search for matching regexp in the list of EAL log level options and
    /// pick the level from the last matching entry. If nothing can be applied
    /// from the list, the level will be set to the user-defined default value.
    ///
    /// @param name
    ///    Name for the log type to be registered
    /// @param level_def
    ///    Fallback level to be set if the global list has no matching options
    /// @return
    ///    - >=0: the newly registered log type
    ///    - <0: rte_log_register() error value
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump log information.
    ///
    /// Dump the global level and the registered log types.
    ///
    /// @param f
    ///   The output stream where the dump should be sent.
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    /// Generates a log message.
    ///
    /// The message will be sent in the stream defined by the previous call
    /// to rte_openlog_stream().
    ///
    /// The level argument determines if the log should be displayed or
    /// not, depending on the global rte_logs variable.
    ///
    /// The preferred alternative is the RTE_LOG() because it adds the
    /// level and type in the logged string.
    ///
    /// @param level
    ///   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
    /// @param logtype
    ///   The log type, for example, RTE_LOGTYPE_EAL.
    /// @param format
    ///   The format string, as in printf(3), followed by the variable arguments
    ///   required by the format.
    /// @return
    ///   - 0: Success.
    ///   - Negative on error.
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Generates a log message.
    ///
    /// The message will be sent in the stream defined by the previous call
    /// to rte_openlog_stream().
    ///
    /// The level argument determines if the log should be displayed or
    /// not, depending on the global rte_logs variable. A trailing
    /// newline may be added if needed.
    ///
    /// The preferred alternative is the RTE_LOG() because it adds the
    /// level and type in the logged string.
    ///
    /// @param level
    ///   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8).
    /// @param logtype
    ///   The log type, for example, RTE_LOGTYPE_EAL.
    /// @param format
    ///   The format string, as in printf(3), followed by the variable arguments
    ///   required by the format.
    /// @param ap
    ///   The va_list of the variable arguments required by the format.
    /// @return
    ///   - 0: Success.
    ///   - Negative on error.
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub mod rte_page_sizes {
    pub type Type = u64;
    pub const RTE_PGSIZE_4K: Type = 4096;
    pub const RTE_PGSIZE_64K: Type = 65536;
    pub const RTE_PGSIZE_256K: Type = 262144;
    pub const RTE_PGSIZE_2M: Type = 2097152;
    pub const RTE_PGSIZE_16M: Type = 16777216;
    pub const RTE_PGSIZE_256M: Type = 268435456;
    pub const RTE_PGSIZE_512M: Type = 536870912;
    pub const RTE_PGSIZE_1G: Type = 1073741824;
    pub const RTE_PGSIZE_4G: Type = 4294967296;
    pub const RTE_PGSIZE_16G: Type = 17179869184;
}
pub type phys_addr_t = u64;
/// IO virtual address type.
/// When the physical addressing mode (IOVA as PA) is in use,
/// the translation from an IO virtual address (IOVA) to a physical address
/// is a direct mapping, i.e. the same value.
/// Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation.
pub type rte_iova_t = u64;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memseg__bindgen_ty_2,
    ///< Length of the segment.
    pub len: usize,
    ///< The pagesize of underlying memory
    pub hugepage_sz: u64,
    ///< NUMA socket ID.
    pub socket_id: i32,
    ///< Number of channels.
    pub nchannel: u32,
    ///< Number of ranks.
    pub nrank: u32,
    ///< Memseg-specific flags
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    ///< deprecated - Start physical address.
    pub phys_addr: phys_addr_t,
    ///< Start IO address.
    pub iova: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).phys_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(iova)
        )
    );
}
impl Default for rte_memseg__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_2 {
    ///< Start virtual address.
    pub addr: *mut ::std::os::raw::c_void,
    ///< Makes sure addr is always 64 bits
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_2>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_2),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg__bindgen_ty_2>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_2),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memseg__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg>(),
        48usize,
        concat!("Size of: ", stringify!(rte_memseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memseg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).hugepage_sz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).socket_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nchannel as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nrank as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nrank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_memseg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Lock page in physical memory and prevent from swapping.
    ///
    /// @param virt
    ///   The virtual address.
    /// @return
    ///   0 on success, negative on error.
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get physical address of any mapped virtual address in the current process.
    /// It is found by browsing the /proc/self/pagemap special file.
    /// The page must be locked.
    ///
    /// @param virt
    ///   The virtual address.
    /// @return
    ///   The physical address or RTE_BAD_IOVA on error.
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    /// Get IO virtual address of any mapped virtual address in the current process.
    ///
    /// @param virt
    ///   The virtual address.
    /// @return
    ///   The IO address or RTE_BAD_IOVA on error.
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    /// Get virtual memory address corresponding to iova address.
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @param iova
    ///   The iova address.
    /// @return
    ///   Virtual address corresponding to iova address (or NULL if address does not
    ///   exist within DPDK memory map).
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Get memseg to which a particular virtual address belongs.
    ///
    /// @param virt
    ///   The virtual address.
    /// @param msl
    ///   The memseg list in which to look up based on ``virt`` address
    ///   (can be NULL).
    /// @return
    ///   Memseg pointer on success, or NULL on error.
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
extern "C" {
    /// Get memseg list corresponding to virtual memory address.
    ///
    /// @param virt
    ///   The virtual address.
    /// @return
    ///   Memseg list to which this virtual address belongs to.
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
/// Memseg walk function prototype.
///
/// Returning 0 will continue walk
/// Returning 1 will stop the walk
/// Returning -1 will stop the walk and report error
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
/// Memseg contig walk function prototype. This will trigger a callback on every
/// VA-contiguous are starting at memseg ``ms``, so total valid VA space at each
/// callback call will be [``ms->addr``, ``ms->addr + len``).
///
/// Returning 0 will continue walk
/// Returning 1 will stop the walk
/// Returning -1 will stop the walk and report error
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
/// Memseg list walk function prototype. This will trigger a callback on every
/// allocated memseg list.
///
/// Returning 0 will continue walk
/// Returning 1 will stop the walk
/// Returning -1 will stop the walk and report error
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(msl: *const rte_memseg_list, arg: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Walk list of all memsegs.
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @note This function will also walk through externally allocated segments. It
    ///       is up to the user to decide whether to skip through these segments.
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    /// @return
    ///   0 if walked over the entire list
    ///   1 if stopped by the user
    ///   -1 if user function reported error
    pub fn rte_memseg_walk(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Walk each VA-contiguous area.
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @note This function will also walk through externally allocated segments. It
    ///       is up to the user to decide whether to skip through these segments.
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    /// @return
    ///   0 if walked over the entire list
    ///   1 if stopped by the user
    ///   -1 if user function reported error
    pub fn rte_memseg_contig_walk(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Walk each allocated memseg list.
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @note This function will also walk through externally allocated segments. It
    ///       is up to the user to decide whether to skip through these segments.
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    /// @return
    ///   0 if walked over the entire list
    ///   1 if stopped by the user
    ///   -1 if user function reported error
    pub fn rte_memseg_list_walk(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Walk list of all memsegs without performing any locking.
    ///
    /// @note This function does not perform any locking, and is only safe to call
    ///       from within memory-related callback functions.
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    /// @return
    ///   0 if walked over the entire list
    ///   1 if stopped by the user
    ///   -1 if user function reported error
    pub fn rte_memseg_walk_thread_unsafe(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Walk each VA-contiguous area without performing any locking.
    ///
    /// @note This function does not perform any locking, and is only safe to call
    ///       from within memory-related callback functions.
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    /// @return
    ///   0 if walked over the entire list
    ///   1 if stopped by the user
    ///   -1 if user function reported error
    pub fn rte_memseg_contig_walk_thread_unsafe(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Walk each allocated memseg list without performing any locking.
    ///
    /// @note This function does not perform any locking, and is only safe to call
    ///       from within memory-related callback functions.
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    /// @return
    ///   0 if walked over the entire list
    ///   1 if stopped by the user
    ///   -1 if user function reported error
    pub fn rte_memseg_list_walk_thread_unsafe(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return file descriptor associated with a particular memseg (if available).
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @note This returns an internal file descriptor. Performing any operations on
    ///       this file descriptor is inherently dangerous, so it should be treated
    ///       as read-only for all intents and purposes.
    ///
    /// @param ms
    ///   A pointer to memseg for which to get file descriptor.
    ///
    /// @return
    ///   Valid file descriptor in case of success.
    ///   -1 in case of error, with ``rte_errno`` set to the following values:
    ///     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg
    ///     - ENODEV  - ``ms`` fd is not available
    ///     - ENOENT  - ``ms`` is an unused segment
    ///     - ENOTSUP - segment fd's are not supported
    pub fn rte_memseg_get_fd(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return file descriptor associated with a particular memseg (if available).
    ///
    /// @note This function does not perform any locking, and is only safe to call
    ///       from within memory-related callback functions.
    ///
    /// @note This returns an internal file descriptor. Performing any operations on
    ///       this file descriptor is inherently dangerous, so it should be treated
    ///       as read-only for all intents and purposes.
    ///
    /// @param ms
    ///   A pointer to memseg for which to get file descriptor.
    ///
    /// @return
    ///   Valid file descriptor in case of success.
    ///   -1 in case of error, with ``rte_errno`` set to the following values:
    ///     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg
    ///     - ENODEV  - ``ms`` fd is not available
    ///     - ENOENT  - ``ms`` is an unused segment
    ///     - ENOTSUP - segment fd's are not supported
    pub fn rte_memseg_get_fd_thread_unsafe(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get offset into segment file descriptor associated with a particular memseg
    /// (if available).
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @param ms
    ///   A pointer to memseg for which to get file descriptor.
    /// @param offset
    ///   A pointer to offset value where the result will be stored.
    ///
    /// @return
    ///   Valid file descriptor in case of success.
    ///   -1 in case of error, with ``rte_errno`` set to the following values:
    ///     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg
    ///     - EINVAL  - ``offset`` pointer was NULL
    ///     - ENODEV  - ``ms`` fd is not available
    ///     - ENOENT  - ``ms`` is an unused segment
    ///     - ENOTSUP - segment fd's are not supported
    pub fn rte_memseg_get_fd_offset(
        ms: *const rte_memseg,
        offset: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get offset into segment file descriptor associated with a particular memseg
    /// (if available).
    ///
    /// @note This function does not perform any locking, and is only safe to call
    ///       from within memory-related callback functions.
    ///
    /// @param ms
    ///   A pointer to memseg for which to get file descriptor.
    /// @param offset
    ///   A pointer to offset value where the result will be stored.
    ///
    /// @return
    ///   Valid file descriptor in case of success.
    ///   -1 in case of error, with ``rte_errno`` set to the following values:
    ///     - EINVAL  - ``ms`` pointer was NULL or did not point to a valid memseg
    ///     - EINVAL  - ``offset`` pointer was NULL
    ///     - ENODEV  - ``ms`` fd is not available
    ///     - ENOENT  - ``ms`` is an unused segment
    ///     - ENOTSUP - segment fd's are not supported
    pub fn rte_memseg_get_fd_offset_thread_unsafe(
        ms: *const rte_memseg,
        offset: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump the physical memory layout to a file.
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    /// Get the total amount of available physical memory.
    ///
    /// @note This function read-locks the memory hotplug subsystem, and thus cannot
    ///       be used within memory-related callback functions.
    ///
    /// @return
    ///    The total amount of available physical memory in bytes.
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    /// Get the number of memory channels.
    ///
    /// @return
    ///   The number of memory channels on the system. The value is 0 if unknown
    ///   or not the same on all devices.
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the number of memory ranks.
    ///
    /// @return
    ///   The number of memory ranks on the system. The value is 0 if unknown or
    ///   not the same on all devices.
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Check if all currently allocated memory segments are compliant with
    /// supplied DMA address width.
    ///
    ///  @param maskbits
    ///    Address width to check against.
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Check if all currently allocated memory segments are compliant with
    /// supplied DMA address width. This function will use
    /// rte_memseg_walk_thread_unsafe instead of rte_memseg_walk implying
    /// memory_hotplug_lock will not be acquired avoiding deadlock during
    /// memory initialization.
    ///
    /// This function is just for EAL core memory internal use. Drivers should
    /// use the previous rte_mem_check_dma_mask.
    ///
    ///  @param maskbits
    ///    Address width to check against.
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    ///  Set dma mask to use once memory initialization is done. Previous functions
    ///  rte_mem_check_dma_mask and rte_mem_check_dma_mask_thread_unsafe can not be
    ///  used safely until memory has been initialized.
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
extern "C" {
    /// Drivers based on uio will not load unless physical
    /// addresses are obtainable. It is only possible to get
    /// physical addresses when running as a privileged user.
    ///
    /// @return
    ///   1 if the system is able to obtain physical addresses.
    ///   0 if using DMA addresses through an IOMMU.
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
pub mod rte_mem_event {
    /// Enum indicating which kind of memory event has happened. Used by callbacks to
    /// distinguish between memory allocations and deallocations.
    pub type Type = u32;
    ///< Allocation event.
    pub const RTE_MEM_EVENT_ALLOC: Type = 0;
    ///< Deallocation event.
    pub const RTE_MEM_EVENT_FREE: Type = 1;
}
/// Function typedef used to register callbacks for memory events.
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event::Type,
        addr: *const ::std::os::raw::c_void,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    /// Function used to register callbacks for memory events.
    ///
    /// @note callbacks will happen while memory hotplug subsystem is write-locked,
    ///       therefore some functions (e.g. `rte_memseg_walk()`) will cause a
    ///       deadlock when called from within such callbacks.
    ///
    /// @note mem event callbacks not being supported is an expected error condition,
    ///       so user code needs to handle this situation. In these cases, return
    ///       value will be -1, and rte_errno will be set to ENOTSUP.
    ///
    /// @param name
    ///   Name associated with specified callback to be added to the list.
    ///
    /// @param clb
    ///   Callback function pointer.
    ///
    /// @param arg
    ///   Argument to pass to the callback.
    ///
    /// @return
    ///   0 on successful callback register
    ///   -1 on unsuccessful callback register, with rte_errno value indicating
    ///   reason for failure.
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Function used to unregister callbacks for memory events.
    ///
    /// @param name
    ///   Name associated with specified callback to be removed from the list.
    ///
    /// @param arg
    ///   Argument to look for among callbacks with specified callback name.
    ///
    /// @return
    ///   0 on successful callback unregister
    ///   -1 on unsuccessful callback unregister, with rte_errno value indicating
    ///   reason for failure.
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
/// Function typedef used to register memory allocation validation callbacks.
///
/// Returning 0 will allow allocation attempt to continue. Returning -1 will
/// prevent allocation from succeeding.
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(socket_id: ::std::os::raw::c_int, cur_limit: usize, new_len: usize)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    /// @brief Register validator callback for memory allocations.
    ///
    /// Callbacks registered by this function will be called right before memory
    /// allocator is about to trigger allocation of more pages from the system if
    /// said allocation will bring total memory usage above specified limit on
    /// specified socket. User will be able to cancel pending allocation if callback
    /// returns -1.
    ///
    /// @note callbacks will happen while memory hotplug subsystem is write-locked,
    ///       therefore some functions (e.g. `rte_memseg_walk()`) will cause a
    ///       deadlock when called from within such callbacks.
    ///
    /// @note validator callbacks not being supported is an expected error condition,
    ///       so user code needs to handle this situation. In these cases, return
    ///       value will be -1, and rte_errno will be set to ENOTSUP.
    ///
    /// @param name
    ///   Name associated with specified callback to be added to the list.
    ///
    /// @param clb
    ///   Callback function pointer.
    ///
    /// @param socket_id
    ///   Socket ID on which to watch for allocations.
    ///
    /// @param limit
    ///   Limit above which to trigger callbacks.
    ///
    /// @return
    ///   0 on successful callback register
    ///   -1 on unsuccessful callback register, with rte_errno value indicating
    ///   reason for failure.
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @brief Unregister validator callback for memory allocations.
    ///
    /// @param name
    ///   Name associated with specified callback to be removed from the list.
    ///
    /// @param socket_id
    ///   Socket ID on which to watch for allocations.
    ///
    /// @return
    ///   0 on successful callback unregister
    ///   -1 on unsuccessful callback unregister, with rte_errno value indicating
    ///   reason for failure.
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
///  Structure to hold heap statistics obtained from rte_malloc_get_socket_stats function.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_malloc_socket_stats {
    ///< Total bytes on heap
    pub heap_totalsz_bytes: usize,
    ///< Total free bytes on heap
    pub heap_freesz_bytes: usize,
    ///< Size in bytes of largest free block
    pub greatest_free_size: usize,
    ///< Number of free elements on heap
    pub free_count: ::std::os::raw::c_uint,
    ///< Number of allocated elements on heap
    pub alloc_count: ::std::os::raw::c_uint,
    ///< Total allocated bytes on heap
    pub heap_allocsz_bytes: usize,
}
#[test]
fn bindgen_test_layout_rte_malloc_socket_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_malloc_socket_stats>(),
        40usize,
        concat!("Size of: ", stringify!(rte_malloc_socket_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_malloc_socket_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_malloc_socket_stats))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_malloc_socket_stats>())).heap_totalsz_bytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(heap_totalsz_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_malloc_socket_stats>())).heap_freesz_bytes as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(heap_freesz_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_malloc_socket_stats>())).greatest_free_size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(greatest_free_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_malloc_socket_stats>())).free_count as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(free_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_malloc_socket_stats>())).alloc_count as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(alloc_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_malloc_socket_stats>())).heap_allocsz_bytes as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_malloc_socket_stats),
            "::",
            stringify!(heap_allocsz_bytes)
        )
    );
}
extern "C" {
    /// This function allocates memory from the huge-page area of memory. The memory
    /// is not cleared. In NUMA systems, the memory allocated resides on the same
    /// NUMA socket as the core that calls this function.
    ///
    /// @param type
    ///   A string identifying the type of allocated objects (useful for debug
    ///   purposes, such as identifying the cause of a memory leak). Can be NULL.
    /// @param size
    ///   Size (in bytes) to be allocated.
    /// @param align
    ///   If 0, the return is a pointer that is suitably aligned for any kind of
    ///   variable (in the same manner as malloc()).
    ///   Otherwise, the return is a pointer that is a multiple of *align*. In
    ///   this case, it must be a power of two. (Minimum alignment is the
    ///   cacheline size, i.e. 64-bytes)
    /// @return
    ///   - NULL on error. Not enough memory, or invalid arguments (size is 0,
    ///     align is not a power of two).
    ///   - Otherwise, the pointer to the allocated object.
    pub fn rte_malloc(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate zero'ed memory from the heap.
    ///
    /// Equivalent to rte_malloc() except that the memory zone is
    /// initialised with zeros. In NUMA systems, the memory allocated resides on the
    /// same NUMA socket as the core that calls this function.
    ///
    /// @param type
    ///   A string identifying the type of allocated objects (useful for debug
    ///   purposes, such as identifying the cause of a memory leak). Can be NULL.
    /// @param size
    ///   Size (in bytes) to be allocated.
    /// @param align
    ///   If 0, the return is a pointer that is suitably aligned for any kind of
    ///   variable (in the same manner as malloc()).
    ///   Otherwise, the return is a pointer that is a multiple of *align*. In
    ///   this case, it must obviously be a power of two. (Minimum alignment is the
    ///   cacheline size, i.e. 64-bytes)
    /// @return
    ///   - NULL on error. Not enough memory, or invalid arguments (size is 0,
    ///     align is not a power of two).
    ///   - Otherwise, the pointer to the allocated object.
    pub fn rte_zmalloc(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Replacement function for calloc(), using huge-page memory. Memory area is
    /// initialised with zeros. In NUMA systems, the memory allocated resides on the
    /// same NUMA socket as the core that calls this function.
    ///
    /// @param type
    ///   A string identifying the type of allocated objects (useful for debug
    ///   purposes, such as identifying the cause of a memory leak). Can be NULL.
    /// @param num
    ///   Number of elements to be allocated.
    /// @param size
    ///   Size (in bytes) of a single element.
    /// @param align
    ///   If 0, the return is a pointer that is suitably aligned for any kind of
    ///   variable (in the same manner as malloc()).
    ///   Otherwise, the return is a pointer that is a multiple of *align*. In
    ///   this case, it must obviously be a power of two. (Minimum alignment is the
    ///   cacheline size, i.e. 64-bytes)
    /// @return
    ///   - NULL on error. Not enough memory, or invalid arguments (size is 0,
    ///     align is not a power of two).
    ///   - Otherwise, the pointer to the allocated object.
    pub fn rte_calloc(
        type_: *const ::std::os::raw::c_char,
        num: usize,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Replacement function for realloc(), using huge-page memory. Reserved area
    /// memory is resized, preserving contents. In NUMA systems, the new area
    /// resides on the same NUMA socket as the old area.
    ///
    /// @param ptr
    ///   Pointer to already allocated memory
    /// @param size
    ///   Size (in bytes) of new area. If this is 0, memory is freed.
    /// @param align
    ///   If 0, the return is a pointer that is suitably aligned for any kind of
    ///   variable (in the same manner as malloc()).
    ///   Otherwise, the return is a pointer that is a multiple of *align*. In
    ///   this case, it must obviously be a power of two. (Minimum alignment is the
    ///   cacheline size, i.e. 64-bytes)
    /// @return
    ///   - NULL on error. Not enough memory, or invalid arguments (size is 0,
    ///     align is not a power of two).
    ///   - Otherwise, the pointer to the reallocated memory.
    pub fn rte_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// This function allocates memory from the huge-page area of memory. The memory
    /// is not cleared.
    ///
    /// @param type
    ///   A string identifying the type of allocated objects (useful for debug
    ///   purposes, such as identifying the cause of a memory leak). Can be NULL.
    /// @param size
    ///   Size (in bytes) to be allocated.
    /// @param align
    ///   If 0, the return is a pointer that is suitably aligned for any kind of
    ///   variable (in the same manner as malloc()).
    ///   Otherwise, the return is a pointer that is a multiple of *align*. In
    ///   this case, it must be a power of two. (Minimum alignment is the
    ///   cacheline size, i.e. 64-bytes)
    /// @param socket
    ///   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
    ///   will behave the same as rte_malloc().
    /// @return
    ///   - NULL on error. Not enough memory, or invalid arguments (size is 0,
    ///     align is not a power of two).
    ///   - Otherwise, the pointer to the allocated object.
    pub fn rte_malloc_socket(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Allocate zero'ed memory from the heap.
    ///
    /// Equivalent to rte_malloc() except that the memory zone is
    /// initialised with zeros.
    ///
    /// @param type
    ///   A string identifying the type of allocated objects (useful for debug
    ///   purposes, such as identifying the cause of a memory leak). Can be NULL.
    /// @param size
    ///   Size (in bytes) to be allocated.
    /// @param align
    ///   If 0, the return is a pointer that is suitably aligned for any kind of
    ///   variable (in the same manner as malloc()).
    ///   Otherwise, the return is a pointer that is a multiple of *align*. In
    ///   this case, it must obviously be a power of two. (Minimum alignment is the
    ///   cacheline size, i.e. 64-bytes)
    /// @param socket
    ///   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
    ///   will behave the same as rte_zmalloc().
    /// @return
    ///   - NULL on error. Not enough memory, or invalid arguments (size is 0,
    ///     align is not a power of two).
    ///   - Otherwise, the pointer to the allocated object.
    pub fn rte_zmalloc_socket(
        type_: *const ::std::os::raw::c_char,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Replacement function for calloc(), using huge-page memory. Memory area is
    /// initialised with zeros.
    ///
    /// @param type
    ///   A string identifying the type of allocated objects (useful for debug
    ///   purposes, such as identifying the cause of a memory leak). Can be NULL.
    /// @param num
    ///   Number of elements to be allocated.
    /// @param size
    ///   Size (in bytes) of a single element.
    /// @param align
    ///   If 0, the return is a pointer that is suitably aligned for any kind of
    ///   variable (in the same manner as malloc()).
    ///   Otherwise, the return is a pointer that is a multiple of *align*. In
    ///   this case, it must obviously be a power of two. (Minimum alignment is the
    ///   cacheline size, i.e. 64-bytes)
    /// @param socket
    ///   NUMA socket to allocate memory on. If SOCKET_ID_ANY is used, this function
    ///   will behave the same as rte_calloc().
    /// @return
    ///   - NULL on error. Not enough memory, or invalid arguments (size is 0,
    ///     align is not a power of two).
    ///   - Otherwise, the pointer to the allocated object.
    pub fn rte_calloc_socket(
        type_: *const ::std::os::raw::c_char,
        num: usize,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Frees the memory space pointed to by the provided pointer.
    ///
    /// This pointer must have been returned by a previous call to
    /// rte_malloc(), rte_zmalloc(), rte_calloc() or rte_realloc(). The behaviour of
    /// rte_free() is undefined if the pointer does not match this requirement.
    ///
    /// If the pointer is NULL, the function does nothing.
    ///
    /// @param ptr
    ///   The pointer to memory to be freed.
    pub fn rte_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// If malloc debug is enabled, check a memory block for header
    /// and trailer markers to indicate that all is well with the block.
    /// If size is non-null, also return the size of the block.
    ///
    /// @param ptr
    ///   pointer to the start of a data block, must have been returned
    ///   by a previous call to rte_malloc(), rte_zmalloc(), rte_calloc()
    ///   or rte_realloc()
    /// @param size
    ///   if non-null, and memory block pointer is valid, returns the size
    ///   of the memory block
    /// @return
    ///   -1 on error, invalid pointer passed or header and trailer markers
    ///   are missing or corrupted
    ///   0 on success
    pub fn rte_malloc_validate(
        ptr: *const ::std::os::raw::c_void,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get heap statistics for the specified heap.
    ///
    /// @param socket
    ///   An unsigned integer specifying the socket to get heap statistics for
    /// @param socket_stats
    ///   A structure which provides memory to store statistics
    /// @return
    ///   Null on error
    ///   Pointer to structure storing statistics on success
    pub fn rte_malloc_get_socket_stats(
        socket: ::std::os::raw::c_int,
        socket_stats: *mut rte_malloc_socket_stats,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add memory chunk to a heap with specified name.
    ///
    /// @note Multiple memory chunks can be added to the same heap
    ///
    /// @note Before accessing this memory in other processes, it needs to be
    ///   attached in each of those processes by calling
    ///   ``rte_malloc_heap_memory_attach`` in each other process.
    ///
    /// @note Memory must be previously allocated for DPDK to be able to use it as a
    ///   malloc heap. Failing to do so will result in undefined behavior, up to and
    ///   including segmentation faults.
    ///
    /// @note Calling this function will erase any contents already present at the
    ///   supplied memory address.
    ///
    /// @param heap_name
    ///   Name of the heap to add memory chunk to
    /// @param va_addr
    ///   Start of virtual area to add to the heap
    /// @param len
    ///   Length of virtual area to add to the heap
    /// @param iova_addrs
    ///   Array of page IOVA addresses corresponding to each page in this memory
    ///   area. Can be NULL, in which case page IOVA addresses will be set to
    ///   RTE_BAD_IOVA.
    /// @param n_pages
    ///   Number of elements in the iova_addrs array. Ignored if  ``iova_addrs``
    ///   is NULL.
    /// @param page_sz
    ///   Page size of the underlying memory
    ///
    /// @return
    ///   - 0 on success
    ///   - -1 in case of error, with rte_errno set to one of the following:
    ///     EINVAL - one of the parameters was invalid
    ///     EPERM  - attempted to add memory to a reserved heap
    ///     ENOSPC - no more space in internal config to store a new memory chunk
    pub fn rte_malloc_heap_memory_add(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove memory chunk from heap with specified name.
    ///
    /// @note Memory chunk being removed must be the same as one that was added;
    ///   partially removing memory chunks is not supported
    ///
    /// @note Memory area must not contain any allocated elements to allow its
    ///   removal from the heap
    ///
    /// @note All other processes must detach from the memory chunk prior to it being
    ///   removed from the heap.
    ///
    /// @param heap_name
    ///   Name of the heap to remove memory from
    /// @param va_addr
    ///   Virtual address to remove from the heap
    /// @param len
    ///   Length of virtual area to remove from the heap
    ///
    /// @return
    ///   - 0 on success
    ///   - -1 in case of error, with rte_errno set to one of the following:
    ///     EINVAL - one of the parameters was invalid
    ///     EPERM  - attempted to remove memory from a reserved heap
    ///     ENOENT - heap or memory chunk was not found
    ///     EBUSY  - memory chunk still contains data
    pub fn rte_malloc_heap_memory_remove(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Attach to an already existing chunk of external memory in another process.
    ///
    /// @note This function must be called before any attempt is made to use an
    ///   already existing external memory chunk. This function does *not* need to
    ///   be called if a call to ``rte_malloc_heap_memory_add`` was made in the
    ///   current process.
    ///
    /// @param heap_name
    ///   Heap name to which this chunk of memory belongs
    /// @param va_addr
    ///   Start address of memory chunk to attach to
    /// @param len
    ///   Length of memory chunk to attach to
    /// @return
    ///   0 on successful attach
    ///   -1 on unsuccessful attach, with rte_errno set to indicate cause for error:
    ///     EINVAL - one of the parameters was invalid
    ///     EPERM  - attempted to attach memory to a reserved heap
    ///     ENOENT - heap or memory chunk was not found
    pub fn rte_malloc_heap_memory_attach(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Detach from a chunk of external memory in secondary process.
    ///
    /// @note This function must be called in before any attempt is made to remove
    ///   external memory from the heap in another process. This function does *not*
    ///   need to be called if a call to ``rte_malloc_heap_memory_remove`` will be
    ///   called in current process.
    ///
    /// @param heap_name
    ///   Heap name to which this chunk of memory belongs
    /// @param va_addr
    ///   Start address of memory chunk to attach to
    /// @param len
    ///   Length of memory chunk to attach to
    /// @return
    ///   0 on successful detach
    ///   -1 on unsuccessful detach, with rte_errno set to indicate cause for error:
    ///     EINVAL - one of the parameters was invalid
    ///     EPERM  - attempted to detach memory from a reserved heap
    ///     ENOENT - heap or memory chunk was not found
    pub fn rte_malloc_heap_memory_detach(
        heap_name: *const ::std::os::raw::c_char,
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Creates a new empty malloc heap with a specified name.
    ///
    /// @note Heaps created via this call will automatically get assigned a unique
    ///   socket ID, which can be found using ``rte_malloc_heap_get_socket()``
    ///
    /// @param heap_name
    ///   Name of the heap to create.
    ///
    /// @return
    ///   - 0 on successful creation
    ///   - -1 in case of error, with rte_errno set to one of the following:
    ///     EINVAL - ``heap_name`` was NULL, empty or too long
    ///     EEXIST - heap by name of ``heap_name`` already exists
    ///     ENOSPC - no more space in internal config to store a new heap
    pub fn rte_malloc_heap_create(
        heap_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Destroys a previously created malloc heap with specified name.
    ///
    /// @note This function will return a failure result if not all memory allocated
    ///   from the heap has been freed back to the heap
    ///
    /// @note This function will return a failure result if not all memory segments
    ///   were removed from the heap prior to its destruction
    ///
    /// @param heap_name
    ///   Name of the heap to create.
    ///
    /// @return
    ///   - 0 on success
    ///   - -1 in case of error, with rte_errno set to one of the following:
    ///     EINVAL - ``heap_name`` was NULL, empty or too long
    ///     ENOENT - heap by the name of ``heap_name`` was not found
    ///     EPERM  - attempting to destroy reserved heap
    ///     EBUSY  - heap still contains data
    pub fn rte_malloc_heap_destroy(
        heap_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find socket ID corresponding to a named heap.
    ///
    /// @param name
    ///   Heap name to find socket ID for
    /// @return
    ///   Socket ID in case of success (a non-negative number)
    ///   -1 in case of error, with rte_errno set to one of the following:
    ///     EINVAL - ``name`` was NULL
    ///     ENOENT - heap identified by the name ``name`` was not found
    pub fn rte_malloc_heap_get_socket(name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if a given socket ID refers to externally allocated memory.
    ///
    /// @note Passing SOCKET_ID_ANY will return 0.
    ///
    /// @param socket_id
    ///   Socket ID to check
    /// @return
    ///   1 if socket ID refers to externally allocated memory
    ///   0 if socket ID refers to internal DPDK memory
    ///   -1 if socket ID is invalid
    pub fn rte_malloc_heap_socket_is_external(
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump statistics.
    ///
    /// Dump for the specified type to a file. If the type argument is
    /// NULL, all memory types will be dumped.
    ///
    /// @param f
    ///   A pointer to a file for output
    /// @param type
    ///   A string identifying the type of objects to dump, or NULL
    ///   to dump all objects.
    pub fn rte_malloc_dump_stats(f: *mut FILE, type_: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Dump contents of all malloc heaps to a file.
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_malloc_dump_heaps(f: *mut FILE);
}
extern "C" {
    /// Set the maximum amount of allocated memory for this type.
    ///
    /// This is not yet implemented
    ///
    /// @param type
    ///   A string identifying the type of allocated objects.
    /// @param max
    ///   The maximum amount of allocated bytes for this type.
    /// @return
    ///   - 0: Success.
    ///   - (-1): Error.
    pub fn rte_malloc_set_limit(
        type_: *const ::std::os::raw::c_char,
        max: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the IO address of a virtual address obtained through
    /// rte_malloc
    ///
    /// @param addr
    ///   Address obtained from a previous rte_malloc call
    /// @return
    ///   RTE_BAD_IOVA on error
    ///   otherwise return an address suitable for IO
    pub fn rte_malloc_virt2iova(addr: *const ::std::os::raw::c_void) -> rte_iova_t;
}
/// 64 bits vector size to use with unsigned 8 bits elements.
///
/// a = (rte_v64u8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v64u8_t = [u8; 8usize];
/// 64 bits vector size to use with unsigned 16 bits elements.
///
/// a = (rte_v64u16_t){ a0, a1, a2, a3 }
pub type rte_v64u16_t = [u16; 4usize];
/// 64 bits vector size to use with unsigned 32 bits elements.
///
/// a = (rte_v64u32_t){ a0, a1 }
pub type rte_v64u32_t = [u32; 2usize];
/// 128 bits vector size to use with unsigned 8 bits elements.
///
/// a = (rte_v128u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
///                     a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v128u8_t = [u8; 16usize];
/// 128 bits vector size to use with unsigned 16 bits elements.
///
/// a = (rte_v128u16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v128u16_t = [u16; 8usize];
/// 128 bits vector size to use with unsigned 32 bits elements.
///
/// a = (rte_v128u32_t){ a0, a1, a2, a3, a4 }
pub type rte_v128u32_t = [u32; 4usize];
/// 128 bits vector size to use with unsigned 64 bits elements.
///
/// a = (rte_v128u64_t){ a0, a1 }
pub type rte_v128u64_t = [u64; 2usize];
/// 256 bits vector size to use with unsigned 8 bits elements.
///
/// a = (rte_v256u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
///                     a08, a09, a10, a11, a12, a13, a14, a15,
///                     a16, a17, a18, a19, a20, a21, a22, a23,
///                     a24, a25, a26, a27, a28, a29, a30, a31 }
pub type rte_v256u8_t = [u8; 32usize];
/// 256 bits vector size to use with unsigned 16 bits elements.
///
/// a = (rte_v256u16_t){ a00, a01, a02, a03, a04, a05, a06, a07,
///                      a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v256u16_t = [u16; 16usize];
/// 256 bits vector size to use with unsigned 32 bits elements.
///
/// a = (rte_v256u32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v256u32_t = [u32; 8usize];
/// 256 bits vector size to use with unsigned 64 bits elements.
///
/// a = (rte_v256u64_t){ a0, a1, a2, a3 }
pub type rte_v256u64_t = [u64; 4usize];
/// 64 bits vector size to use with 8 bits elements.
///
/// a = (rte_v64s8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v64s8_t = [i8; 8usize];
/// 64 bits vector size to use with 16 bits elements.
///
/// a = (rte_v64s16_t){ a0, a1, a2, a3 }
pub type rte_v64s16_t = [i16; 4usize];
/// 64 bits vector size to use with 32 bits elements.
///
/// a = (rte_v64s32_t){ a0, a1 }
pub type rte_v64s32_t = [i32; 2usize];
/// 128 bits vector size to use with 8 bits elements.
///
/// a = (rte_v128s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
///                     a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v128s8_t = [i8; 16usize];
/// 128 bits vector size to use with 16 bits elements.
///
/// a = (rte_v128s16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v128s16_t = [i16; 8usize];
/// 128 bits vector size to use with 32 bits elements.
///
/// a = (rte_v128s32_t){ a0, a1, a2, a3 }
pub type rte_v128s32_t = [i32; 4usize];
/// 128 bits vector size to use with 64 bits elements.
///
/// a = (rte_v128s64_t){ a1, a2 }
pub type rte_v128s64_t = [i64; 2usize];
/// 256 bits vector size to use with 8 bits elements.
///
/// a = (rte_v256s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,
///                     a08, a09, a10, a11, a12, a13, a14, a15,
///                     a16, a17, a18, a19, a20, a21, a22, a23,
///                     a24, a25, a26, a27, a28, a29, a30, a31 }
pub type rte_v256s8_t = [i8; 32usize];
/// 256 bits vector size to use with 16 bits elements.
///
/// a = (rte_v256s16_t){ a00, a01, a02, a03, a04, a05, a06, a07,
///                      a08, a09, a10, a11, a12, a13, a14, a15 }
pub type rte_v256s16_t = [i16; 16usize];
/// 256 bits vector size to use with 32 bits elements.
///
/// a = (rte_v256s32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }
pub type rte_v256s32_t = [i32; 8usize];
/// 256 bits vector size to use with 64 bits elements.
///
/// a = (rte_v256s64_t){ a0, a1, a2, a3 }
pub type rte_v256s64_t = [i64; 4usize];
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
pub mod _MM_CMPINT_ENUM {
    pub type Type = u32;
    pub const _MM_CMPINT_EQ: Type = 0;
    pub const _MM_CMPINT_LT: Type = 1;
    pub const _MM_CMPINT_LE: Type = 2;
    pub const _MM_CMPINT_UNUSED: Type = 3;
    pub const _MM_CMPINT_NE: Type = 4;
    pub const _MM_CMPINT_NLT: Type = 5;
    pub const _MM_CMPINT_NLE: Type = 6;
}
pub mod _MM_PERM_ENUM {
    pub type Type = u32;
    pub const _MM_PERM_AAAA: Type = 0;
    pub const _MM_PERM_AAAB: Type = 1;
    pub const _MM_PERM_AAAC: Type = 2;
    pub const _MM_PERM_AAAD: Type = 3;
    pub const _MM_PERM_AABA: Type = 4;
    pub const _MM_PERM_AABB: Type = 5;
    pub const _MM_PERM_AABC: Type = 6;
    pub const _MM_PERM_AABD: Type = 7;
    pub const _MM_PERM_AACA: Type = 8;
    pub const _MM_PERM_AACB: Type = 9;
    pub const _MM_PERM_AACC: Type = 10;
    pub const _MM_PERM_AACD: Type = 11;
    pub const _MM_PERM_AADA: Type = 12;
    pub const _MM_PERM_AADB: Type = 13;
    pub const _MM_PERM_AADC: Type = 14;
    pub const _MM_PERM_AADD: Type = 15;
    pub const _MM_PERM_ABAA: Type = 16;
    pub const _MM_PERM_ABAB: Type = 17;
    pub const _MM_PERM_ABAC: Type = 18;
    pub const _MM_PERM_ABAD: Type = 19;
    pub const _MM_PERM_ABBA: Type = 20;
    pub const _MM_PERM_ABBB: Type = 21;
    pub const _MM_PERM_ABBC: Type = 22;
    pub const _MM_PERM_ABBD: Type = 23;
    pub const _MM_PERM_ABCA: Type = 24;
    pub const _MM_PERM_ABCB: Type = 25;
    pub const _MM_PERM_ABCC: Type = 26;
    pub const _MM_PERM_ABCD: Type = 27;
    pub const _MM_PERM_ABDA: Type = 28;
    pub const _MM_PERM_ABDB: Type = 29;
    pub const _MM_PERM_ABDC: Type = 30;
    pub const _MM_PERM_ABDD: Type = 31;
    pub const _MM_PERM_ACAA: Type = 32;
    pub const _MM_PERM_ACAB: Type = 33;
    pub const _MM_PERM_ACAC: Type = 34;
    pub const _MM_PERM_ACAD: Type = 35;
    pub const _MM_PERM_ACBA: Type = 36;
    pub const _MM_PERM_ACBB: Type = 37;
    pub const _MM_PERM_ACBC: Type = 38;
    pub const _MM_PERM_ACBD: Type = 39;
    pub const _MM_PERM_ACCA: Type = 40;
    pub const _MM_PERM_ACCB: Type = 41;
    pub const _MM_PERM_ACCC: Type = 42;
    pub const _MM_PERM_ACCD: Type = 43;
    pub const _MM_PERM_ACDA: Type = 44;
    pub const _MM_PERM_ACDB: Type = 45;
    pub const _MM_PERM_ACDC: Type = 46;
    pub const _MM_PERM_ACDD: Type = 47;
    pub const _MM_PERM_ADAA: Type = 48;
    pub const _MM_PERM_ADAB: Type = 49;
    pub const _MM_PERM_ADAC: Type = 50;
    pub const _MM_PERM_ADAD: Type = 51;
    pub const _MM_PERM_ADBA: Type = 52;
    pub const _MM_PERM_ADBB: Type = 53;
    pub const _MM_PERM_ADBC: Type = 54;
    pub const _MM_PERM_ADBD: Type = 55;
    pub const _MM_PERM_ADCA: Type = 56;
    pub const _MM_PERM_ADCB: Type = 57;
    pub const _MM_PERM_ADCC: Type = 58;
    pub const _MM_PERM_ADCD: Type = 59;
    pub const _MM_PERM_ADDA: Type = 60;
    pub const _MM_PERM_ADDB: Type = 61;
    pub const _MM_PERM_ADDC: Type = 62;
    pub const _MM_PERM_ADDD: Type = 63;
    pub const _MM_PERM_BAAA: Type = 64;
    pub const _MM_PERM_BAAB: Type = 65;
    pub const _MM_PERM_BAAC: Type = 66;
    pub const _MM_PERM_BAAD: Type = 67;
    pub const _MM_PERM_BABA: Type = 68;
    pub const _MM_PERM_BABB: Type = 69;
    pub const _MM_PERM_BABC: Type = 70;
    pub const _MM_PERM_BABD: Type = 71;
    pub const _MM_PERM_BACA: Type = 72;
    pub const _MM_PERM_BACB: Type = 73;
    pub const _MM_PERM_BACC: Type = 74;
    pub const _MM_PERM_BACD: Type = 75;
    pub const _MM_PERM_BADA: Type = 76;
    pub const _MM_PERM_BADB: Type = 77;
    pub const _MM_PERM_BADC: Type = 78;
    pub const _MM_PERM_BADD: Type = 79;
    pub const _MM_PERM_BBAA: Type = 80;
    pub const _MM_PERM_BBAB: Type = 81;
    pub const _MM_PERM_BBAC: Type = 82;
    pub const _MM_PERM_BBAD: Type = 83;
    pub const _MM_PERM_BBBA: Type = 84;
    pub const _MM_PERM_BBBB: Type = 85;
    pub const _MM_PERM_BBBC: Type = 86;
    pub const _MM_PERM_BBBD: Type = 87;
    pub const _MM_PERM_BBCA: Type = 88;
    pub const _MM_PERM_BBCB: Type = 89;
    pub const _MM_PERM_BBCC: Type = 90;
    pub const _MM_PERM_BBCD: Type = 91;
    pub const _MM_PERM_BBDA: Type = 92;
    pub const _MM_PERM_BBDB: Type = 93;
    pub const _MM_PERM_BBDC: Type = 94;
    pub const _MM_PERM_BBDD: Type = 95;
    pub const _MM_PERM_BCAA: Type = 96;
    pub const _MM_PERM_BCAB: Type = 97;
    pub const _MM_PERM_BCAC: Type = 98;
    pub const _MM_PERM_BCAD: Type = 99;
    pub const _MM_PERM_BCBA: Type = 100;
    pub const _MM_PERM_BCBB: Type = 101;
    pub const _MM_PERM_BCBC: Type = 102;
    pub const _MM_PERM_BCBD: Type = 103;
    pub const _MM_PERM_BCCA: Type = 104;
    pub const _MM_PERM_BCCB: Type = 105;
    pub const _MM_PERM_BCCC: Type = 106;
    pub const _MM_PERM_BCCD: Type = 107;
    pub const _MM_PERM_BCDA: Type = 108;
    pub const _MM_PERM_BCDB: Type = 109;
    pub const _MM_PERM_BCDC: Type = 110;
    pub const _MM_PERM_BCDD: Type = 111;
    pub const _MM_PERM_BDAA: Type = 112;
    pub const _MM_PERM_BDAB: Type = 113;
    pub const _MM_PERM_BDAC: Type = 114;
    pub const _MM_PERM_BDAD: Type = 115;
    pub const _MM_PERM_BDBA: Type = 116;
    pub const _MM_PERM_BDBB: Type = 117;
    pub const _MM_PERM_BDBC: Type = 118;
    pub const _MM_PERM_BDBD: Type = 119;
    pub const _MM_PERM_BDCA: Type = 120;
    pub const _MM_PERM_BDCB: Type = 121;
    pub const _MM_PERM_BDCC: Type = 122;
    pub const _MM_PERM_BDCD: Type = 123;
    pub const _MM_PERM_BDDA: Type = 124;
    pub const _MM_PERM_BDDB: Type = 125;
    pub const _MM_PERM_BDDC: Type = 126;
    pub const _MM_PERM_BDDD: Type = 127;
    pub const _MM_PERM_CAAA: Type = 128;
    pub const _MM_PERM_CAAB: Type = 129;
    pub const _MM_PERM_CAAC: Type = 130;
    pub const _MM_PERM_CAAD: Type = 131;
    pub const _MM_PERM_CABA: Type = 132;
    pub const _MM_PERM_CABB: Type = 133;
    pub const _MM_PERM_CABC: Type = 134;
    pub const _MM_PERM_CABD: Type = 135;
    pub const _MM_PERM_CACA: Type = 136;
    pub const _MM_PERM_CACB: Type = 137;
    pub const _MM_PERM_CACC: Type = 138;
    pub const _MM_PERM_CACD: Type = 139;
    pub const _MM_PERM_CADA: Type = 140;
    pub const _MM_PERM_CADB: Type = 141;
    pub const _MM_PERM_CADC: Type = 142;
    pub const _MM_PERM_CADD: Type = 143;
    pub const _MM_PERM_CBAA: Type = 144;
    pub const _MM_PERM_CBAB: Type = 145;
    pub const _MM_PERM_CBAC: Type = 146;
    pub const _MM_PERM_CBAD: Type = 147;
    pub const _MM_PERM_CBBA: Type = 148;
    pub const _MM_PERM_CBBB: Type = 149;
    pub const _MM_PERM_CBBC: Type = 150;
    pub const _MM_PERM_CBBD: Type = 151;
    pub const _MM_PERM_CBCA: Type = 152;
    pub const _MM_PERM_CBCB: Type = 153;
    pub const _MM_PERM_CBCC: Type = 154;
    pub const _MM_PERM_CBCD: Type = 155;
    pub const _MM_PERM_CBDA: Type = 156;
    pub const _MM_PERM_CBDB: Type = 157;
    pub const _MM_PERM_CBDC: Type = 158;
    pub const _MM_PERM_CBDD: Type = 159;
    pub const _MM_PERM_CCAA: Type = 160;
    pub const _MM_PERM_CCAB: Type = 161;
    pub const _MM_PERM_CCAC: Type = 162;
    pub const _MM_PERM_CCAD: Type = 163;
    pub const _MM_PERM_CCBA: Type = 164;
    pub const _MM_PERM_CCBB: Type = 165;
    pub const _MM_PERM_CCBC: Type = 166;
    pub const _MM_PERM_CCBD: Type = 167;
    pub const _MM_PERM_CCCA: Type = 168;
    pub const _MM_PERM_CCCB: Type = 169;
    pub const _MM_PERM_CCCC: Type = 170;
    pub const _MM_PERM_CCCD: Type = 171;
    pub const _MM_PERM_CCDA: Type = 172;
    pub const _MM_PERM_CCDB: Type = 173;
    pub const _MM_PERM_CCDC: Type = 174;
    pub const _MM_PERM_CCDD: Type = 175;
    pub const _MM_PERM_CDAA: Type = 176;
    pub const _MM_PERM_CDAB: Type = 177;
    pub const _MM_PERM_CDAC: Type = 178;
    pub const _MM_PERM_CDAD: Type = 179;
    pub const _MM_PERM_CDBA: Type = 180;
    pub const _MM_PERM_CDBB: Type = 181;
    pub const _MM_PERM_CDBC: Type = 182;
    pub const _MM_PERM_CDBD: Type = 183;
    pub const _MM_PERM_CDCA: Type = 184;
    pub const _MM_PERM_CDCB: Type = 185;
    pub const _MM_PERM_CDCC: Type = 186;
    pub const _MM_PERM_CDCD: Type = 187;
    pub const _MM_PERM_CDDA: Type = 188;
    pub const _MM_PERM_CDDB: Type = 189;
    pub const _MM_PERM_CDDC: Type = 190;
    pub const _MM_PERM_CDDD: Type = 191;
    pub const _MM_PERM_DAAA: Type = 192;
    pub const _MM_PERM_DAAB: Type = 193;
    pub const _MM_PERM_DAAC: Type = 194;
    pub const _MM_PERM_DAAD: Type = 195;
    pub const _MM_PERM_DABA: Type = 196;
    pub const _MM_PERM_DABB: Type = 197;
    pub const _MM_PERM_DABC: Type = 198;
    pub const _MM_PERM_DABD: Type = 199;
    pub const _MM_PERM_DACA: Type = 200;
    pub const _MM_PERM_DACB: Type = 201;
    pub const _MM_PERM_DACC: Type = 202;
    pub const _MM_PERM_DACD: Type = 203;
    pub const _MM_PERM_DADA: Type = 204;
    pub const _MM_PERM_DADB: Type = 205;
    pub const _MM_PERM_DADC: Type = 206;
    pub const _MM_PERM_DADD: Type = 207;
    pub const _MM_PERM_DBAA: Type = 208;
    pub const _MM_PERM_DBAB: Type = 209;
    pub const _MM_PERM_DBAC: Type = 210;
    pub const _MM_PERM_DBAD: Type = 211;
    pub const _MM_PERM_DBBA: Type = 212;
    pub const _MM_PERM_DBBB: Type = 213;
    pub const _MM_PERM_DBBC: Type = 214;
    pub const _MM_PERM_DBBD: Type = 215;
    pub const _MM_PERM_DBCA: Type = 216;
    pub const _MM_PERM_DBCB: Type = 217;
    pub const _MM_PERM_DBCC: Type = 218;
    pub const _MM_PERM_DBCD: Type = 219;
    pub const _MM_PERM_DBDA: Type = 220;
    pub const _MM_PERM_DBDB: Type = 221;
    pub const _MM_PERM_DBDC: Type = 222;
    pub const _MM_PERM_DBDD: Type = 223;
    pub const _MM_PERM_DCAA: Type = 224;
    pub const _MM_PERM_DCAB: Type = 225;
    pub const _MM_PERM_DCAC: Type = 226;
    pub const _MM_PERM_DCAD: Type = 227;
    pub const _MM_PERM_DCBA: Type = 228;
    pub const _MM_PERM_DCBB: Type = 229;
    pub const _MM_PERM_DCBC: Type = 230;
    pub const _MM_PERM_DCBD: Type = 231;
    pub const _MM_PERM_DCCA: Type = 232;
    pub const _MM_PERM_DCCB: Type = 233;
    pub const _MM_PERM_DCCC: Type = 234;
    pub const _MM_PERM_DCCD: Type = 235;
    pub const _MM_PERM_DCDA: Type = 236;
    pub const _MM_PERM_DCDB: Type = 237;
    pub const _MM_PERM_DCDC: Type = 238;
    pub const _MM_PERM_DCDD: Type = 239;
    pub const _MM_PERM_DDAA: Type = 240;
    pub const _MM_PERM_DDAB: Type = 241;
    pub const _MM_PERM_DDAC: Type = 242;
    pub const _MM_PERM_DDAD: Type = 243;
    pub const _MM_PERM_DDBA: Type = 244;
    pub const _MM_PERM_DDBB: Type = 245;
    pub const _MM_PERM_DDBC: Type = 246;
    pub const _MM_PERM_DDBD: Type = 247;
    pub const _MM_PERM_DDCA: Type = 248;
    pub const _MM_PERM_DDCB: Type = 249;
    pub const _MM_PERM_DDCC: Type = 250;
    pub const _MM_PERM_DDCD: Type = 251;
    pub const _MM_PERM_DDDA: Type = 252;
    pub const _MM_PERM_DDDB: Type = 253;
    pub const _MM_PERM_DDDC: Type = 254;
    pub const _MM_PERM_DDDD: Type = 255;
}
pub mod _MM_MANTISSA_NORM_ENUM {
    pub type Type = u32;
    pub const _MM_MANT_NORM_1_2: Type = 0;
    pub const _MM_MANT_NORM_p5_2: Type = 1;
    pub const _MM_MANT_NORM_p5_1: Type = 2;
    pub const _MM_MANT_NORM_p75_1p5: Type = 3;
}
pub mod _MM_MANTISSA_SIGN_ENUM {
    pub type Type = u32;
    pub const _MM_MANT_SIGN_src: Type = 0;
    pub const _MM_MANT_SIGN_zero: Type = 1;
    pub const _MM_MANT_SIGN_nan: Type = 2;
}
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type xmm_t = __m128i;
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8: [u8; 16usize],
    pub u16: [u16; 8usize],
    pub u32: [u32; 4usize],
    pub u64: [u64; 2usize],
    pub pd: [f64; 2usize],
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_xmm() {
    assert_eq!(
        ::std::mem::size_of::<rte_xmm>(),
        16usize,
        concat!("Size of: ", stringify!(rte_xmm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(pd)
        )
    );
}
impl Default for rte_xmm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_xmm_t = rte_xmm;
pub type ymm_t = __m256i;
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ymm {
    pub y: ymm_t,
    pub x: [xmm_t; 2usize],
    pub u8: [u8; 32usize],
    pub u16: [u16; 16usize],
    pub u32: [u32; 8usize],
    pub u64: [u64; 4usize],
    pub pd: [f64; 4usize],
    _bindgen_union_align: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_rte_ymm() {
    assert_eq!(
        ::std::mem::size_of::<rte_ymm>(),
        32usize,
        concat!("Size of: ", stringify!(rte_ymm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).y as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ymm>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ymm),
            "::",
            stringify!(pd)
        )
    );
}
impl Default for rte_ymm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_ymm_t = rte_ymm;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "\u{1}__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub mod _bindgen_ty_2 {
    pub type Type = u32;
    pub const PTHREAD_CREATE_JOINABLE: Type = 0;
    pub const PTHREAD_CREATE_DETACHED: Type = 1;
}
pub mod _bindgen_ty_3 {
    pub type Type = u32;
    pub const PTHREAD_MUTEX_TIMED_NP: Type = 0;
    pub const PTHREAD_MUTEX_RECURSIVE_NP: Type = 1;
    pub const PTHREAD_MUTEX_ERRORCHECK_NP: Type = 2;
    pub const PTHREAD_MUTEX_ADAPTIVE_NP: Type = 3;
    pub const PTHREAD_MUTEX_NORMAL: Type = 0;
    pub const PTHREAD_MUTEX_RECURSIVE: Type = 1;
    pub const PTHREAD_MUTEX_ERRORCHECK: Type = 2;
    pub const PTHREAD_MUTEX_DEFAULT: Type = 0;
}
pub mod _bindgen_ty_4 {
    pub type Type = u32;
    pub const PTHREAD_MUTEX_STALLED: Type = 0;
    pub const PTHREAD_MUTEX_STALLED_NP: Type = 0;
    pub const PTHREAD_MUTEX_ROBUST: Type = 1;
    pub const PTHREAD_MUTEX_ROBUST_NP: Type = 1;
}
pub mod _bindgen_ty_5 {
    pub type Type = u32;
    pub const PTHREAD_PRIO_NONE: Type = 0;
    pub const PTHREAD_PRIO_INHERIT: Type = 1;
    pub const PTHREAD_PRIO_PROTECT: Type = 2;
}
pub mod _bindgen_ty_6 {
    pub type Type = u32;
    pub const PTHREAD_RWLOCK_PREFER_READER_NP: Type = 0;
    pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: Type = 1;
    pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: Type = 2;
    pub const PTHREAD_RWLOCK_DEFAULT_NP: Type = 0;
}
pub mod _bindgen_ty_7 {
    pub type Type = u32;
    pub const PTHREAD_INHERIT_SCHED: Type = 0;
    pub const PTHREAD_EXPLICIT_SCHED: Type = 1;
}
pub mod _bindgen_ty_8 {
    pub type Type = u32;
    pub const PTHREAD_SCOPE_SYSTEM: Type = 0;
    pub const PTHREAD_SCOPE_PROCESS: Type = 1;
}
pub mod _bindgen_ty_9 {
    pub type Type = u32;
    pub const PTHREAD_PROCESS_PRIVATE: Type = 0;
    pub const PTHREAD_PROCESS_SHARED: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_10 {
    pub type Type = u32;
    pub const PTHREAD_CANCEL_ENABLE: Type = 0;
    pub const PTHREAD_CANCEL_DISABLE: Type = 1;
}
pub mod _bindgen_ty_11 {
    pub type Type = u32;
    pub const PTHREAD_CANCEL_DEFERRED: Type = 0;
    pub const PTHREAD_CANCEL_ASYNCHRONOUS: Type = 1;
}
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}per_lcore__rte_errno"]
    pub static mut per_lcore__rte_errno: ::std::os::raw::c_int;
}
extern "C" {
    /// Function which returns a printable string describing a particular
    /// error code. For non-RTE-specific error codes, this function returns
    /// the value from the libc strerror function.
    ///
    /// @param errnum
    ///   The error number to be looked up - generally the value of rte_errno
    /// @return
    ///   A pointer to a thread-local string containing the text describing
    ///   the error.
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub mod _bindgen_ty_12 {
    /// Error types
    pub type Type = u32;
    ///< Start numbering above std errno vals
    pub const RTE_MIN_ERRNO: Type = 1000;
    ///< Operation not allowed in secondary processes
    pub const E_RTE_SECONDARY: Type = 1001;
    ///< Missing rte_config
    pub const E_RTE_NO_CONFIG: Type = 1002;
    ///< Max RTE error number
    pub const RTE_MAX_ERRNO: Type = 1003;
}
pub mod rte_lcore_state_t {
    /// State of an lcore.
    pub type Type = u32;
    ///< waiting a new command
    pub const WAIT: Type = 0;
    ///< executing command
    pub const RUNNING: Type = 1;
    ///< command executed
    pub const FINISHED: Type = 2;
}
/// Definition of a remote launch function.
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Launch a function on another lcore.
    ///
    /// To be executed on the MASTER lcore only.
    ///
    /// Sends a message to a slave lcore (identified by the slave_id) that
    /// is in the WAIT state (this is true after the first call to
    /// rte_eal_init()). This can be checked by first calling
    /// rte_eal_wait_lcore(slave_id).
    ///
    /// When the remote lcore receives the message, it switches to
    /// the RUNNING state, then calls the function f with argument arg. Once the
    /// execution is done, the remote lcore switches to a FINISHED state and
    /// the return value of f is stored in a local variable to be read using
    /// rte_eal_wait_lcore().
    ///
    /// The MASTER lcore returns as soon as the message is sent and knows
    /// nothing about the completion of f.
    ///
    /// Note: This function is not designed to offer optimum
    /// performance. It is just a practical way to launch a function on
    /// another lcore at initialization time.
    ///
    /// @param f
    ///   The function to be called.
    /// @param arg
    ///   The argument for the function.
    /// @param slave_id
    ///   The identifier of the lcore on which the function should be executed.
    /// @return
    ///   - 0: Success. Execution of function f started on the remote lcore.
    ///   - (-EBUSY): The remote lcore is not in a WAIT state.
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        slave_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_rmt_call_master_t {
    /// This enum indicates whether the master core must execute the handler
    /// launched on all logical cores.
    pub type Type = u32;
    ///< lcore handler not executed by master core.
    pub const SKIP_MASTER: Type = 0;
    ///< lcore handler executed by master core.
    pub const CALL_MASTER: Type = 1;
}
extern "C" {
    /// Launch a function on all lcores.
    ///
    /// Check that each SLAVE lcore is in a WAIT state, then call
    /// rte_eal_remote_launch() for each lcore.
    ///
    /// @param f
    ///   The function to be called.
    /// @param arg
    ///   The argument for the function.
    /// @param call_master
    ///   If call_master set to SKIP_MASTER, the MASTER lcore does not call
    ///   the function. If call_master is set to CALL_MASTER, the function
    ///   is also called on master before returning. In any case, the master
    ///   lcore returns as soon as it finished its job and knows nothing
    ///   about the completion of f on the other lcores.
    /// @return
    ///   - 0: Success. Execution of function f started on all remote lcores.
    ///   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this
    ///     case, no message is sent to any of the lcores.
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_master: rte_rmt_call_master_t::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the state of the lcore identified by slave_id.
    ///
    /// To be executed on the MASTER lcore only.
    ///
    /// @param slave_id
    ///   The identifier of the lcore.
    /// @return
    ///   The state of the lcore.
    pub fn rte_eal_get_lcore_state(slave_id: ::std::os::raw::c_uint) -> rte_lcore_state_t::Type;
}
extern "C" {
    /// Wait until an lcore finishes its job.
    ///
    /// To be executed on the MASTER lcore only.
    ///
    /// If the slave lcore identified by the slave_id is in a FINISHED state,
    /// switch to the WAIT state. If the lcore is in RUNNING state, wait until
    /// the lcore finishes its job and moves to the FINISHED state.
    ///
    /// @param slave_id
    ///   The identifier of the lcore.
    /// @return
    ///   - 0: If the lcore identified by the slave_id is in a WAIT state.
    ///   - The value that was returned by the previous remote launch
    ///     function call if the lcore identified by the slave_id was in a
    ///     FINISHED or RUNNING state. In this case, it changes the state
    ///     of the lcore to WAIT.
    pub fn rte_eal_wait_lcore(slave_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wait until all lcores finish their jobs.
    ///
    /// To be executed on the MASTER lcore only. Issue an
    /// rte_eal_wait_lcore() for every lcore. The return values are
    /// ignored.
    ///
    /// After a call to rte_eal_mp_wait_lcore(), the caller can assume
    /// that all slave lcores are in a WAIT state.
    pub fn rte_eal_mp_wait_lcore();
}
/// The atomic counter structure.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic16_t {
    ///< An internal counter value.
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic16_t>(),
        2usize,
        concat!("Size of: ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic16_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic16_t),
            "::",
            stringify!(cnt)
        )
    );
}
/// The atomic counter structure.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic32_t {
    ///< An internal counter value.
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_atomic32_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic32_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic32_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic32_t),
            "::",
            stringify!(cnt)
        )
    );
}
/// The atomic counter structure.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_atomic64_t {
    ///< Internal counter value.
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout_rte_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic64_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic64_t),
            "::",
            stringify!(cnt)
        )
    );
}
extern "C" {
    /// Dump the stack of the calling core to the console.
    pub fn rte_dump_stack();
}
extern "C" {
    /// Dump the registers of the calling core to the console.
    ///
    /// Note: Not implemented in a userapp environment; use gdb instead.
    pub fn rte_dump_registers();
}
extern "C" {
    pub fn __rte_panic(
        funcname: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
pub mod timer_source {
    pub type Type = u32;
    pub const EAL_TIMER_TSC: Type = 0;
    pub const EAL_TIMER_HPET: Type = 1;
}
extern "C" {
    #[link_name = "\u{1}eal_timer_source"]
    pub static mut eal_timer_source: timer_source::Type;
}
extern "C" {
    /// Get the measured frequency of the RDTSC counter
    ///
    /// @return
    ///   The TSC frequency for this lcore
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    #[link_name = "\u{1}rte_delay_us"]
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
extern "C" {
    /// Blocking delay function.
    ///
    /// @param us
    ///   Number of microseconds to wait.
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    /// Delay function that uses system sleep.
    /// Does not block the CPU core.
    ///
    /// @param us
    ///   Number of microseconds to wait.
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
extern "C" {
    /// Replace rte_delay_us with user defined function.
    ///
    /// @param userfunc
    ///   User function which replaces rte_delay_us. rte_delay_us_block restores
    ///   buildin block delay function.
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
extern "C" {
    #[link_name = "\u{1}rte_cycles_vmware_tsc_map"]
    pub static mut rte_cycles_vmware_tsc_map: ::std::os::raw::c_int;
}
pub mod rte_dev_event_type {
    /// The device event type.
    pub type Type = u32;
    ///< device being added
    pub const RTE_DEV_EVENT_ADD: Type = 0;
    ///< device being removed
    pub const RTE_DEV_EVENT_REMOVE: Type = 1;
    ///< max value of this enum
    pub const RTE_DEV_EVENT_MAX: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_event {
    ///< device event type
    pub type_: rte_dev_event_type::Type,
    ///< subsystem id
    pub subsystem: ::std::os::raw::c_int,
    ///< device name
    pub devname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_dev_event() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_event>(),
        16usize,
        concat!("Size of: ", stringify!(rte_dev_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).subsystem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).devname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(devname)
        )
    );
}
impl Default for rte_dev_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type rte_dev_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type::Type,
        cb_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub mod rte_kernel_driver {
    /// Device driver.
    pub type Type = u32;
    pub const RTE_KDRV_UNKNOWN: Type = 0;
    pub const RTE_KDRV_IGB_UIO: Type = 1;
    pub const RTE_KDRV_VFIO: Type = 2;
    pub const RTE_KDRV_UIO_GENERIC: Type = 3;
    pub const RTE_KDRV_NIC_UIO: Type = 4;
    pub const RTE_KDRV_NONE: Type = 5;
}
pub mod rte_dev_policy {
    /// Device policies.
    pub type Type = u32;
    pub const RTE_DEV_WHITELISTED: Type = 0;
    pub const RTE_DEV_BLACKLISTED: Type = 1;
}
/// A generic memory resource representation.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mem_resource {
    ///< Physical address, 0 if not resource.
    pub phys_addr: u64,
    ///< Length of the resource.
    pub len: u64,
    ///< Virtual address, NULL when not mapped.
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_mem_resource() {
    assert_eq!(
        ::std::mem::size_of::<rte_mem_resource>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mem_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).phys_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for rte_mem_resource {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure describing a device driver.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_driver {
    ///< Next in list.
    pub next: rte_driver__bindgen_ty_1,
    ///< Driver name.
    pub name: *const ::std::os::raw::c_char,
    ///< Driver alias.
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[test]
fn bindgen_test_layout_rte_driver__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_driver__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_driver() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver>(),
        32usize,
        concat!("Size of: ", stringify!(rte_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).alias as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for rte_driver {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure describing a generic device.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_device {
    ///< Next device
    pub next: rte_device__bindgen_ty_1,
    ///< Device name
    pub name: *const ::std::os::raw::c_char,
    ///< Driver assigned after probing
    pub driver: *const rte_driver,
    ///< Bus handle assigned on scan
    pub bus: *const rte_bus,
    ///< NUMA node connection
    pub numa_node: ::std::os::raw::c_int,
    ///< Arguments for latest probing
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[test]
fn bindgen_test_layout_rte_device__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_device__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_device__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_device() {
    assert_eq!(
        ::std::mem::size_of::<rte_device>(),
        56usize,
        concat!("Size of: ", stringify!(rte_device))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).driver as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).bus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).numa_node as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).devargs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(devargs)
        )
    );
}
impl Default for rte_device {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Query status of a device.
    ///
    /// @param dev
    ///   Generic device pointer.
    /// @return
    ///   (int)true if already probed successfully, 0 otherwise.
    pub fn rte_dev_is_probed(dev: *const rte_device) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Hotplug add a given device to a specific bus.
    ///
    /// In multi-process, it will request other processes to add the same device.
    /// A failure, in any process, will rollback the action
    ///
    /// @param busname
    ///   The bus name the device is added to.
    /// @param devname
    ///   The device name. Based on this device name, eal will identify a driver
    ///   capable of handling it and pass it to the driver probing function.
    /// @param drvargs
    ///   Device arguments to be passed to the driver.
    /// @return
    ///   0 on success, negative on error.
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        drvargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add matching devices.
    ///
    /// In multi-process, it will request other processes to add the same device.
    /// A failure, in any process, will rollback the action
    ///
    /// @param devargs
    ///   Device arguments including bus, class and driver properties.
    /// @return
    ///   0 on success, negative on error.
    pub fn rte_dev_probe(devargs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Hotplug remove a given device from a specific bus.
    ///
    /// In multi-process, it will request other processes to remove the same device.
    /// A failure, in any process, will rollback the action
    ///
    /// @param busname
    ///   The bus name the device is removed from.
    /// @param devname
    ///   The device name being removed.
    /// @return
    ///   0 on success, negative on error.
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove one device.
    ///
    /// In multi-process, it will request other processes to remove the same device.
    /// A failure, in any process, will rollback the action
    ///
    /// @param dev
    ///   Data structure of the device to remove.
    /// @return
    ///   0 on success, negative on error.
    pub fn rte_dev_remove(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
/// Device comparison function.
///
/// This type of function is used to compare an rte_device with arbitrary
/// data.
///
/// @param dev
///   Device handle.
///
/// @param data
///   Data to compare against. The type of this parameter is determined by
///   the kind of comparison performed by the function.
///
/// @return
///   0 if the device matches the data.
///   !0 if the device does not match.
///   <0 if ordering is possible and the device is lower than the data.
///   >0 if ordering is possible and the device is greater than the data.
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *const rte_device, data: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
/// Iteration context.
///
/// This context carries over the current iteration state.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_iterator {
    ///< device string.
    pub dev_str: *const ::std::os::raw::c_char,
    ///< bus-related part of device string.
    pub bus_str: *const ::std::os::raw::c_char,
    ///< class-related part of device string.
    pub cls_str: *const ::std::os::raw::c_char,
    ///< bus handle.
    pub bus: *mut rte_bus,
    ///< class handle.
    pub cls: *mut rte_class,
    ///< current position.
    pub device: *mut rte_device,
    ///< additional specialized context.
    pub class_device: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_dev_iterator() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_iterator>(),
        56usize,
        concat!("Size of: ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).dev_str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(dev_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus_str as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(bus_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls_str as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(cls_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).class_device as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(class_device)
        )
    );
}
impl Default for rte_dev_iterator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Device iteration function.
///
/// Find the next device matching properties passed in parameters.
/// The function takes an additional ``start`` parameter, that is
/// used as starting context when relevant.
///
/// The function returns the current element in the iteration.
/// This return value will potentially be used as a start parameter
/// in subsequent calls to the function.
///
/// The additional iterator parameter is only there if a specific
/// implementation needs additional context. It must not be modified by
/// the iteration function itself.
///
/// @param start
///   Starting iteration context.
///
/// @param devstr
///   Device description string.
///
/// @param it
///   Device iterator.
///
/// @return
///   The address of the current element matching the device description
///   string.
pub type rte_dev_iterate_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const ::std::os::raw::c_void,
        devstr: *const ::std::os::raw::c_char,
        it: *const rte_dev_iterator,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    /// Initializes a device iterator.
    ///
    /// This iterator allows accessing a list of devices matching a criteria.
    /// The device matching is made among all buses and classes currently registered,
    /// filtered by the device description given as parameter.
    ///
    /// This function will not allocate any memory. It is safe to stop the
    /// iteration at any moment and let the iterator go out of context.
    ///
    /// @param it
    ///   Device iterator handle.
    ///
    /// @param str
    ///   Device description string.
    ///
    /// @return
    ///   0 on successful initialization.
    ///   <0 on error.
    pub fn rte_dev_iterator_init(
        it: *mut rte_dev_iterator,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Iterates on a device iterator.
    ///
    /// Generates a new rte_device handle corresponding to the next element
    /// in the list described in comprehension by the iterator.
    ///
    /// The next object is returned, and the iterator is updated.
    ///
    /// @param it
    ///   Device iterator handle.
    ///
    /// @return
    ///   An rte_device handle if found.
    ///   NULL if an error occurred (rte_errno is set).
    ///   NULL if no device could be found (rte_errno is not set).
    pub fn rte_dev_iterator_next(it: *mut rte_dev_iterator) -> *mut rte_device;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// It registers the callback for the specific device.
    /// Multiple callbacks cal be registered at the same time.
    ///
    /// @param device_name
    ///  The device name, that is the param name of the struct rte_device,
    ///  null value means for all devices.
    /// @param cb_fn
    ///  callback address.
    /// @param cb_arg
    ///  address of parameter for callback.
    ///
    /// @return
    ///  - On success, zero.
    ///  - On failure, a negative value.
    pub fn rte_dev_event_callback_register(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// It unregisters the callback according to the specified device.
    ///
    /// @param device_name
    ///  The device name, that is the param name of the struct rte_device,
    ///  null value means for all devices and their callbacks.
    /// @param cb_fn
    ///  callback address.
    /// @param cb_arg
    ///  address of parameter for callback, (void *)-1 means to remove all
    ///  registered which has the same callback address.
    ///
    /// @return
    ///  - On success, return the number of callback entities removed.
    ///  - On failure, a negative value.
    pub fn rte_dev_event_callback_unregister(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Executes all the user application registered callbacks for
    /// the specific device.
    ///
    /// @param device_name
    ///  The device name.
    /// @param event
    ///  the device event type.
    pub fn rte_dev_event_callback_process(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type::Type,
    );
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Start the device event monitoring.
    ///
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_dev_event_monitor_start() -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Stop the device event monitoring.
    ///
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_dev_event_monitor_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Enable hotplug handling for devices.
    ///
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_dev_hotplug_handle_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Disable hotplug handling for devices.
    ///
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_dev_hotplug_handle_disable() -> ::std::os::raw::c_int;
}
/// Double linked list of buses
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for rte_bus_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_iova_mode {
    /// IOVA mapping mode.
    ///
    /// IOVA mapping mode is iommu programming mode of a device.
    /// That device (for example: IOMMU backed DMA device) based
    /// on rte_iova_mode will generate physical or virtual address.
    ///
    pub type Type = u32;
    pub const RTE_IOVA_DC: Type = 0;
    pub const RTE_IOVA_PA: Type = 1;
    pub const RTE_IOVA_VA: Type = 2;
}
/// Bus specific scan for devices attached on the bus.
/// For each bus object, the scan would be responsible for finding devices and
/// adding them to its private device list.
///
/// A bus should mandatorily implement this method.
///
/// @return
///	0 for successful scan
///	<0 for unsuccessful scan with error value
pub type rte_bus_scan_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
/// Implementation specific probe function which is responsible for linking
/// devices on that bus with applicable drivers.
///
/// This is called while iterating over each registered bus.
///
/// @return
///	0 for successful probe
///	!0 for any error while probing
pub type rte_bus_probe_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
/// Device iterator to find a device on a bus.
///
/// This function returns an rte_device if one of those held by the bus
/// matches the data passed as parameter.
///
/// If the comparison function returns zero this function should stop iterating
/// over any more devices. To continue a search the device of a previous search
/// can be passed via the start parameter.
///
/// @param cmp
///	Comparison function.
///
/// @param data
///	Data to compare each device against.
///
/// @param start
///	starting point for the iteration
///
/// @return
///	The first device matching the data, NULL if none exists.
pub type rte_bus_find_device_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const rte_device,
        cmp: rte_dev_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_device,
>;
/// Implementation specific probe function which is responsible for linking
/// devices on that bus with applicable drivers.
///
/// @param dev
///	Device pointer that was returned by a previous call to find_device.
///
/// @return
///	0 on success.
///	!0 on error.
pub type rte_bus_plug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
/// Implementation specific remove function which is responsible for unlinking
/// devices on that bus from assigned driver.
///
/// @param dev
///	Device pointer that was returned by a previous call to find_device.
///
/// @return
///	0 on success.
///	!0 on error.
pub type rte_bus_unplug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
/// Bus specific parsing function.
/// Validates the syntax used in the textual representation of a device,
/// If the syntax is valid and ``addr`` is not NULL, writes the bus-specific
/// device representation to ``addr``.
///
/// @param[in] name
///	device textual description
///
/// @param[out] addr
///	device information location address, into which parsed info
///	should be written. If NULL, nothing should be written, which
///	is not an error.
///
/// @return
///	0 if parsing was successful.
///	!0 for any error.
pub type rte_bus_parse_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char, addr: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
/// Implement a specific hot-unplug handler, which is responsible for
/// handle the failure when device be hot-unplugged. When the event of
/// hot-unplug be detected, it could call this function to handle
/// the hot-unplug failure and avoid app crash.
/// @param dev
///	Pointer of the device structure.
///
/// @return
///	0 on success.
///	!0 on error.
pub type rte_bus_hot_unplug_handler_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
/// Implement a specific sigbus handler, which is responsible for handling
/// the sigbus error which is either original memory error, or specific memory
/// error that caused of device be hot-unplugged. When sigbus error be captured,
/// it could call this function to handle sigbus error.
/// @param failure_addr
///	Pointer of the fault address of the sigbus error.
///
/// @return
///	0 for success handle the sigbus for hot-unplug.
///	1 for not process it, because it is a generic sigbus error.
///	-1 for failed to handle the sigbus for hot-unplug.
pub type rte_bus_sigbus_handler_t = ::std::option::Option<
    unsafe extern "C" fn(failure_addr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub mod rte_bus_scan_mode {
    /// Bus scan policies
    pub type Type = u32;
    pub const RTE_BUS_SCAN_UNDEFINED: Type = 0;
    pub const RTE_BUS_SCAN_WHITELIST: Type = 1;
    pub const RTE_BUS_SCAN_BLACKLIST: Type = 2;
}
/// A structure used to configure bus operations.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus_conf {
    ///< Scan policy.
    pub scan_mode: rte_bus_scan_mode::Type,
}
#[test]
fn bindgen_test_layout_rte_bus_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_conf>())).scan_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_conf),
            "::",
            stringify!(scan_mode)
        )
    );
}
impl Default for rte_bus_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Get common iommu class of the all the devices on the bus. The bus may
/// check that those devices are attached to iommu driver.
/// If no devices are attached to the bus. The bus may return with don't care
/// (_DC) value.
/// Otherwise, The bus will return appropriate _pa or _va iova mode.
///
/// @return
///      enum rte_iova_mode value.
pub type rte_bus_get_iommu_class_t =
    ::std::option::Option<unsafe extern "C" fn() -> rte_iova_mode::Type>;
/// A structure describing a generic bus.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus {
    ///< Next bus object in linked list
    pub next: rte_bus__bindgen_ty_1,
    ///< Name of the bus
    pub name: *const ::std::os::raw::c_char,
    ///< Scan for devices attached to bus
    pub scan: rte_bus_scan_t,
    ///< Probe devices on bus
    pub probe: rte_bus_probe_t,
    ///< Find a device on the bus
    pub find_device: rte_bus_find_device_t,
    ///< Probe single device for drivers
    pub plug: rte_bus_plug_t,
    ///< Remove single device from driver
    pub unplug: rte_bus_unplug_t,
    ///< Parse a device name
    pub parse: rte_bus_parse_t,
    ///< Bus configuration
    pub conf: rte_bus_conf,
    ///< Get iommu class
    pub get_iommu_class: rte_bus_get_iommu_class_t,
    ///< Device iterator.
    pub dev_iterate: rte_dev_iterate_t,
    pub hot_unplug_handler: rte_bus_hot_unplug_handler_t,
    pub sigbus_handler: rte_bus_sigbus_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_bus__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_bus() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus>(),
        112usize,
        concat!("Size of: ", stringify!(rte_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).scan as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).probe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).find_device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(find_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).plug as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).unplug as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(unplug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).parse as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).conf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).get_iommu_class as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(get_iommu_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dev_iterate as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(dev_iterate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).hot_unplug_handler as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(hot_unplug_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).sigbus_handler as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(sigbus_handler)
        )
    );
}
impl Default for rte_bus {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Register a Bus handler.
    ///
    /// @param bus
    ///   A pointer to a rte_bus structure describing the bus
    ///   to be registered.
    pub fn rte_bus_register(bus: *mut rte_bus);
}
extern "C" {
    /// Unregister a Bus handler.
    ///
    /// @param bus
    ///   A pointer to a rte_bus structure describing the bus
    ///   to be unregistered.
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
extern "C" {
    /// Scan all the buses.
    ///
    /// @return
    ///   0 in case of success in scanning all buses
    ///  !0 in case of failure to scan
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    /// For each device on the buses, perform a driver 'match' and call the
    /// driver-specific probe for device initialization.
    ///
    /// @return
    ///	 0 for successful match/probe
    ///	!0 otherwise
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump information of all the buses registered with EAL.
    ///
    /// @param f
    ///	 A valid and open output stream handle
    pub fn rte_bus_dump(f: *mut FILE);
}
/// Bus comparison function.
///
/// @param bus
///	Bus under test.
///
/// @param data
///	Data to compare against.
///
/// @return
///	0 if the bus matches the data.
///	!0 if the bus does not match.
///	<0 if ordering is possible and the bus is lower than the data.
///	>0 if ordering is possible and the bus is greater than the data.
pub type rte_bus_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(bus: *const rte_bus, data: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Bus iterator to find a particular bus.
    ///
    /// This function compares each registered bus to find one that matches
    /// the data passed as parameter.
    ///
    /// If the comparison function returns zero this function will stop iterating
    /// over any more buses. To continue a search the bus of a previous search can
    /// be passed via the start parameter.
    ///
    /// @param start
    ///	Starting point for the iteration.
    ///
    /// @param cmp
    ///	Comparison function.
    ///
    /// @param data
    ///	 Data to pass to comparison function.
    ///
    /// @return
    ///	 A pointer to a rte_bus structure or NULL in case no bus matches
    pub fn rte_bus_find(
        start: *const rte_bus,
        cmp: rte_bus_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_bus;
}
extern "C" {
    /// Find the registered bus for a particular device.
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
extern "C" {
    /// Find the registered bus for a given name.
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char) -> *mut rte_bus;
}
extern "C" {
    /// Get the common iommu class of devices bound on to buses available in the
    /// system. The default mode is PA.
    ///
    /// @return
    ///     enum rte_iova_mode value.
    pub fn rte_bus_get_iommu_class() -> rte_iova_mode::Type;
}
pub mod rte_intr_mode {
    pub type Type = u32;
    pub const RTE_INTR_MODE_NONE: Type = 0;
    pub const RTE_INTR_MODE_LEGACY: Type = 1;
    pub const RTE_INTR_MODE_MSI: Type = 2;
    pub const RTE_INTR_MODE_MSIX: Type = 3;
}
pub mod rte_lcore_role_t {
    /// The lcore role (used in RTE or not).
    pub type Type = u32;
    pub const ROLE_RTE: Type = 0;
    pub const ROLE_OFF: Type = 1;
    pub const ROLE_SERVICE: Type = 2;
}
pub mod rte_proc_type_t {
    /// The type of process in a linuxapp, multi-process setup
    pub type Type = i32;
    pub const RTE_PROC_AUTO: Type = -1;
    pub const RTE_PROC_PRIMARY: Type = 0;
    pub const RTE_PROC_SECONDARY: Type = 1;
    pub const RTE_PROC_INVALID: Type = 2;
}
/// The global RTE configuration structure.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_config {
    ///< Id of the master lcore
    pub master_lcore: u32,
    ///< Number of available logical cores.
    pub lcore_count: u32,
    ///< Number of detected NUMA nodes.
    pub numa_node_count: u32,
    ///< List of detected NUMA nodes.
    pub numa_nodes: [u32; 8usize],
    ///< Number of available service cores.
    pub service_lcore_count: u32,
    ///< State of cores.
    pub lcore_role: [rte_lcore_role_t::Type; 128usize],
    /// Primary or secondary configuration
    pub process_type: rte_proc_type_t::Type,
    /// PA or VA mapping mode
    pub iova_mode: rte_iova_mode::Type,
    /// Pointer to memory configuration, which may be shared across multiple
    /// DPDK instances
    pub mem_config: *mut rte_mem_config,
}
#[test]
fn bindgen_test_layout_rte_config() {
    assert_eq!(
        ::std::mem::size_of::<rte_config>(),
        576usize,
        concat!("Size of: ", stringify!(rte_config))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_config>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).master_lcore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(master_lcore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).lcore_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(lcore_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).numa_node_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(numa_node_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).numa_nodes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(numa_nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).service_lcore_count as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(service_lcore_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).lcore_role as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(lcore_role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).process_type as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(process_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).iova_mode as *const _ as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(iova_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).mem_config as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(mem_config)
        )
    );
}
impl Default for rte_config {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Get the global configuration structure.
    ///
    /// @return
    ///   A pointer to the global configuration structure.
    pub fn rte_eal_get_configuration() -> *mut rte_config;
}
extern "C" {
    /// Get a lcore's role.
    ///
    /// @param lcore_id
    ///   The identifier of the lcore.
    /// @return
    ///   The role of the lcore.
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t::Type;
}
extern "C" {
    /// Get the process type in a multi-process setup
    ///
    /// @return
    ///   The process type
    pub fn rte_eal_process_type() -> rte_proc_type_t::Type;
}
extern "C" {
    /// Request iopl privilege for all RPL.
    ///
    /// This function should be called by pmds which need access to ioports.
    ///
    /// @return
    ///   - On success, returns 0.
    ///   - On failure, returns -1.
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize the Environment Abstraction Layer (EAL).
    ///
    /// This function is to be executed on the MASTER lcore only, as soon
    /// as possible in the application's main() function.
    ///
    /// The function finishes the initialization process before main() is called.
    /// It puts the SLAVE lcores in the WAIT state.
    ///
    /// When the multi-partition feature is supported, depending on the
    /// configuration (if CONFIG_RTE_EAL_MAIN_PARTITION is disabled), this
    /// function waits to ensure that the magic number is set before
    /// returning. See also the rte_eal_get_configuration() function. Note:
    /// This behavior may change in the future.
    ///
    /// @param argc
    ///   A non-negative value.  If it is greater than 0, the array members
    ///   for argv[0] through argv[argc] (non-inclusive) shall contain pointers
    ///   to strings.
    /// @param argv
    ///   An array of strings.  The contents of the array, as well as the strings
    ///   which are pointed to by the array, may be modified by this function.
    /// @return
    ///   - On success, the number of parsed arguments, which is greater or
    ///     equal to zero. After the call to rte_eal_init(),
    ///     all arguments argv[x] with x < ret may have been modified by this
    ///     function call and should not be further interpreted by the
    ///     application.  The EAL does not take any ownership of the memory used
    ///     for either the argv array, or its members.
    ///   - On failure, -1 and rte_errno is set to a value indicating the cause
    ///     for failure.  In some instances, the application will need to be
    ///     restarted as part of clearing the issue.
    ///
    ///   Error codes returned via rte_errno:
    ///     EACCES indicates a permissions issue.
    ///
    ///     EAGAIN indicates either a bus or system resource was not available,
    ///            setup may be attempted again.
    ///
    ///     EALREADY indicates that the rte_eal_init function has already been
    ///              called, and cannot be called again.
    ///
    ///     EFAULT indicates the tailq configuration name was not found in
    ///            memory configuration.
    ///
    ///     EINVAL indicates invalid parameters were passed as argv/argc.
    ///
    ///     ENOMEM indicates failure likely caused by an out-of-memory condition.
    ///
    ///     ENODEV indicates memory setup issues.
    ///
    ///     ENOTSUP indicates that the EAL cannot initialize on this system.
    ///
    ///     EPROTO indicates that the PCI bus is either not present, or is not
    ///            readable by the eal.
    ///
    ///     ENOEXEC indicates that a service core failed to launch successfully.
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Clean up the Environment Abstraction Layer (EAL)
    ///
    /// This function must be called to release any internal resources that EAL has
    /// allocated during rte_eal_init(). After this call, no DPDK function calls may
    /// be made. It is expected that common usage of this function is to call it
    /// just before terminating the process.
    ///
    /// @return 0 Successfully released all internal EAL resources
    /// @return -EFAULT There was an error in releasing all resources.
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if a primary process is currently alive
    ///
    /// This function returns true when a primary process is currently
    /// active.
    ///
    /// @param config_file_path
    ///   The config_file_path argument provided should point at the location
    ///   that the primary process will create its config file. If NULL, the default
    ///   config file path is used.
    ///
    /// @return
    ///  - If alive, returns 1.
    ///  - If dead, returns 0.
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_rte_mp_msg() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_msg>(),
        360usize,
        concat!("Size of: ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).len_param as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(len_param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).num_fds as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(num_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).param as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).fds as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(fds)
        )
    );
}
impl Default for rte_mp_msg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[test]
fn bindgen_test_layout_rte_mp_reply() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_reply>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_reply>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_sent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_received as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_received)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(msgs)
        )
    );
}
impl Default for rte_mp_reply {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Action function typedef used by other components.
///
/// As we create  socket channel for primary/secondary communication, use
/// this function typedef to register action for coming messages.
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(msg: *const rte_mp_msg, peer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
/// Asynchronous reply function typedef used by other components.
///
/// As we create socket channel for primary/secondary communication, use
/// this function typedef to register action for coming responses to asynchronous
/// requests.
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(request: *const rte_mp_msg, reply: *const rte_mp_reply)
        -> ::std::os::raw::c_int,
>;
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Register an action function for primary/secondary communication.
    ///
    /// Call this function to register an action, if the calling component wants
    /// to response the messages from the corresponding component in its primary
    /// process or secondary processes.
    ///
    /// @param name
    ///   The name argument plays as the nonredundant key to find the action.
    ///
    /// @param action
    ///   The action argument is the function pointer to the action function.
    ///
    /// @return
    ///  - 0 on success.
    ///  - (<0) on failure.
    pub fn rte_mp_action_register(
        name: *const ::std::os::raw::c_char,
        action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Unregister an action function for primary/secondary communication.
    ///
    /// Call this function to unregister an action  if the calling component does
    /// not want to response the messages from the corresponding component in its
    /// primary process or secondary processes.
    ///
    /// @param name
    ///   The name argument plays as the nonredundant key to find the action.
    ///
    pub fn rte_mp_action_unregister(name: *const ::std::os::raw::c_char);
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Send a message to the peer process.
    ///
    /// This function will send a message which will be responsed by the action
    /// identified by name in the peer process.
    ///
    /// @param msg
    ///   The msg argument contains the customized message.
    ///
    /// @return
    ///  - On success, return 0.
    ///  - On failure, return -1, and the reason will be stored in rte_errno.
    pub fn rte_mp_sendmsg(msg: *mut rte_mp_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Send a request to the peer process and expect a reply.
    ///
    /// This function sends a request message to the peer process, and will
    /// block until receiving reply message from the peer process.
    ///
    /// @note The caller is responsible to free reply->replies.
    ///
    /// @param req
    ///   The req argument contains the customized request message.
    ///
    /// @param reply
    ///   The reply argument will be for storing all the replied messages;
    ///   the caller is responsible for free reply->msgs.
    ///
    /// @param ts
    ///   The ts argument specifies how long we can wait for the peer(s) to reply.
    ///
    /// @return
    ///  - On success, return 0.
    ///  - On failure, return -1, and the reason will be stored in rte_errno.
    pub fn rte_mp_request_sync(
        req: *mut rte_mp_msg,
        reply: *mut rte_mp_reply,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Send a request to the peer process and expect a reply in a separate callback.
    ///
    /// This function sends a request message to the peer process, and will not
    /// block. Instead, reply will be received in a separate callback.
    ///
    /// @param req
    ///   The req argument contains the customized request message.
    ///
    /// @param ts
    ///   The ts argument specifies how long we can wait for the peer(s) to reply.
    ///
    /// @param clb
    ///   The callback to trigger when all responses for this request have arrived.
    ///
    /// @return
    ///  - On success, return 0.
    ///  - On failure, return -1, and the reason will be stored in rte_errno.
    pub fn rte_mp_request_async(
        req: *mut rte_mp_msg,
        ts: *const timespec,
        clb: rte_mp_async_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Send a reply to the peer process.
    ///
    /// This function will send a reply message in response to a request message
    /// received previously.
    ///
    /// @param msg
    ///   The msg argument contains the customized message.
    ///
    /// @param peer
    ///   The peer argument is the pointer to the peer socket path.
    ///
    /// @return
    ///  - On success, return 0.
    ///  - On failure, return -1, and the reason will be stored in rte_errno.
    pub fn rte_mp_reply(
        msg: *mut rte_mp_msg,
        peer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register all mp action callbacks for hotplug.
    ///
    /// @return
    ///   0 on success, negative on error.
    pub fn rte_mp_dev_hotplug_init() -> ::std::os::raw::c_int;
}
/// Usage function typedef used by the application usage function.
///
/// Use this function typedef to define and call rte_set_application_usage_hook()
/// routine.
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
extern "C" {
    /// Add application usage routine callout from the eal_usage() routine.
    ///
    /// This function allows the application to include its usage message
    /// in the EAL system usage message. The routine rte_set_application_usage_hook()
    /// needs to be called before the rte_eal_init() routine in the application.
    ///
    /// This routine is optional for the application and will behave as if the set
    /// routine was never called as the default behavior.
    ///
    /// @param usage_func
    ///   The func argument is a function pointer to the application usage routine.
    ///   Called function is defined using rte_usage_hook_t typedef, which is of
    ///   the form void rte_usage_func(const char * prgname).
    ///
    ///   Calling this routine with a NULL value will reset the usage hook routine and
    ///   return the current value, which could be NULL.
    /// @return
    ///   - Returns the current value of the rte_application_usage pointer to allow
    ///     the caller to daisy chain the usage routines if needing more then one.
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
extern "C" {
    /// Whether EAL is using huge pages (disabled by --no-huge option).
    /// The no-huge mode cannot be used with UIO poll-mode drivers like igb/ixgbe.
    /// It is useful for NIC drivers (e.g. librte_pmd_mlx4, librte_pmd_vmxnet3) or
    /// crypto drivers (e.g. librte_crypto_nitrox) provided by third-parties such
    /// as 6WIND.
    ///
    /// @return
    ///   Nonzero if hugepages are enabled.
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Whether EAL is using PCI bus.
    /// Disabled by --no-pci option.
    ///
    /// @return
    ///   Nonzero if the PCI bus is enabled.
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Whether the EAL was asked to create UIO device.
    ///
    /// @return
    ///   Nonzero if true.
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
extern "C" {
    /// The user-configured vfio interrupt mode.
    ///
    /// @return
    ///   Interrupt mode configured with the command line,
    ///   RTE_INTR_MODE_NONE by default.
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode::Type;
}
extern "C" {
    /// A wrap API for syscall gettid.
    ///
    /// @return
    ///   On success, returns the thread ID of calling process.
    ///   It is always successful.
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the iova mode
    ///
    /// @return
    ///   enum rte_iova_mode value.
    pub fn rte_eal_iova_mode() -> rte_iova_mode::Type;
}
extern "C" {
    /// Get user provided pool ops name for mbuf
    ///
    /// @return
    ///   returns user provided pool ops name.
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the runtime directory of DPDK
    ///
    /// @return
    ///  The runtime directory path of DPDK
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
pub type rte_cpuset_t = cpu_set_t;
/// Structure storing internal configuration (per-lcore)
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct lcore_config {
    ///< true if lcore was detected
    pub detected: ::std::os::raw::c_uint,
    ///< pthread identifier
    pub thread_id: pthread_t,
    ///< communication pipe with master
    pub pipe_master2slave: [::std::os::raw::c_int; 2usize],
    ///< communication pipe with master
    pub pipe_slave2master: [::std::os::raw::c_int; 2usize],
    ///< function to call
    pub f: lcore_function_t,
    ///< argument of function
    pub arg: *mut ::std::os::raw::c_void,
    ///< return value of function
    pub ret: ::std::os::raw::c_int,
    ///< lcore state
    pub state: rte_lcore_state_t::Type,
    ///< physical socket id for this lcore
    pub socket_id: ::std::os::raw::c_uint,
    ///< core number on socket for this lcore
    pub core_id: ::std::os::raw::c_uint,
    ///< relative index, starting from 0
    pub core_index: ::std::os::raw::c_int,
    ///< cpu set which the lcore affinity to
    pub cpuset: rte_cpuset_t,
    ///< role of core eg: OFF, RTE, SERVICE
    pub core_role: u8,
}
#[test]
fn bindgen_test_layout_lcore_config() {
    assert_eq!(
        ::std::mem::size_of::<lcore_config>(),
        208usize,
        concat!("Size of: ", stringify!(lcore_config))
    );
    assert_eq!(
        ::std::mem::align_of::<lcore_config>(),
        8usize,
        concat!("Alignment of ", stringify!(lcore_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).detected as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(detected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).thread_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).pipe_master2slave as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(pipe_master2slave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).pipe_slave2master as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(pipe_slave2master)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).f as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).arg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).ret as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(ret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).state as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).socket_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).core_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).core_index as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(core_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).cpuset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(cpuset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).core_role as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(core_role)
        )
    );
}
impl Default for lcore_config {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}lcore_config"]
    pub static mut lcore_config: [lcore_config; 128usize];
}
extern "C" {
    #[link_name = "\u{1}per_lcore__lcore_id"]
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}per_lcore__cpuset"]
    pub static mut per_lcore__cpuset: cpu_set_t;
}
extern "C" {
    /// Return the ID of the physical socket of the logical core we are
    /// running on.
    /// @return
    ///   the ID of current lcoreid's physical socket
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Return number of physical sockets detected on the system.
    ///
    /// Note that number of nodes may not be correspondent to their physical id's:
    /// for example, a system may report two socket id's, but the actual socket id's
    /// may be 0 and 8.
    ///
    /// @return
    ///   the number of physical sockets as recognized by EAL
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Return socket id with a particular index.
    ///
    /// This will return socket id at a particular position in list of all detected
    /// physical socket id's. For example, on a machine with sockets [0, 8], passing
    /// 1 as a parameter will return 8.
    ///
    /// @param idx
    ///   index of physical socket id to return
    ///
    /// @return
    ///   - physical socket id as recognized by EAL
    ///   - -1 on error, with errno set to EINVAL
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set core affinity of the current thread.
    /// Support both EAL and non-EAL thread and update TLS.
    ///
    /// @param cpusetp
    ///   Point to cpu_set_t for setting current thread affinity.
    /// @return
    ///   On success, return 0; otherwise return -1;
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get core affinity of the current thread.
    ///
    /// @param cpusetp
    ///   Point to cpu_set_t for getting current thread cpu affinity.
    ///   It presumes input is not NULL, otherwise it causes panic.
    ///
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
extern "C" {
    /// Set thread names.
    ///
    /// @note It fails with glibc < 2.12.
    ///
    /// @param id
    ///   Thread id.
    /// @param name
    ///   Thread name to set.
    /// @return
    ///   On success, return 0; otherwise return a negative value.
    pub fn rte_thread_setname(
        id: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a control thread.
    ///
    /// Wrapper to pthread_create(), pthread_setname_np() and
    /// pthread_setaffinity_np(). The dataplane and service lcores are
    /// excluded from the affinity of the new thread.
    ///
    /// @param thread
    ///   Filled with the thread id of the new created thread.
    /// @param name
    ///   The name of the control thread (max 16 characters including '\0').
    /// @param attr
    ///   Attributes for the new thread.
    /// @param start_routine
    ///   Function to be executed by the new thread.
    /// @param arg
    ///   Argument passed to start_routine.
    /// @return
    ///   On success, returns 0; on error, it returns a negative value
    ///   corresponding to the error number.
    pub fn rte_ctrl_thread_create(
        thread: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        attr: *const pthread_attr_t,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Test if the core supplied has a specific role
    ///
    /// @param lcore_id
    ///   The identifier of the lcore, which MUST be between 0 and
    ///   RTE_MAX_LCORE-1.
    /// @param role
    ///   The role to be checked against.
    /// @return
    ///   Boolean value: positive if test is true; otherwise returns 0.
    pub fn rte_lcore_has_role(
        lcore_id: ::std::os::raw::c_uint,
        role: rte_lcore_role_t::Type,
    ) -> ::std::os::raw::c_int;
}
/// The rte_spinlock_t type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_spinlock_t {
    ///< lock status 0 = unlocked, 1 = locked
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_t>())).locked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_t),
            "::",
            stringify!(locked)
        )
    );
}
/// The rte_spinlock_recursive_t type.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_spinlock_recursive_t {
    ///< the actual spinlock
    pub sl: rte_spinlock_t,
    ///< core id using lock, -1 for unused
    pub user: ::std::os::raw::c_int,
    ///< count of time this lock has been called
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_recursive_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_recursive_t>(),
        12usize,
        concat!("Size of: ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_recursive_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).user as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(count)
        )
    );
}
pub mod rte_cpu_flag_t {
    /// Enumeration of all CPU features supported
    pub type Type = u32;
    ///< SSE3
    pub const RTE_CPUFLAG_SSE3: Type = 0;
    ///< PCLMULQDQ
    pub const RTE_CPUFLAG_PCLMULQDQ: Type = 1;
    ///< DTES64
    pub const RTE_CPUFLAG_DTES64: Type = 2;
    ///< MONITOR
    pub const RTE_CPUFLAG_MONITOR: Type = 3;
    ///< DS_CPL
    pub const RTE_CPUFLAG_DS_CPL: Type = 4;
    ///< VMX
    pub const RTE_CPUFLAG_VMX: Type = 5;
    ///< SMX
    pub const RTE_CPUFLAG_SMX: Type = 6;
    ///< EIST
    pub const RTE_CPUFLAG_EIST: Type = 7;
    ///< TM2
    pub const RTE_CPUFLAG_TM2: Type = 8;
    ///< SSSE3
    pub const RTE_CPUFLAG_SSSE3: Type = 9;
    ///< CNXT_ID
    pub const RTE_CPUFLAG_CNXT_ID: Type = 10;
    ///< FMA
    pub const RTE_CPUFLAG_FMA: Type = 11;
    ///< CMPXCHG16B
    pub const RTE_CPUFLAG_CMPXCHG16B: Type = 12;
    ///< XTPR
    pub const RTE_CPUFLAG_XTPR: Type = 13;
    ///< PDCM
    pub const RTE_CPUFLAG_PDCM: Type = 14;
    ///< PCID
    pub const RTE_CPUFLAG_PCID: Type = 15;
    ///< DCA
    pub const RTE_CPUFLAG_DCA: Type = 16;
    ///< SSE4_1
    pub const RTE_CPUFLAG_SSE4_1: Type = 17;
    ///< SSE4_2
    pub const RTE_CPUFLAG_SSE4_2: Type = 18;
    ///< X2APIC
    pub const RTE_CPUFLAG_X2APIC: Type = 19;
    ///< MOVBE
    pub const RTE_CPUFLAG_MOVBE: Type = 20;
    ///< POPCNT
    pub const RTE_CPUFLAG_POPCNT: Type = 21;
    ///< TSC_DEADLINE
    pub const RTE_CPUFLAG_TSC_DEADLINE: Type = 22;
    ///< AES
    pub const RTE_CPUFLAG_AES: Type = 23;
    ///< XSAVE
    pub const RTE_CPUFLAG_XSAVE: Type = 24;
    ///< OSXSAVE
    pub const RTE_CPUFLAG_OSXSAVE: Type = 25;
    ///< AVX
    pub const RTE_CPUFLAG_AVX: Type = 26;
    ///< F16C
    pub const RTE_CPUFLAG_F16C: Type = 27;
    ///< RDRAND
    pub const RTE_CPUFLAG_RDRAND: Type = 28;
    ///< Running in a VM
    pub const RTE_CPUFLAG_HYPERVISOR: Type = 29;
    ///< FPU
    pub const RTE_CPUFLAG_FPU: Type = 30;
    ///< VME
    pub const RTE_CPUFLAG_VME: Type = 31;
    ///< DE
    pub const RTE_CPUFLAG_DE: Type = 32;
    ///< PSE
    pub const RTE_CPUFLAG_PSE: Type = 33;
    ///< TSC
    pub const RTE_CPUFLAG_TSC: Type = 34;
    ///< MSR
    pub const RTE_CPUFLAG_MSR: Type = 35;
    ///< PAE
    pub const RTE_CPUFLAG_PAE: Type = 36;
    ///< MCE
    pub const RTE_CPUFLAG_MCE: Type = 37;
    ///< CX8
    pub const RTE_CPUFLAG_CX8: Type = 38;
    ///< APIC
    pub const RTE_CPUFLAG_APIC: Type = 39;
    ///< SEP
    pub const RTE_CPUFLAG_SEP: Type = 40;
    ///< MTRR
    pub const RTE_CPUFLAG_MTRR: Type = 41;
    ///< PGE
    pub const RTE_CPUFLAG_PGE: Type = 42;
    ///< MCA
    pub const RTE_CPUFLAG_MCA: Type = 43;
    ///< CMOV
    pub const RTE_CPUFLAG_CMOV: Type = 44;
    ///< PAT
    pub const RTE_CPUFLAG_PAT: Type = 45;
    ///< PSE36
    pub const RTE_CPUFLAG_PSE36: Type = 46;
    ///< PSN
    pub const RTE_CPUFLAG_PSN: Type = 47;
    ///< CLFSH
    pub const RTE_CPUFLAG_CLFSH: Type = 48;
    ///< DS
    pub const RTE_CPUFLAG_DS: Type = 49;
    ///< ACPI
    pub const RTE_CPUFLAG_ACPI: Type = 50;
    ///< MMX
    pub const RTE_CPUFLAG_MMX: Type = 51;
    ///< FXSR
    pub const RTE_CPUFLAG_FXSR: Type = 52;
    ///< SSE
    pub const RTE_CPUFLAG_SSE: Type = 53;
    ///< SSE2
    pub const RTE_CPUFLAG_SSE2: Type = 54;
    ///< SS
    pub const RTE_CPUFLAG_SS: Type = 55;
    ///< HTT
    pub const RTE_CPUFLAG_HTT: Type = 56;
    ///< TM
    pub const RTE_CPUFLAG_TM: Type = 57;
    ///< PBE
    pub const RTE_CPUFLAG_PBE: Type = 58;
    ///< DIGTEMP
    pub const RTE_CPUFLAG_DIGTEMP: Type = 59;
    ///< TRBOBST
    pub const RTE_CPUFLAG_TRBOBST: Type = 60;
    ///< ARAT
    pub const RTE_CPUFLAG_ARAT: Type = 61;
    ///< PLN
    pub const RTE_CPUFLAG_PLN: Type = 62;
    ///< ECMD
    pub const RTE_CPUFLAG_ECMD: Type = 63;
    ///< PTM
    pub const RTE_CPUFLAG_PTM: Type = 64;
    ///< MPERF_APERF_MSR
    pub const RTE_CPUFLAG_MPERF_APERF_MSR: Type = 65;
    ///< ACNT2
    pub const RTE_CPUFLAG_ACNT2: Type = 66;
    ///< ENERGY_EFF
    pub const RTE_CPUFLAG_ENERGY_EFF: Type = 67;
    ///< FSGSBASE
    pub const RTE_CPUFLAG_FSGSBASE: Type = 68;
    ///< BMI1
    pub const RTE_CPUFLAG_BMI1: Type = 69;
    ///< Hardware Lock elision
    pub const RTE_CPUFLAG_HLE: Type = 70;
    ///< AVX2
    pub const RTE_CPUFLAG_AVX2: Type = 71;
    ///< SMEP
    pub const RTE_CPUFLAG_SMEP: Type = 72;
    ///< BMI2
    pub const RTE_CPUFLAG_BMI2: Type = 73;
    ///< ERMS
    pub const RTE_CPUFLAG_ERMS: Type = 74;
    ///< INVPCID
    pub const RTE_CPUFLAG_INVPCID: Type = 75;
    ///< Transactional memory
    pub const RTE_CPUFLAG_RTM: Type = 76;
    ///< AVX512F
    pub const RTE_CPUFLAG_AVX512F: Type = 77;
    ///< LAHF_SAHF
    pub const RTE_CPUFLAG_LAHF_SAHF: Type = 78;
    ///< LZCNT
    pub const RTE_CPUFLAG_LZCNT: Type = 79;
    ///< SYSCALL
    pub const RTE_CPUFLAG_SYSCALL: Type = 80;
    ///< XD
    pub const RTE_CPUFLAG_XD: Type = 81;
    ///< 1GB_PG
    pub const RTE_CPUFLAG_1GB_PG: Type = 82;
    ///< RDTSCP
    pub const RTE_CPUFLAG_RDTSCP: Type = 83;
    ///< EM64T
    pub const RTE_CPUFLAG_EM64T: Type = 84;
    ///< INVTSC
    pub const RTE_CPUFLAG_INVTSC: Type = 85;
    ///< This should always be the last!
    pub const RTE_CPUFLAG_NUMFLAGS: Type = 86;
}
extern "C" {
    /// Get name of CPU flag
    ///
    /// @param feature
    ///     CPU flag ID
    /// @return
    ///     flag name
    ///     NULL if flag ID is invalid
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Function for checking a CPU flag availability
    ///
    /// @param feature
    ///     CPU flag to query CPU for
    /// @return
    ///     1 if flag is available
    ///     0 if flag is not available
    ///     -ENOENT if flag is invalid
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function checks that the currently used CPU supports the CPU features
    /// that were specified at compile time. It is called automatically within the
    /// EAL, so does not need to be used by applications.
    pub fn rte_cpu_check_supported();
}
extern "C" {
    /// This function checks that the currently used CPU supports the CPU features
    /// that were specified at compile time. It is called automatically within the
    /// EAL, so does not need to be used by applications.  This version returns a
    /// result so that decisions may be made (for instance, graceful shutdowns).
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function attempts to retrieve a value from the auxiliary vector.
    /// If it is unsuccessful, the result will be 0, and errno will be set.
    ///
    /// @return A value from the auxiliary vector.  When the value is 0, check
    /// errno to determine if an error occurred.
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    /// This function retrieves a value from the auxiliary vector, and compares it
    /// as a string against the value retrieved.
    ///
    /// @return The result of calling strcmp() against the value retrieved from
    /// the auxiliary vector.  When the value is 0 (meaning a match is found),
    /// check errno to determine if an error occurred.
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}rte_rtm_supported"]
    pub static mut rte_rtm_supported: u8;
}
/// A structure describing a memzone, which is a contiguous portion of
/// physical memory identified by a name.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    ///< Name of the memory zone.
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memzone__bindgen_ty_2,
    ///< Length of the memzone.
    pub len: usize,
    ///< The page size of underlying memory
    pub hugepage_sz: u64,
    ///< NUMA socket ID.
    pub socket_id: i32,
    ///< Characteristics of this memzone.
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    ///< deprecated - Start physical address.
    pub phys_addr: phys_addr_t,
    ///< Start IO address.
    pub iova: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).phys_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(iova)
        )
    );
}
impl Default for rte_memzone__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_2 {
    ///< Start virtual address.
    pub addr: *mut ::std::os::raw::c_void,
    ///< Makes sure addr is always 64-bits
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_2>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_2),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memzone__bindgen_ty_2>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_2),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memzone__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone>(),
        72usize,
        concat!("Size of: ", stringify!(rte_memzone))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memzone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).hugepage_sz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).socket_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).flags as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for rte_memzone {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Reserve a portion of physical memory.
    ///
    /// This function reserves some memory and returns a pointer to a
    /// correctly filled memzone descriptor. If the allocation cannot be
    /// done, return NULL.
    ///
    /// @note Reserving memzones with len set to 0 will only attempt to allocate
    ///   memzones from memory that is already available. It will not trigger any
    ///   new allocations.
    ///
    /// @note: When reserving memzones with len set to 0, it is preferable to also
    ///   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but
    ///   will likely not yield expected results. Specifically, the resulting memzone
    ///   may not necessarily be the biggest memzone available, but rather biggest
    ///   memzone available on socket id corresponding to an lcore from which
    ///   reservation was called.
    ///
    /// @param name
    ///   The name of the memzone. If it already exists, the function will
    ///   fail and return NULL.
    /// @param len
    ///   The size of the memory to be reserved. If it
    ///   is 0, the biggest contiguous zone will be reserved.
    /// @param socket_id
    ///   The socket identifier in the case of
    ///   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
    ///   constraint for the reserved zone.
    /// @param flags
    ///   The flags parameter is used to request memzones to be
    ///   taken from specifically sized hugepages.
    ///   - RTE_MEMZONE_2MB - Reserved from 2MB pages
    ///   - RTE_MEMZONE_1GB - Reserved from 1GB pages
    ///   - RTE_MEMZONE_16MB - Reserved from 16MB pages
    ///   - RTE_MEMZONE_16GB - Reserved from 16GB pages
    ///   - RTE_MEMZONE_256KB - Reserved from 256KB pages
    ///   - RTE_MEMZONE_256MB - Reserved from 256MB pages
    ///   - RTE_MEMZONE_512MB - Reserved from 512MB pages
    ///   - RTE_MEMZONE_4GB - Reserved from 4GB pages
    ///   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
    ///                                  the requested page size is unavailable.
    ///                                  If this flag is not set, the function
    ///                                  will return error on an unavailable size
    ///                                  request.
    ///   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous.
    ///                               This option should be used when allocating
    ///                               memory intended for hardware rings etc.
    /// @return
    ///   A pointer to a correctly-filled read-only memzone descriptor, or NULL
    ///   on error.
    ///   On error case, rte_errno will be set appropriately:
    ///    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
    ///    - E_RTE_SECONDARY - function was called from a secondary process instance
    ///    - ENOSPC - the maximum number of memzones has already been allocated
    ///    - EEXIST - a memzone with the same name already exists
    ///    - ENOMEM - no appropriate memory area found in which to create memzone
    ///    - EINVAL - invalid parameters
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    /// Reserve a portion of physical memory with alignment on a specified
    /// boundary.
    ///
    /// This function reserves some memory with alignment on a specified
    /// boundary, and returns a pointer to a correctly filled memzone
    /// descriptor. If the allocation cannot be done or if the alignment
    /// is not a power of 2, returns NULL.
    ///
    /// @note Reserving memzones with len set to 0 will only attempt to allocate
    ///   memzones from memory that is already available. It will not trigger any
    ///   new allocations.
    ///
    /// @note: When reserving memzones with len set to 0, it is preferable to also
    ///   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but
    ///   will likely not yield expected results. Specifically, the resulting memzone
    ///   may not necessarily be the biggest memzone available, but rather biggest
    ///   memzone available on socket id corresponding to an lcore from which
    ///   reservation was called.
    ///
    /// @param name
    ///   The name of the memzone. If it already exists, the function will
    ///   fail and return NULL.
    /// @param len
    ///   The size of the memory to be reserved. If it
    ///   is 0, the biggest contiguous zone will be reserved.
    /// @param socket_id
    ///   The socket identifier in the case of
    ///   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
    ///   constraint for the reserved zone.
    /// @param flags
    ///   The flags parameter is used to request memzones to be
    ///   taken from specifically sized hugepages.
    ///   - RTE_MEMZONE_2MB - Reserved from 2MB pages
    ///   - RTE_MEMZONE_1GB - Reserved from 1GB pages
    ///   - RTE_MEMZONE_16MB - Reserved from 16MB pages
    ///   - RTE_MEMZONE_16GB - Reserved from 16GB pages
    ///   - RTE_MEMZONE_256KB - Reserved from 256KB pages
    ///   - RTE_MEMZONE_256MB - Reserved from 256MB pages
    ///   - RTE_MEMZONE_512MB - Reserved from 512MB pages
    ///   - RTE_MEMZONE_4GB - Reserved from 4GB pages
    ///   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
    ///                                  the requested page size is unavailable.
    ///                                  If this flag is not set, the function
    ///                                  will return error on an unavailable size
    ///                                  request.
    ///   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous.
    ///                               This option should be used when allocating
    ///                               memory intended for hardware rings etc.
    /// @param align
    ///   Alignment for resulting memzone. Must be a power of 2.
    /// @return
    ///   A pointer to a correctly-filled read-only memzone descriptor, or NULL
    ///   on error.
    ///   On error case, rte_errno will be set appropriately:
    ///    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
    ///    - E_RTE_SECONDARY - function was called from a secondary process instance
    ///    - ENOSPC - the maximum number of memzones has already been allocated
    ///    - EEXIST - a memzone with the same name already exists
    ///    - ENOMEM - no appropriate memory area found in which to create memzone
    ///    - EINVAL - invalid parameters
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    /// Reserve a portion of physical memory with specified alignment and
    /// boundary.
    ///
    /// This function reserves some memory with specified alignment and
    /// boundary, and returns a pointer to a correctly filled memzone
    /// descriptor. If the allocation cannot be done or if the alignment
    /// or boundary are not a power of 2, returns NULL.
    /// Memory buffer is reserved in a way, that it wouldn't cross specified
    /// boundary. That implies that requested length should be less or equal
    /// then boundary.
    ///
    /// @note Reserving memzones with len set to 0 will only attempt to allocate
    ///   memzones from memory that is already available. It will not trigger any
    ///   new allocations.
    ///
    /// @note: When reserving memzones with len set to 0, it is preferable to also
    ///   set a valid socket_id. Setting socket_id to SOCKET_ID_ANY is supported, but
    ///   will likely not yield expected results. Specifically, the resulting memzone
    ///   may not necessarily be the biggest memzone available, but rather biggest
    ///   memzone available on socket id corresponding to an lcore from which
    ///   reservation was called.
    ///
    /// @param name
    ///   The name of the memzone. If it already exists, the function will
    ///   fail and return NULL.
    /// @param len
    ///   The size of the memory to be reserved. If it
    ///   is 0, the biggest contiguous zone will be reserved.
    /// @param socket_id
    ///   The socket identifier in the case of
    ///   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA
    ///   constraint for the reserved zone.
    /// @param flags
    ///   The flags parameter is used to request memzones to be
    ///   taken from specifically sized hugepages.
    ///   - RTE_MEMZONE_2MB - Reserved from 2MB pages
    ///   - RTE_MEMZONE_1GB - Reserved from 1GB pages
    ///   - RTE_MEMZONE_16MB - Reserved from 16MB pages
    ///   - RTE_MEMZONE_16GB - Reserved from 16GB pages
    ///   - RTE_MEMZONE_256KB - Reserved from 256KB pages
    ///   - RTE_MEMZONE_256MB - Reserved from 256MB pages
    ///   - RTE_MEMZONE_512MB - Reserved from 512MB pages
    ///   - RTE_MEMZONE_4GB - Reserved from 4GB pages
    ///   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if
    ///                                  the requested page size is unavailable.
    ///                                  If this flag is not set, the function
    ///                                  will return error on an unavailable size
    ///                                  request.
    ///   - RTE_MEMZONE_IOVA_CONTIG - Ensure reserved memzone is IOVA-contiguous.
    ///                               This option should be used when allocating
    ///                               memory intended for hardware rings etc.
    /// @param align
    ///   Alignment for resulting memzone. Must be a power of 2.
    /// @param bound
    ///   Boundary for resulting memzone. Must be a power of 2 or zero.
    ///   Zero value implies no boundary condition.
    /// @return
    ///   A pointer to a correctly-filled read-only memzone descriptor, or NULL
    ///   on error.
    ///   On error case, rte_errno will be set appropriately:
    ///    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
    ///    - E_RTE_SECONDARY - function was called from a secondary process instance
    ///    - ENOSPC - the maximum number of memzones has already been allocated
    ///    - EEXIST - a memzone with the same name already exists
    ///    - ENOMEM - no appropriate memory area found in which to create memzone
    ///    - EINVAL - invalid parameters
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    /// Free a memzone.
    ///
    /// @param mz
    ///   A pointer to the memzone
    /// @return
    ///  -EINVAL - invalid parameter.
    ///  0 - success
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Lookup for a memzone.
    ///
    /// Get a pointer to a descriptor of an already reserved memory
    /// zone identified by the name given as an argument.
    ///
    /// @param name
    ///   The name of the memzone.
    /// @return
    ///   A pointer to a read-only memzone descriptor.
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
extern "C" {
    /// Dump all reserved memzones to a file.
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    /// Walk list of all memzones
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    pub fn rte_memzone_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub mod rte_ring_queue_behavior {
    pub type Type = u32;
    pub const RTE_RING_QUEUE_FIXED: Type = 0;
    pub const RTE_RING_QUEUE_VARIABLE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_ring_headtail {
    ///< Prod/consumer head.
    pub head: u32,
    ///< Prod/consumer tail.
    pub tail: u32,
    ///< True if single prod/cons
    pub single: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_headtail() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).single as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(single)
        )
    );
}
/// An RTE ring structure.
///
/// The producer and the consumer have a head and a tail index. The particularity
/// of these index is that they are not between 0 and size(ring). These indexes
/// are between 0 and 2^32, and we mask their value when we access the ring[]
/// field. Thanks to this assumption, we can do subtractions between 2 index
/// values in a modulo-32bit base: that's why the overflow of the indexes is not
/// a problem.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring {
    ///< Name of the ring.
    pub name: [::std::os::raw::c_char; 32usize],
    ///< Flags supplied at creation.
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    ///< Size of ring.
    pub size: u32,
    ///< Mask (size-1) of ring.
    pub mask: u32,
    ///< Usable size of ring
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    ///< empty cache line
    pub pad0: ::std::os::raw::c_char,
    pub __bindgen_padding_1: [u32; 15usize],
    /// Ring producer status.
    pub prod: rte_ring_headtail,
    pub __bindgen_padding_2: [u8; 52usize],
    ///< empty cache line
    pub pad1: ::std::os::raw::c_char,
    pub __bindgen_padding_3: [u32; 15usize],
    /// Ring consumer status.
    pub cons: rte_ring_headtail,
    pub __bindgen_padding_4: [u8; 52usize],
    ///< empty cache line
    pub pad2: ::std::os::raw::c_char,
    pub __bindgen_padding_5: [u8; 63usize],
}
#[test]
fn bindgen_test_layout_rte_ring() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring>(),
        384usize,
        concat!("Size of: ", stringify!(rte_ring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).memzone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(memzone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).capacity as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad0 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).prod as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(prod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).cons as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(cons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad2 as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad2)
        )
    );
}
impl Default for rte_ring {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Calculate the memory size needed for a ring
    ///
    /// This function returns the number of bytes needed for a ring, given
    /// the number of elements in it. This value is the sum of the size of
    /// the structure rte_ring and the size of the memory needed by the
    /// objects pointers. The value is aligned to a cache line size.
    ///
    /// @param count
    ///   The number of elements in the ring (must be a power of 2).
    /// @return
    ///   - The memory size needed for the ring on success.
    ///   - -EINVAL if count is not a power of 2.
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
extern "C" {
    /// Initialize a ring structure.
    ///
    /// Initialize a ring structure in memory pointed by "r". The size of the
    /// memory area must be large enough to store the ring structure and the
    /// object table. It is advised to use rte_ring_get_memsize() to get the
    /// appropriate size.
    ///
    /// The ring size is set to *count*, which must be a power of two. Water
    /// marking is disabled by default. The real usable ring size is
    /// *count-1* instead of *count* to differentiate a free ring from an
    /// empty ring.
    ///
    /// The ring is not added in RTE_TAILQ_RING global list. Indeed, the
    /// memory given by the caller may not be shareable among dpdk
    /// processes.
    ///
    /// @param r
    ///   The pointer to the ring structure followed by the objects table.
    /// @param name
    ///   The name of the ring.
    /// @param count
    ///   The number of elements in the ring (must be a power of 2).
    /// @param flags
    ///   An OR of the following:
    ///    - RING_F_SP_ENQ: If this flag is set, the default behavior when
    ///      using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
    ///      is "single-producer". Otherwise, it is "multi-producers".
    ///    - RING_F_SC_DEQ: If this flag is set, the default behavior when
    ///      using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
    ///      is "single-consumer". Otherwise, it is "multi-consumers".
    /// @return
    ///   0 on success, or a negative value on error.
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create a new ring named *name* in memory.
    ///
    /// This function uses ``memzone_reserve()`` to allocate memory. Then it
    /// calls rte_ring_init() to initialize an empty ring.
    ///
    /// The new ring size is set to *count*, which must be a power of
    /// two. Water marking is disabled by default. The real usable ring size
    /// is *count-1* instead of *count* to differentiate a free ring from an
    /// empty ring.
    ///
    /// The ring is added in RTE_TAILQ_RING list.
    ///
    /// @param name
    ///   The name of the ring.
    /// @param count
    ///   The size of the ring (must be a power of 2).
    /// @param socket_id
    ///   The *socket_id* argument is the socket identifier in case of
    ///   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
    ///   constraint for the reserved zone.
    /// @param flags
    ///   An OR of the following:
    ///    - RING_F_SP_ENQ: If this flag is set, the default behavior when
    ///      using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``
    ///      is "single-producer". Otherwise, it is "multi-producers".
    ///    - RING_F_SC_DEQ: If this flag is set, the default behavior when
    ///      using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``
    ///      is "single-consumer". Otherwise, it is "multi-consumers".
    /// @return
    ///   On success, the pointer to the new allocated ring. NULL on error with
    ///    rte_errno set appropriately. Possible errno values include:
    ///    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
    ///    - E_RTE_SECONDARY - function was called from a secondary process instance
    ///    - EINVAL - count provided is not a power of 2
    ///    - ENOSPC - the maximum number of memzones has already been allocated
    ///    - EEXIST - a memzone with the same name already exists
    ///    - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    /// De-allocate all memory used by the ring.
    ///
    /// @param r
    ///   Ring to free
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    /// Dump the status of the ring to a file.
    ///
    /// @param f
    ///   A pointer to a file for output
    /// @param r
    ///   A pointer to the ring structure.
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    /// Dump the status of all rings on the console
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    /// Search a ring from its name
    ///
    /// @param name
    ///   The name of the ring.
    /// @return
    ///   The pointer to the ring matching the name, or NULL if not found,
    ///   with rte_errno set appropriately. Possible rte_errno values include:
    ///    - ENOENT - required entry not available to return.
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
/// A structure that stores a per-core object cache.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    ///< Size of the cache
    pub size: u32,
    ///< Threshold before we flush excess elements
    pub flushthresh: u32,
    ///< Current cache count
    pub len: u32,
    ///< Cache objects
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
    pub __bindgen_padding_0: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_cache>(),
        12352usize,
        concat!("Size of: ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).flushthresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(flushthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).objs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(objs)
        )
    );
}
impl Default for rte_mempool_cache {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure that stores the size of mempool elements.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mempool_objsz {
    ///< Size of an element.
    pub elt_size: u32,
    ///< Size of header (before elt).
    pub header_size: u32,
    ///< Size of trailer (after elt).
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objsz>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objsz>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).elt_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).trailer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).total_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(total_size)
        )
    );
}
/// Mempool object header structure
///
/// Each object stored in mempools are prefixed by this header structure,
/// it allows to retrieve the mempool pointer from the object and to
/// iterate on all objects attached to a mempool. When debug is enabled,
/// a cookie is also added in this structure preventing corruptions and
/// double-frees.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    ///< Next in list.
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    ///< The mempool owning the object.
    pub mp: *mut rte_mempool,
    pub __bindgen_anon_1: rte_mempool_objhdr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
impl Default for rte_mempool_objhdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_objhdr__bindgen_ty_2 {
    ///< IO address of the object.
    pub iova: rte_iova_t,
    ///< deprecated - Physical address of the object.
    pub physaddr: phys_addr_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_2>())).iova as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_2>())).physaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2),
            "::",
            stringify!(physaddr)
        )
    );
}
impl Default for rte_mempool_objhdr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(mp)
        )
    );
}
impl Default for rte_mempool_objhdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A list of object headers type
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
impl Default for rte_mempool_objhdr_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A list of memory where objects are stored
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
impl Default for rte_mempool_memhdr_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Callback used to free a memory chunk
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
/// Mempool objects memory header structure
///
/// The memory chunks where objects are stored. Each chunk is virtually
/// and physically contiguous.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    ///< Next in list.
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    ///< The mempool owning the chunk
    pub mp: *mut rte_mempool,
    ///< Virtual address of the chunk
    pub addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_mempool_memhdr__bindgen_ty_2,
    ///< length of the chunk
    pub len: usize,
    ///< Free callback
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    ///< Argument passed to the free callback
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
impl Default for rte_mempool_memhdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_memhdr__bindgen_ty_2 {
    ///< IO address of the chunk
    pub iova: rte_iova_t,
    ///< Physical address of the chunk
    pub phys_addr: phys_addr_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_2>())).iova as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_2>())).phys_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2),
            "::",
            stringify!(phys_addr)
        )
    );
}
impl Default for rte_mempool_memhdr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr>(),
        56usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).free_cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(opaque)
        )
    );
}
impl Default for rte_mempool_memhdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// @warning
/// @b EXPERIMENTAL: this API may change without prior notice.
///
/// Additional information about the mempool
///
/// The structure is cache-line aligned to avoid ABI breakages in
/// a number of cases when something small is added.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_info {
    /// Number of objects in the contiguous block
    pub contig_block_size: ::std::os::raw::c_uint,
    pub __bindgen_padding_0: [u32; 15usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_info>())).contig_block_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_info),
            "::",
            stringify!(contig_block_size)
        )
    );
}
impl Default for rte_mempool_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// The RTE mempool structure.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    ///< Name of mempool.
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    ///< optional args for ops alloc.
    pub pool_config: *mut ::std::os::raw::c_void,
    ///< Memzone where pool is alloc'd.
    pub mz: *const rte_memzone,
    ///< Flags of the mempool.
    pub flags: ::std::os::raw::c_uint,
    ///< Socket id passed at create.
    pub socket_id: ::std::os::raw::c_int,
    ///< Max size of the mempool.
    pub size: u32,
    pub cache_size: u32,
    ///< Size of an element.
    pub elt_size: u32,
    ///< Size of header (before elt).
    pub header_size: u32,
    ///< Size of trailer (after elt).
    pub trailer_size: u32,
    ///< Size of private data.
    pub private_data_size: ::std::os::raw::c_uint,
    /// Index into rte_mempool_ops_table array of mempool ops
    /// structs, which contain callback function pointers.
    /// We're using an index here rather than pointers to the callbacks
    /// to facilitate any secondary processes that may want to use
    /// this mempool.
    pub ops_index: i32,
    ///< Per-lcore local cache
    pub local_cache: *mut rte_mempool_cache,
    ///< Number of populated objects.
    pub populated_size: u32,
    ///< List of objects in pool
    pub elt_list: rte_mempool_objhdr_list,
    ///< Number of memory chunks
    pub nb_mem_chunks: u32,
    ///< List of memory chunks
    pub mem_list: rte_mempool_memhdr_list,
    pub __bindgen_padding_0: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    ///< Ring or pool to store objects.
    pub pool_data: *mut ::std::os::raw::c_void,
    ///< External mempool identifier.
    pub pool_id: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_id)
        )
    );
}
impl Default for rte_mempool__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool>(),
        192usize,
        concat!("Size of: ", stringify!(rte_mempool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).pool_config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(pool_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).socket_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).cache_size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).header_size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).trailer_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).private_data_size as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(private_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).ops_index as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(ops_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).local_cache as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(local_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).populated_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(populated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_list as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).nb_mem_chunks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(nb_mem_chunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mem_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mem_list)
        )
    );
}
impl Default for rte_mempool {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    /// @internal Check and update cookies or panic.
    ///
    /// @param mp
    ///   Pointer to the memory pool.
    /// @param obj_table_const
    ///   Pointer to a table of void * pointers (objects).
    /// @param n
    ///   Index of object in object table.
    /// @param free
    ///   - 0: object is supposed to be allocated, mark it as free
    ///   - 1: object is supposed to be free, mark it as allocated
    ///   - 2: just check that cookie is valid (free or allocated)
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// @internal Check contiguous object blocks and update cookies or panic.
    ///
    /// @param mp
    ///   Pointer to the memory pool.
    /// @param first_obj_table_const
    ///   Pointer to a table of void * pointers (first object of the contiguous
    ///   object blocks).
    /// @param n
    ///   Number of contiguous object blocks.
    /// @param free
    ///   - 0: object is supposed to be allocated, mark it as free
    ///   - 1: object is supposed to be free, mark it as allocated
    ///   - 2: just check that cookie is valid (free or allocated)
    pub fn rte_mempool_contig_blocks_check_cookies(
        mp: *const rte_mempool,
        first_obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
/// Prototype for implementation specific data provisioning function.
///
/// The function should provide the implementation specific memory for
/// use by the other mempool ops functions in a given mempool ops struct.
/// E.g. the default ops provides an instance of the rte_ring for this purpose.
/// it will most likely point to a different type of data structure, and
/// will be transparent to the application programmer.
/// This function should set mp->pool_data.
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
/// Free the opaque private data pointed to by mp->pool_data pointer.
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
/// Enqueue an object into the external pool.
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
/// Dequeue an object from the external pool.
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
/// @warning
/// @b EXPERIMENTAL: this API may change without prior notice.
///
/// Dequeue a number of contiquous object blocks from the external pool.
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
/// Return the number of available objects in the external pool.
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
/// Calculate memory size required to store given number of objects.
///
/// If mempool objects are not required to be IOVA-contiguous
/// (the flag MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines
/// virtually contiguous chunk size. Otherwise, if mempool objects must
/// be IOVA-contiguous (the flag MEMPOOL_F_NO_IOVA_CONTIG is clear),
/// min_chunk_size defines IOVA-contiguous chunk size.
///
/// @param[in] mp
///   Pointer to the memory pool.
/// @param[in] obj_num
///   Number of objects.
/// @param[in] pg_shift
///   LOG2 of the physical pages size. If set to 0, ignore page boundaries.
/// @param[out] min_chunk_size
///   Location for minimum size of the memory chunk which may be used to
///   store memory pool objects.
/// @param[out] align
///   Location for required memory chunk alignment.
/// @return
///   Required memory size aligned at page boundary.
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize,
>;
extern "C" {
    /// Default way to calculate memory size required to store given number of
    /// objects.
    ///
    /// If page boundaries may be ignored, it is just a product of total
    /// object size including header and trailer and number of objects.
    /// Otherwise, it is a number of pages required to store given number of
    /// objects without crossing page boundary.
    ///
    /// Note that if object size is bigger than page size, then it assumes
    /// that pages are grouped in subsets of physically continuous pages big
    /// enough to store at least one object.
    ///
    /// Minimum size of memory chunk is a maximum of the page size and total
    /// element size.
    ///
    /// Required memory chunk alignment is a maximum of page size and cache
    /// line size.
    pub fn rte_mempool_op_calc_mem_size_default(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
/// Function to be called for each populated object.
///
/// @param[in] mp
///   A pointer to the mempool structure.
/// @param[in] opaque
///   An opaque pointer passed to iterator.
/// @param[in] vaddr
///   Object virtual address.
/// @param[in] iova
///   Input/output virtual address of the object or RTE_BAD_IOVA.
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
/// Populate memory pool objects using provided memory chunk.
///
/// Populated objects should be enqueued to the pool, e.g. using
/// rte_mempool_ops_enqueue_bulk().
///
/// If the given IO address is unknown (iova = RTE_BAD_IOVA),
/// the chunk doesn't need to be physically contiguous (only virtually),
/// and allocated objects may span two pages.
///
/// @param[in] mp
///   A pointer to the mempool structure.
/// @param[in] max_objs
///   Maximum number of objects to be populated.
/// @param[in] vaddr
///   The virtual address of memory that should be used to store objects.
/// @param[in] iova
///   The IO address
/// @param[in] len
///   The length of memory in bytes.
/// @param[in] obj_cb
///   Callback function to be executed for each populated object.
/// @param[in] obj_cb_arg
///   An opaque pointer passed to the callback function.
/// @return
///   The number of objects added on success.
///   On error, no objects are populated and a negative errno is returned.
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Default way to populate memory pool object using provided memory
    /// chunk: just slice objects one by one.
    pub fn rte_mempool_op_populate_default(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
/// @warning
/// @b EXPERIMENTAL: this API may change without prior notice.
///
/// Get some additional information about a mempool.
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(mp: *const rte_mempool, info: *mut rte_mempool_info)
        -> ::std::os::raw::c_int,
>;
/// Structure defining mempool operations structure
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops {
    ///< Name of mempool ops struct.
    pub name: [::std::os::raw::c_char; 32usize],
    ///< Allocate private data.
    pub alloc: rte_mempool_alloc_t,
    ///< Free the external pool.
    pub free: rte_mempool_free_t,
    ///< Enqueue an object.
    pub enqueue: rte_mempool_enqueue_t,
    ///< Dequeue an object.
    pub dequeue: rte_mempool_dequeue_t,
    ///< Get qty of available objs.
    pub get_count: rte_mempool_get_count,
    /// Optional callback to calculate memory size required to
    /// store specified number of objects.
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    /// Optional callback to populate mempool objects using
    /// provided memory chunk.
    pub populate: rte_mempool_populate_t,
    /// Get mempool info
    pub get_info: rte_mempool_get_info_t,
    /// Dequeue a number of contiguous object blocks.
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
    pub __bindgen_padding_0: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).enqueue as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).calc_mem_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(calc_mem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).populate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(populate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_info as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue_contig_blocks as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue_contig_blocks)
        )
    );
}
impl Default for rte_mempool_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Structure storing the table of registered ops structs, each of which contain
/// the function pointers for the mempool ops functions.
/// Each process has its own storage for this ops struct array so that
/// the mempools can be shared across primary and secondary processes.
/// The indices used to access the array are valid across processes, whereas
/// any function pointers stored directly in the mempool struct would not be.
/// This results in us simply having "ops_index" in the mempool struct.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops_table {
    ///< Spinlock for add/delete.
    pub sl: rte_spinlock_t,
    ///< Number of used ops structs in the table.
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    /// Storage for all possible ops structs.
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops_table>(),
        2112usize,
        concat!("Size of: ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).num_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(num_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).ops as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for rte_mempool_ops_table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}rte_mempool_ops_table"]
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    /// @internal Wrapper for mempool_ops alloc callback.
    ///
    /// @param mp
    ///   Pointer to the memory pool.
    /// @return
    ///   - 0: Success; successfully allocated mempool pool_data.
    ///   - <0: Error; code of alloc function.
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @internal wrapper for mempool_ops get_count callback.
    ///
    /// @param mp
    ///   Pointer to the memory pool.
    /// @return
    ///   The number of available objects in the external pool.
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// @internal wrapper for mempool_ops calc_mem_size callback.
    /// API to calculate size of memory required to store specified number of
    /// object.
    ///
    /// @param[in] mp
    ///   Pointer to the memory pool.
    /// @param[in] obj_num
    ///   Number of objects.
    /// @param[in] pg_shift
    ///   LOG2 of the physical pages size. If set to 0, ignore page boundaries.
    /// @param[out] min_chunk_size
    ///   Location for minimum size of the memory chunk which may be used to
    ///   store memory pool objects.
    /// @param[out] align
    ///   Location for required memory chunk alignment.
    /// @return
    ///   Required memory size aligned at page boundary.
    pub fn rte_mempool_ops_calc_mem_size(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
extern "C" {
    /// @internal wrapper for mempool_ops populate callback.
    ///
    /// Populate memory pool objects using provided memory chunk.
    ///
    /// @param[in] mp
    ///   A pointer to the mempool structure.
    /// @param[in] max_objs
    ///   Maximum number of objects to be populated.
    /// @param[in] vaddr
    ///   The virtual address of memory that should be used to store objects.
    /// @param[in] iova
    ///   The IO address
    /// @param[in] len
    ///   The length of memory in bytes.
    /// @param[in] obj_cb
    ///   Callback function to be executed for each populated object.
    /// @param[in] obj_cb_arg
    ///   An opaque pointer passed to the callback function.
    /// @return
    ///   The number of objects added on success.
    ///   On error, no objects are populated and a negative errno is returned.
    pub fn rte_mempool_ops_populate(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Wrapper for mempool_ops get_info callback.
    ///
    /// @param[in] mp
    ///   Pointer to the memory pool.
    /// @param[out] info
    ///   Pointer to the rte_mempool_info structure
    /// @return
    ///   - 0: Success; The mempool driver supports retrieving supplementary
    ///        mempool information
    ///   - -ENOTSUP - doesn't support get_info ops (valid case).
    pub fn rte_mempool_ops_get_info(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @internal wrapper for mempool_ops free callback.
    ///
    /// @param mp
    ///   Pointer to the memory pool.
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    /// Set the ops of a mempool.
    ///
    /// This can only be done on a mempool that is not populated, i.e. just after
    /// a call to rte_mempool_create_empty().
    ///
    /// @param mp
    ///   Pointer to the memory pool.
    /// @param name
    ///   Name of the ops structure to use for this mempool.
    /// @param pool_config
    ///   Opaque data that can be passed by the application to the ops functions.
    /// @return
    ///   - 0: Success; the mempool is now using the requested ops functions.
    ///   - -EINVAL - Invalid ops struct name provided.
    ///   - -EEXIST - mempool already has an ops struct assigned.
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Register mempool operations.
    ///
    /// @param ops
    ///   Pointer to an ops structure to register.
    /// @return
    ///   - >=0: Success; return the index of the ops struct in the table.
    ///   - -EINVAL - some missing callbacks while registering ops struct.
    ///   - -ENOSPC - the maximum number of ops structs has been reached.
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
/// An object callback function for mempool.
///
/// Used by rte_mempool_create() and rte_mempool_obj_iter().
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
/// A memory callback function for mempool.
///
/// Used by rte_mempool_mem_iter().
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
/// A mempool constructor callback function.
///
/// Arguments are the mempool and the opaque pointer given by the user in
/// rte_mempool_create().
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    /// Create a new mempool named *name* in memory.
    ///
    /// This function uses ``rte_memzone_reserve()`` to allocate memory. The
    /// pool contains n elements of elt_size. Its size is set to n.
    ///
    /// @param name
    ///   The name of the mempool.
    /// @param n
    ///   The number of elements in the mempool. The optimum size (in terms of
    ///   memory usage) for a mempool is when n is a power of two minus one:
    ///   n = (2^q - 1).
    /// @param elt_size
    ///   The size of each element.
    /// @param cache_size
    ///   If cache_size is non-zero, the rte_mempool library will try to
    ///   limit the accesses to the common lockless pool, by maintaining a
    ///   per-lcore object cache. This argument must be lower or equal to
    ///   CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose
    ///   cache_size to have "n modulo cache_size == 0": if this is
    ///   not the case, some elements will always stay in the pool and will
    ///   never be used. The access to the per-lcore table is of course
    ///   faster than the multi-producer/consumer pool. The cache can be
    ///   disabled if the cache_size argument is set to 0; it can be useful to
    ///   avoid losing objects in cache.
    /// @param private_data_size
    ///   The size of the private data appended after the mempool
    ///   structure. This is useful for storing some private data after the
    ///   mempool structure, as is done for rte_mbuf_pool for example.
    /// @param mp_init
    ///   A function pointer that is called for initialization of the pool,
    ///   before object initialization. The user can initialize the private
    ///   data in this function if needed. This parameter can be NULL if
    ///   not needed.
    /// @param mp_init_arg
    ///   An opaque pointer to data that can be used in the mempool
    ///   constructor function.
    /// @param obj_init
    ///   A function pointer that is called for each object at
    ///   initialization of the pool. The user can set some meta data in
    ///   objects if needed. This parameter can be NULL if not needed.
    ///   The obj_init() function takes the mempool pointer, the init_arg,
    ///   the object pointer and the object number as parameters.
    /// @param obj_init_arg
    ///   An opaque pointer to data that can be used as an argument for
    ///   each call to the object constructor function.
    /// @param socket_id
    ///   The *socket_id* argument is the socket identifier in the case of
    ///   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
    ///   constraint for the reserved zone.
    /// @param flags
    ///   The *flags* arguments is an OR of following flags:
    ///   - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread
    ///     between channels in RAM: the pool allocator will add padding
    ///     between objects depending on the hardware configuration. See
    ///     Memory alignment constraints for details. If this flag is set,
    ///     the allocator will just align them to a cache line.
    ///   - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are
    ///     cache-aligned. This flag removes this constraint, and no
    ///     padding will be present between objects. This flag implies
    ///     MEMPOOL_F_NO_SPREAD.
    ///   - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior
    ///     when using rte_mempool_put() or rte_mempool_put_bulk() is
    ///     "single-producer". Otherwise, it is "multi-producers".
    ///   - MEMPOOL_F_SC_GET: If this flag is set, the default behavior
    ///     when using rte_mempool_get() or rte_mempool_get_bulk() is
    ///     "single-consumer". Otherwise, it is "multi-consumers".
    ///   - MEMPOOL_F_NO_IOVA_CONTIG: If set, allocated objects won't
    ///     necessarily be contiguous in IO memory.
    /// @return
    ///   The pointer to the new allocated mempool, on success. NULL on error
    ///   with rte_errno set appropriately. Possible rte_errno values include:
    ///    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
    ///    - E_RTE_SECONDARY - function was called from a secondary process instance
    ///    - EINVAL - cache size provided is too large
    ///    - ENOSPC - the maximum number of memzones has already been allocated
    ///    - EEXIST - a memzone with the same name already exists
    ///    - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    /// Create an empty mempool
    ///
    /// The mempool is allocated and initialized, but it is not populated: no
    /// memory is allocated for the mempool elements. The user has to call
    /// rte_mempool_populate_*() to add memory chunks to the pool. Once
    /// populated, the user may also want to initialize each object with
    /// rte_mempool_obj_iter().
    ///
    /// @param name
    ///   The name of the mempool.
    /// @param n
    ///   The maximum number of elements that can be added in the mempool.
    ///   The optimum size (in terms of memory usage) for a mempool is when n
    ///   is a power of two minus one: n = (2^q - 1).
    /// @param elt_size
    ///   The size of each element.
    /// @param cache_size
    ///   Size of the cache. See rte_mempool_create() for details.
    /// @param private_data_size
    ///   The size of the private data appended after the mempool
    ///   structure. This is useful for storing some private data after the
    ///   mempool structure, as is done for rte_mbuf_pool for example.
    /// @param socket_id
    ///   The *socket_id* argument is the socket identifier in the case of
    ///   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
    ///   constraint for the reserved zone.
    /// @param flags
    ///   Flags controlling the behavior of the mempool. See
    ///   rte_mempool_create() for details.
    /// @return
    ///   The pointer to the new allocated mempool, on success. NULL on error
    ///   with rte_errno set appropriately. See rte_mempool_create() for details.
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    /// Free a mempool
    ///
    /// Unlink the mempool from global list, free the memory chunks, and all
    /// memory referenced by the mempool. The objects must not be used by
    /// other cores as they will be freed.
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    /// Add physically contiguous memory for objects in the pool at init
    ///
    /// Add a virtually and physically contiguous memory chunk in the pool
    /// where objects can be instantiated.
    ///
    /// If the given IO address is unknown (iova = RTE_BAD_IOVA),
    /// the chunk doesn't need to be physically contiguous (only virtually),
    /// and allocated objects may span two pages.
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    /// @param vaddr
    ///   The virtual address of memory that should be used to store objects.
    /// @param iova
    ///   The IO address
    /// @param len
    ///   The length of memory in bytes.
    /// @param free_cb
    ///   The callback used to free this chunk when destroying the mempool.
    /// @param opaque
    ///   An opaque argument passed to free_cb.
    /// @return
    ///   The number of objects added on success.
    ///   On error, the chunk is not added in the memory list of the
    ///   mempool and a negative errno is returned.
    pub fn rte_mempool_populate_iova(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        iova: rte_iova_t,
        len: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add virtually contiguous memory for objects in the pool at init
    ///
    /// Add a virtually contiguous memory chunk in the pool where objects can
    /// be instantiated.
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    /// @param addr
    ///   The virtual address of memory that should be used to store objects.
    ///   Must be page-aligned.
    /// @param len
    ///   The length of memory in bytes. Must be page-aligned.
    /// @param pg_sz
    ///   The size of memory pages in this virtual area.
    /// @param free_cb
    ///   The callback used to free this chunk when destroying the mempool.
    /// @param opaque
    ///   An opaque argument passed to free_cb.
    /// @return
    ///   The number of objects added on success.
    ///   On error, the chunk is not added in the memory list of the
    ///   mempool and a negative errno is returned.
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: usize,
        pg_sz: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add memory for objects in the pool at init
    ///
    /// This is the default function used by rte_mempool_create() to populate
    /// the mempool. It adds memory allocated using rte_memzone_reserve().
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    /// @return
    ///   The number of objects added on success.
    ///   On error, the chunk is not added in the memory list of the
    ///   mempool and a negative errno is returned.
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add memory from anonymous mapping for objects in the pool at init
    ///
    /// This function mmap an anonymous memory zone that is locked in
    /// memory to store the objects of the mempool.
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    /// @return
    ///   The number of objects added on success.
    ///   On error, the chunk is not added in the memory list of the
    ///   mempool and a negative errno is returned.
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Call a function for each mempool element
    ///
    /// Iterate across all objects attached to a rte_mempool and call the
    /// callback function on it.
    ///
    /// @param mp
    ///   A pointer to an initialized mempool.
    /// @param obj_cb
    ///   A function pointer that is called for each object.
    /// @param obj_cb_arg
    ///   An opaque pointer passed to the callback function.
    /// @return
    ///   Number of objects iterated.
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    /// Call a function for each mempool memory chunk
    ///
    /// Iterate across all memory chunks attached to a rte_mempool and call
    /// the callback function on it.
    ///
    /// @param mp
    ///   A pointer to an initialized mempool.
    /// @param mem_cb
    ///   A function pointer that is called for each memory chunk.
    /// @param mem_cb_arg
    ///   An opaque pointer passed to the callback function.
    /// @return
    ///   Number of memory chunks iterated.
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    /// Dump the status of the mempool to a file.
    ///
    /// @param f
    ///   A pointer to a file for output
    /// @param mp
    ///   A pointer to the mempool structure.
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    /// Create a user-owned mempool cache.
    ///
    /// This can be used by non-EAL threads to enable caching when they
    /// interact with a mempool.
    ///
    /// @param size
    ///   The size of the mempool cache. See rte_mempool_create()'s cache_size
    ///   parameter description for more information. The same limits and
    ///   considerations apply here too.
    /// @param socket_id
    ///   The socket identifier in the case of NUMA. The value can be
    ///   SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone.
    pub fn rte_mempool_cache_create(
        size: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool_cache;
}
extern "C" {
    /// Free a user-owned mempool cache.
    ///
    /// @param cache
    ///   A pointer to the mempool cache.
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    /// Return the number of entries in the mempool.
    ///
    /// When cache is enabled, this function has to browse the length of
    /// all lcores, so it should not be used in a data path, but only for
    /// debug purposes. User-owned mempool caches are not accounted for.
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    /// @return
    ///   The number of entries in the mempool.
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Return the number of elements which have been allocated from the mempool
    ///
    /// When cache is enabled, this function has to browse the length of
    /// all lcores, so it should not be used in a data path, but only for
    /// debug purposes.
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    /// @return
    ///   The number of free entries in the mempool.
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Check the consistency of mempool objects.
    ///
    /// Verify the coherency of fields in the mempool structure. Also check
    /// that the cookies of mempool objects (even the ones that are not
    /// present in pool) have a correct value. If not, a panic will occur.
    ///
    /// @param mp
    ///   A pointer to the mempool structure.
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    /// Dump the status of all mempools on the console
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    /// Search a mempool from its name
    ///
    /// @param name
    ///   The name of the mempool.
    /// @return
    ///   The pointer to the mempool matching the name, or NULL if not found.
    ///   NULL on error
    ///   with rte_errno set appropriately. Possible rte_errno values include:
    ///    - ENOENT - required entry not available to return.
    ///
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
extern "C" {
    /// Get the header, trailer and total size of a mempool element.
    ///
    /// Given a desired size of the mempool element and mempool flags,
    /// calculates header, trailer, body and total sizes of the mempool object.
    ///
    /// @param elt_size
    ///   The size of each element, without header and trailer.
    /// @param flags
    ///   The flags used for the mempool creation.
    ///   Consult rte_mempool_create() for more information about possible values.
    ///   The size of each element.
    /// @param sz
    ///   The calculated detailed size the mempool object. May be NULL.
    /// @return
    ///   Total size of the mempool object.
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    /// Walk list of all memory pools
    ///
    /// @param func
    ///   Iterator function
    /// @param arg
    ///   Argument passed to iterator
    pub fn rte_mempool_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Get the name of the l2 packet type
    ///
    /// @param ptype
    ///   The packet type value.
    /// @return
    ///   A non-null string describing the packet type.
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the l3 packet type
    ///
    /// @param ptype
    ///   The packet type value.
    /// @return
    ///   A non-null string describing the packet type.
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the l4 packet type
    ///
    /// @param ptype
    ///   The packet type value.
    /// @return
    ///   A non-null string describing the packet type.
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the tunnel packet type
    ///
    /// @param ptype
    ///   The packet type value.
    /// @return
    ///   A non-null string describing the packet type.
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the inner_l2 packet type
    ///
    /// @param ptype
    ///   The packet type value.
    /// @return
    ///   A non-null string describing the packet type.
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the inner_l3 packet type
    ///
    /// @param ptype
    ///   The packet type value.
    /// @return
    ///   A non-null string describing the packet type.
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the name of the inner_l4 packet type
    ///
    /// @param ptype
    ///   The packet type value.
    /// @return
    ///   A non-null string describing the packet type.
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Write the packet type name into the buffer
    ///
    /// @param ptype
    ///   The packet type value.
    /// @param buf
    ///   The buffer where the string is written.
    /// @param buflen
    ///   The length of the buffer.
    /// @return
    ///   - 0 on success
    ///   - (-1) if the buffer is too small
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the name of a RX offload flag
    ///
    /// @param mask
    ///   The mask describing the flag.
    /// @return
    ///   The name of this flag, or NULL if it's not a valid RX flag.
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Dump the list of RX offload flags in a buffer
    ///
    /// @param mask
    ///   The mask describing the RX flags.
    /// @param buf
    ///   The output buffer.
    /// @param buflen
    ///   The length of the buffer.
    /// @return
    ///   0 on success, (-1) on error.
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the name of a TX offload flag
    ///
    /// @param mask
    ///   The mask describing the flag. Usually only one bit must be set.
    ///   Several bits can be given if they belong to the same mask.
    ///   Ex: PKT_TX_L4_MASK.
    /// @return
    ///   The name of this flag, or NULL if it's not a valid TX flag.
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Dump the list of TX offload flags in a buffer
    ///
    /// @param mask
    ///   The mask describing the TX flags.
    /// @param buf
    ///   The output buffer.
    /// @param buflen
    ///   The length of the buffer.
    /// @return
    ///   0 on success, (-1) on error.
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
pub type MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type MARKER8 = [u8; 0usize];
pub type MARKER64 = [u64; 0usize];
/// The generic rte_mbuf, containing a packet mbuf.
#[repr(C)]
pub struct rte_mbuf {
    pub cacheline0: MARKER,
    ///< Virtual address of segment buffer.
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    pub rearm_data: MARKER64,
    pub data_off: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    ///< Number of segments.
    pub nb_segs: u16,
    /// Input port (16 bits to support more than 256 virtual ports).
    /// The event eth Tx adapter uses this field to specify the output port.
    pub port: u16,
    ///< Offload features.
    pub ol_flags: u64,
    pub rx_descriptor_fields1: MARKER,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    ///< Total pkt len: sum of all segments.
    pub pkt_len: u32,
    ///< Amount of data in segment buffer.
    pub data_len: u16,
    /// VLAN TCI (CPU order), valid if PKT_RX_VLAN is set.
    pub vlan_tci: u16,
    pub __bindgen_anon_4: rte_mbuf__bindgen_ty_4,
    /// Outer VLAN TCI (CPU order), valid if PKT_RX_QINQ is set.
    pub vlan_tci_outer: u16,
    ///< Length of segment buffer.
    pub buf_len: u16,
    /// Valid if PKT_RX_TIMESTAMP is set. The unit and time reference
    /// are not normalized but are always the same for a given port.
    pub timestamp: u64,
    pub cacheline1: MARKER,
    pub __bindgen_anon_5: rte_mbuf__bindgen_ty_5,
    ///< Pool from which mbuf was allocated.
    pub pool: *mut rte_mempool,
    ///< Next segment of scattered packet.
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_6: rte_mbuf__bindgen_ty_6,
    /// Size of the application private data. In case of an indirect
    /// mbuf, it stores the direct mbuf private data size.
    pub priv_size: u16,
    /// Timesync flags for use with IEEE1588.
    pub timesync: u16,
    /// Sequence number. See also rte_reorder_insert().
    pub seqn: u32,
    /// Shared data for external buffer attached to mbuf. See
    /// rte_pktmbuf_attach_extbuf().
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    pub __bindgen_padding_0: [u64; 2usize],
}
/// Physical address of segment buffer.
/// Force alignment to 8-bytes, so as to ensure we have the exact
/// same mbuf cacheline0 layout for 32-bit and 64-bit. This makes
/// working on vector drivers easier.
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub buf_iova: rte_iova_t,
    ///< deprecated
    pub buf_physaddr: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1>())).buf_iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(buf_iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1>())).buf_physaddr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(buf_physaddr)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Reference counter. Its size should at least equal to the size
/// of port field (16 bits), to support zero-copy broadcast.
/// It should only be accessed using the following functions:
/// rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and
/// rte_mbuf_refcnt_set(). The functionality of these functions (atomic,
/// or non-atomic) is controlled by the CONFIG_RTE_MBUF_REFCNT_ATOMIC
/// config option.
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    ///< Atomically accessed refcnt
    pub refcnt_atomic: rte_atomic16_t,
    ///< Non-atomically accessed refcnt
    pub refcnt: u16,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2>())).refcnt_atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(refcnt_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2>())).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    ///< L2/L3/L4 and tunnel information.
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub inner_esp_next_proto: u8,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()))
                .inner_esp_next_proto as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(inner_esp_next_proto)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u32,
        l3_type: u32,
        l4_type: u32,
        tun_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u32 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u32 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u32 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u32 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u32 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3>())).packet_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(packet_type)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4 {
    ///< hash information
    pub hash: rte_mbuf__bindgen_ty_4__bindgen_ty_1,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_4__bindgen_ty_2,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4__bindgen_ty_1 {
    ///< RSS hash result if RSS enabled
    pub rss: u32,
    ///< Filter identifier if FDIR enabled
    pub fdir: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    ///< Hierarchical scheduler */
    ////**< User defined tags. See rte_distributor_process()
    pub sched: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >())).id as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . lo as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>())).hi
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub lo: u32,
    pub hi: u32,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>())).lo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>())).hi
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hi)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).rss as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).fdir as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(fdir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).sched as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>())).usr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(usr)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_2 {
    /// Application specific metadata value
    /// for egress flow rule match.
    /// Valid if PKT_TX_METADATA is set.
    /// Located here to allow conjunct use
    /// with hash.sched.hi.
    pub tx_metadata: u32,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_2>())).tx_metadata as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(tx_metadata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4__bindgen_ty_2>())).reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_5 {
    ///< Can be used for external metadata
    pub userdata: *mut ::std::os::raw::c_void,
    ///< Allow 8-byte userdata on 32-bit
    pub udata64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_5>())).userdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_5),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_5>())).udata64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_5),
            "::",
            stringify!(udata64)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_6 {
    ///< combined for easy fetch
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_6__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_mbuf__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u16>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_6__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_6__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_6__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_6__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_6>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_6>())).tx_offload as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_6),
            "::",
            stringify!(tx_offload)
        )
    );
}
impl Default for rte_mbuf__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rearm_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rearm_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_off as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).nb_segs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(nb_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).port as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).ol_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rx_descriptor_fields1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rx_descriptor_fields1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pkt_len as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci_outer as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci_outer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_len as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).timestamp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pool as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).next as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).priv_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).timesync as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timesync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).seqn as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(seqn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).shinfo as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(shinfo)
        )
    );
}
impl Default for rte_mbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Function typedef of callback to free externally attached buffer.
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
/// Shared data at the end of an external buffer.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_mbuf_ext_shared_info {
    ///< Free callback function
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    ///< Free callback argument
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    ///< Atomically accessed refcnt
    pub refcnt_atomic: rte_atomic16_t,
}
#[test]
fn bindgen_test_layout_rte_mbuf_ext_shared_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_ext_shared_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_ext_shared_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).free_cb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).fcb_opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(fcb_opaque)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf_ext_shared_info>())).refcnt_atomic as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(refcnt_atomic)
        )
    );
}
impl Default for rte_mbuf_ext_shared_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Private data in case of pktmbuf pool.
///
/// A structure that contains some pktmbuf_pool-specific data that are
/// appended after the mempool structure (in private data).
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pktmbuf_pool_private {
    ///< Size of data space in each mbuf.
    pub mbuf_data_room_size: u16,
    ///< Size of private area in each mbuf.
    pub mbuf_priv_size: u16,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_pool_private() {
    assert_eq!(
        ::std::mem::size_of::<rte_pktmbuf_pool_private>(),
        4usize,
        concat!("Size of: ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pktmbuf_pool_private>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_data_room_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_data_room_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_priv_size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_priv_size)
        )
    );
}
extern "C" {
    /// Sanity checks on an mbuf.
    ///
    /// Check the consistency of the given mbuf. The function will cause a
    /// panic if corruption is detected.
    ///
    /// @param m
    ///   The mbuf to be checked.
    /// @param is_header
    ///   True if the mbuf is a packet header, false if it is a sub-segment
    ///   of a packet (in this case, some fields like nb_segs are not checked)
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
extern "C" {
    /// The packet mbuf constructor.
    ///
    /// This function initializes some fields in the mbuf structure that are
    /// not modified by the user once created (origin pool, buffer start
    /// address, and so on). This function is given as a callback function to
    /// rte_mempool_obj_iter() or rte_mempool_create() at pool creation time.
    ///
    /// @param mp
    ///   The mempool from which mbufs originate.
    /// @param opaque_arg
    ///   A pointer that can be used by the user to retrieve useful information
    ///   for mbuf initialization. This pointer is the opaque argument passed to
    ///   rte_mempool_obj_iter() or rte_mempool_create().
    /// @param m
    ///   The mbuf to initialize.
    /// @param i
    ///   The index of the mbuf in the pool table.
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    /// A  packet mbuf pool constructor.
    ///
    /// This function initializes the mempool private data in the case of a
    /// pktmbuf pool. This private data is needed by the driver. The
    /// function must be called on the mempool before it is used, or it
    /// can be given as a callback function to rte_mempool_create() at
    /// pool creation. It can be extended by the user, for example, to
    /// provide another packet size.
    ///
    /// @param mp
    ///   The mempool from which mbufs originate.
    /// @param opaque_arg
    ///   A pointer that can be used by the user to retrieve useful information
    ///   for mbuf initialization. This pointer is the opaque argument passed to
    ///   rte_mempool_create().
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Create a mbuf pool.
    ///
    /// This function creates and initializes a packet mbuf pool. It is
    /// a wrapper to rte_mempool functions.
    ///
    /// @param name
    ///   The name of the mbuf pool.
    /// @param n
    ///   The number of elements in the mbuf pool. The optimum size (in terms
    ///   of memory usage) for a mempool is when n is a power of two minus one:
    ///   n = (2^q - 1).
    /// @param cache_size
    ///   Size of the per-core object cache. See rte_mempool_create() for
    ///   details.
    /// @param priv_size
    ///   Size of application private are between the rte_mbuf structure
    ///   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.
    /// @param data_room_size
    ///   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.
    /// @param socket_id
    ///   The socket identifier where the memory should be allocated. The
    ///   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the
    ///   reserved zone.
    /// @return
    ///   The pointer to the new allocated mempool, on success. NULL on error
    ///   with rte_errno set appropriately. Possible rte_errno values include:
    ///    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
    ///    - E_RTE_SECONDARY - function was called from a secondary process instance
    ///    - EINVAL - cache size provided is too large, or priv_size is not aligned.
    ///    - ENOSPC - the maximum number of memzones has already been allocated
    ///    - EEXIST - a memzone with the same name already exists
    ///    - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    /// Create a mbuf pool with a given mempool ops name
    ///
    /// This function creates and initializes a packet mbuf pool. It is
    /// a wrapper to rte_mempool functions.
    ///
    /// @param name
    ///   The name of the mbuf pool.
    /// @param n
    ///   The number of elements in the mbuf pool. The optimum size (in terms
    ///   of memory usage) for a mempool is when n is a power of two minus one:
    ///   n = (2^q - 1).
    /// @param cache_size
    ///   Size of the per-core object cache. See rte_mempool_create() for
    ///   details.
    /// @param priv_size
    ///   Size of application private are between the rte_mbuf structure
    ///   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.
    /// @param data_room_size
    ///   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.
    /// @param socket_id
    ///   The socket identifier where the memory should be allocated. The
    ///   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the
    ///   reserved zone.
    /// @param ops_name
    ///   The mempool ops name to be used for this mempool instead of
    ///   default mempool. The value can be *NULL* to use default mempool.
    /// @return
    ///   The pointer to the new allocated mempool, on success. NULL on error
    ///   with rte_errno set appropriately. Possible rte_errno values include:
    ///    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
    ///    - E_RTE_SECONDARY - function was called from a secondary process instance
    ///    - EINVAL - cache size provided is too large, or priv_size is not aligned.
    ///    - ENOSPC - the maximum number of memzones has already been allocated
    ///    - EEXIST - a memzone with the same name already exists
    ///    - ENOMEM - no appropriate memory area found in which to create memzone
    pub fn rte_pktmbuf_pool_create_by_ops(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ops_name: *const ::std::os::raw::c_char,
    ) -> *mut rte_mempool;
}
extern "C" {
    /// @internal used by rte_pktmbuf_read().
    pub fn __rte_pktmbuf_read(
        m: *const rte_mbuf,
        off: u32,
        len: u32,
        buf: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    /// Dump an mbuf structure to a file.
    ///
    /// Dump all fields for the given packet mbuf and all its associated
    /// segments (in the case of a chained buffer).
    ///
    /// @param f
    ///   A pointer to a file for output
    /// @param m
    ///   The packet mbuf.
    /// @param dump_len
    ///   If dump_len != 0, also dump the "dump_len" first data bytes of
    ///   the packet.
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
pub mod rte_timer_type {
    /// Timer type: Periodic or single (one-shot).
    pub type Type = u32;
    pub const SINGLE: Type = 0;
    pub const PERIODICAL: Type = 1;
}
/// Timer status: A union of the state (stopped, pending, running,
/// config) and an owner (the id of the lcore that owns the timer).
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_timer_status {
    pub __bindgen_anon_1: rte_timer_status__bindgen_ty_1,
    ///< To atomic-set status + owner.
    pub u32: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_timer_status__bindgen_ty_1 {
    ///< Stop, pending, running, config.
    pub state: u16,
    ///< The lcore that owns the timer.
    pub owner: i16,
}
#[test]
fn bindgen_test_layout_rte_timer_status__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer_status__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_timer_status__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer_status__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_timer_status__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_timer_status__bindgen_ty_1>())).state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_timer_status__bindgen_ty_1>())).owner as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_timer_status() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer_status>(),
        4usize,
        concat!("Size of: ", stringify!(rte_timer_status))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer_status>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_timer_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer_status>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status),
            "::",
            stringify!(u32)
        )
    );
}
impl Default for rte_timer_status {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Callback function type for timer expiry.
pub type rte_timer_cb_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_timer, arg2: *mut ::std::os::raw::c_void),
>;
/// A structure describing a timer in RTE.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_timer {
    ///< Time when timer expire.
    pub expire: u64,
    pub sl_next: [*mut rte_timer; 10usize],
    ///< Status of timer.
    pub status: rte_timer_status,
    ///< Period of timer (0 if not periodic).
    pub period: u64,
    ///< Callback function.
    pub f: rte_timer_cb_t,
    ///< Argument to callback function.
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_timer() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer>(),
        120usize,
        concat!("Size of: ", stringify!(rte_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_timer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).expire as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(expire)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).sl_next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(sl_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).status as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).period as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).f as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).arg as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(arg)
        )
    );
}
impl Default for rte_timer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Initialize the timer library.
    ///
    /// Initializes internal variables (list, locks and so on) for the RTE
    /// timer library.
    pub fn rte_timer_subsystem_init();
}
extern "C" {
    /// Initialize a timer handle.
    ///
    /// The rte_timer_init() function initializes the timer handle *tim*
    /// for use. No operations can be performed on a timer before it is
    /// initialized.
    ///
    /// @param tim
    ///   The timer to initialize.
    pub fn rte_timer_init(tim: *mut rte_timer);
}
extern "C" {
    /// Reset and start the timer associated with the timer handle.
    ///
    /// The rte_timer_reset() function resets and starts the timer
    /// associated with the timer handle *tim*. When the timer expires after
    /// *ticks* HPET cycles, the function specified by *fct* will be called
    /// with the argument *arg* on core *tim_lcore*.
    ///
    /// If the timer associated with the timer handle is already running
    /// (in the RUNNING state), the function will fail. The user has to check
    /// the return value of the function to see if there is a chance that the
    /// timer is in the RUNNING state.
    ///
    /// If the timer is being configured on another core (the CONFIG state),
    /// it will also fail.
    ///
    /// If the timer is pending or stopped, it will be rescheduled with the
    /// new parameters.
    ///
    /// @param tim
    ///   The timer handle.
    /// @param ticks
    ///   The number of cycles (see rte_get_hpet_hz()) before the callback
    ///   function is called.
    /// @param type
    ///   The type can be either:
    ///   - PERIODICAL: The timer is automatically reloaded after execution
    ///     (returns to the PENDING state)
    ///   - SINGLE: The timer is one-shot, that is, the timer goes to a
    ///     STOPPED state after execution.
    /// @param tim_lcore
    ///   The ID of the lcore where the timer callback function has to be
    ///   executed. If tim_lcore is LCORE_ID_ANY, the timer library will
    ///   launch it on a different core for each call (round-robin).
    /// @param fct
    ///   The callback function of the timer.
    /// @param arg
    ///   The user argument of the callback function.
    /// @return
    ///   - 0: Success; the timer is scheduled.
    ///   - (-1): Timer is in the RUNNING or CONFIG state.
    pub fn rte_timer_reset(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type::Type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Loop until rte_timer_reset() succeeds.
    ///
    /// Reset and start the timer associated with the timer handle. Always
    /// succeed. See rte_timer_reset() for details.
    ///
    /// @param tim
    ///   The timer handle.
    /// @param ticks
    ///   The number of cycles (see rte_get_hpet_hz()) before the callback
    ///   function is called.
    /// @param type
    ///   The type can be either:
    ///   - PERIODICAL: The timer is automatically reloaded after execution
    ///     (returns to the PENDING state)
    ///   - SINGLE: The timer is one-shot, that is, the timer goes to a
    ///     STOPPED state after execution.
    /// @param tim_lcore
    ///   The ID of the lcore where the timer callback function has to be
    ///   executed. If tim_lcore is LCORE_ID_ANY, the timer library will
    ///   launch it on a different core for each call (round-robin).
    /// @param fct
    ///   The callback function of the timer.
    /// @param arg
    ///   The user argument of the callback function.
    pub fn rte_timer_reset_sync(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type::Type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Stop a timer.
    ///
    /// The rte_timer_stop() function stops the timer associated with the
    /// timer handle *tim*. It may fail if the timer is currently running or
    /// being configured.
    ///
    /// If the timer is pending or stopped (for instance, already expired),
    /// the function will succeed. The timer handle tim must have been
    /// initialized using rte_timer_init(), otherwise, undefined behavior
    /// will occur.
    ///
    /// This function can be called safely from a timer callback. If it
    /// succeeds, the timer is not referenced anymore by the timer library
    /// and the timer structure can be freed (even in the callback
    /// function).
    ///
    /// @param tim
    ///   The timer handle.
    /// @return
    ///   - 0: Success; the timer is stopped.
    ///   - (-1): The timer is in the RUNNING or CONFIG state.
    pub fn rte_timer_stop(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Loop until rte_timer_stop() succeeds.
    ///
    /// After a call to this function, the timer identified by *tim* is
    /// stopped. See rte_timer_stop() for details.
    ///
    /// @param tim
    ///   The timer handle.
    pub fn rte_timer_stop_sync(tim: *mut rte_timer);
}
extern "C" {
    /// Test if a timer is pending.
    ///
    /// The rte_timer_pending() function tests the PENDING status
    /// of the timer handle *tim*. A PENDING timer is one that has been
    /// scheduled and whose function has not yet been called.
    ///
    /// @param tim
    ///   The timer handle.
    /// @return
    ///   - 0: The timer is not pending.
    ///   - 1: The timer is pending.
    pub fn rte_timer_pending(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Manage the timer list and execute callback functions.
    ///
    /// This function must be called periodically from EAL lcores
    /// main_loop(). It browses the list of pending timers and runs all
    /// timers that are expired.
    ///
    /// The precision of the timer depends on the call frequency of this
    /// function. However, the more often the function is called, the more
    /// CPU resources it will use.
    pub fn rte_timer_manage();
}
extern "C" {
    /// Dump statistics about timers.
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_timer_dump_stats(f: *mut FILE);
}
/// dummy structure type used by the rte_tailq APIs
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_tailq_entry {
    ///< Pointer entries for a tailq list
    pub next: rte_tailq_entry__bindgen_ty_1,
    ///< Pointer to the data referenced by this tailq entry
    pub data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_tailq_entry__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_entry,
    pub tqe_prev: *mut *mut rte_tailq_entry,
}
#[test]
fn bindgen_test_layout_rte_tailq_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_tailq_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_tailq_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tailq_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_tailq_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_tailq_entry__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_entry__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_tailq_entry__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_entry__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_tailq_entry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_tailq_entry() {
    assert_eq!(
        ::std::mem::size_of::<rte_tailq_entry>(),
        24usize,
        concat!("Size of: ", stringify!(rte_tailq_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tailq_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_tailq_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_entry>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_entry),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_entry>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_entry),
            "::",
            stringify!(data)
        )
    );
}
impl Default for rte_tailq_entry {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// dummy
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_tailq_entry_head {
    pub tqh_first: *mut rte_tailq_entry,
    pub tqh_last: *mut *mut rte_tailq_entry,
}
#[test]
fn bindgen_test_layout_rte_tailq_entry_head() {
    assert_eq!(
        ::std::mem::size_of::<rte_tailq_entry_head>(),
        16usize,
        concat!("Size of: ", stringify!(rte_tailq_entry_head))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tailq_entry_head>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_tailq_entry_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_entry_head>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_entry_head),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_entry_head>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_entry_head),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for rte_tailq_entry_head {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// The structure defining a tailq header entry for storing
/// in the rte_config structure in shared memory. Each tailq
/// is identified by name.
/// Any library storing a set of objects e.g. rings, mempools, hash-tables,
/// is recommended to use an entry here, so as to make it easy for
/// a multi-process app to find already-created elements in shared memory.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_tailq_head {
    ///< NOTE: must be first element
    pub tailq_head: rte_tailq_entry_head,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_rte_tailq_head() {
    assert_eq!(
        ::std::mem::size_of::<rte_tailq_head>(),
        48usize,
        concat!("Size of: ", stringify!(rte_tailq_head))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tailq_head>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_tailq_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_head>())).tailq_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_head),
            "::",
            stringify!(tailq_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_head>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_head),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_tailq_head {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_tailq_elem {
    /// Reference to head in shared mem, updated at init time by
    /// rte_eal_tailqs_init()
    pub head: *mut rte_tailq_head,
    pub next: rte_tailq_elem__bindgen_ty_1,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_tailq_elem__bindgen_ty_1 {
    pub tqe_next: *mut rte_tailq_elem,
    pub tqe_prev: *mut *mut rte_tailq_elem,
}
#[test]
fn bindgen_test_layout_rte_tailq_elem__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_tailq_elem__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_tailq_elem__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tailq_elem__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_tailq_elem__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_tailq_elem__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_elem__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_tailq_elem__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_elem__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_tailq_elem__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_tailq_elem() {
    assert_eq!(
        ::std::mem::size_of::<rte_tailq_elem>(),
        56usize,
        concat!("Size of: ", stringify!(rte_tailq_elem))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_tailq_elem>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_tailq_elem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_elem>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_elem),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_elem>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_elem),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_tailq_elem>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_tailq_elem),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_tailq_elem {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Dump tail queues to a file.
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_dump_tailq(f: *mut FILE);
}
extern "C" {
    /// Lookup for a tail queue.
    ///
    /// Get a pointer to a tail queue header of a tail
    /// queue identified by the name given as an argument.
    /// Note: this function is not multi-thread safe, and should only be called from
    /// a single thread at a time
    ///
    /// @param name
    ///   The name of the queue.
    /// @return
    ///   A pointer to the tail queue head structure.
    pub fn rte_eal_tailq_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_tailq_head;
}
extern "C" {
    /// Register a tail queue.
    ///
    /// Register a tail queue from shared memory.
    /// This function is mainly used by EAL_REGISTER_TAILQ macro which is used to
    /// register tailq from the different dpdk libraries. Since this macro is a
    /// constructor, the function has no access to dpdk shared memory, so the
    /// registered tailq can not be used before call to rte_eal_init() which calls
    /// rte_eal_tailqs_init().
    ///
    /// @param t
    ///   The tailq element which contains the name of the tailq you want to
    ///   create (/retrieve when in secondary process).
    /// @return
    ///   0 on success or -1 in case of an error.
    pub fn rte_eal_tailq_register(t: *mut rte_tailq_elem) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_elem {
    _unused: [u8; 0],
}
/// Structure to hold malloc heap
#[repr(C)]
#[derive(Copy, Clone)]
pub struct malloc_heap {
    pub lock: rte_spinlock_t,
    pub free_head: [malloc_heap__bindgen_ty_1; 13usize],
    pub first: *mut malloc_elem,
    pub last: *mut malloc_elem,
    pub alloc_count: ::std::os::raw::c_uint,
    pub socket_id: ::std::os::raw::c_uint,
    pub total_size: usize,
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_padding_0: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct malloc_heap__bindgen_ty_1 {
    pub lh_first: *mut malloc_elem,
}
#[test]
fn bindgen_test_layout_malloc_heap__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<malloc_heap__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(malloc_heap__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_heap__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_heap__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<malloc_heap__bindgen_ty_1>())).lh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for malloc_heap__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_malloc_heap() {
    assert_eq!(
        ::std::mem::size_of::<malloc_heap>(),
        192usize,
        concat!("Size of: ", stringify!(malloc_heap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).free_head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(free_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).first as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).last as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).alloc_count as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(alloc_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).socket_id as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).total_size as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(total_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<malloc_heap>())).name as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_heap),
            "::",
            stringify!(name)
        )
    );
}
impl Default for malloc_heap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// The rte_rwlock_t type.
///
/// cnt is -1 when write lock is held, and > 0 when read locks are held.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_rwlock_t {
    ///< -1 when W lock held, > 0 when R locks held.
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_rwlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_rwlock_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_rwlock_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    ///< name associated with an array
    pub name: [::std::os::raw::c_char; 64usize],
    ///< number of entries stored
    pub count: ::std::os::raw::c_uint,
    ///< current length of the array
    pub len: ::std::os::raw::c_uint,
    ///< size of each element
    pub elt_sz: ::std::os::raw::c_uint,
    ///< data pointer
    pub data: *mut ::std::os::raw::c_void,
    ///< multiprocess lock
    pub rwlock: rte_rwlock_t,
}
#[test]
fn bindgen_test_layout_rte_fbarray() {
    assert_eq!(
        ::std::mem::size_of::<rte_fbarray>(),
        96usize,
        concat!("Size of: ", stringify!(rte_fbarray))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fbarray>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_fbarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).len as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).elt_sz as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(elt_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).rwlock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(rwlock)
        )
    );
}
impl Default for rte_fbarray {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Set up ``rte_fbarray`` structure and allocate underlying resources.
    ///
    /// Call this function to correctly set up ``rte_fbarray`` and allocate
    /// underlying files that will be backing the data in the current process. Note
    /// that in order to use and share ``rte_fbarray`` between multiple processes,
    /// data pointed to by ``arr`` pointer must itself be allocated in shared memory.
    ///
    /// @param arr
    ///   Valid pointer to allocated ``rte_fbarray`` structure.
    ///
    /// @param name
    ///   Unique name to be assigned to this array.
    ///
    /// @param len
    ///   Number of elements initially available in the array.
    ///
    /// @param elt_sz
    ///   Size of each element.
    ///
    /// @return
    ///  - 0 on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Attach to a file backing an already allocated and correctly set up
    /// ``rte_fbarray`` structure.
    ///
    /// Call this function to attach to file that will be backing the data in the
    /// current process. The structure must have been previously correctly set up
    /// with a call to ``rte_fbarray_init()``. Calls to ``rte_fbarray_attach()`` are
    /// usually meant to be performed in a multiprocessing scenario, with data
    /// pointed to by ``arr`` pointer allocated in shared memory.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up rte_fbarray structure.
    ///
    /// @return
    ///  - 0 on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Deallocate resources for an already allocated and correctly set up
    /// ``rte_fbarray`` structure, and remove the underlying file.
    ///
    /// Call this function to deallocate all resources associated with an
    /// ``rte_fbarray`` structure within the current process. This will also
    /// zero-fill data pointed to by ``arr`` pointer and remove the underlying file
    /// backing the data, so it is expected that by the time this function is called,
    /// all other processes have detached from this ``rte_fbarray``.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @return
    ///  - 0 on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Deallocate resources for an already allocated and correctly set up
    /// ``rte_fbarray`` structure.
    ///
    /// Call this function to deallocate all resources associated with an
    /// ``rte_fbarray`` structure within current process.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @return
    ///  - 0 on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get pointer to element residing at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param idx
    ///   Index of an element to get a pointer to.
    ///
    /// @return
    ///  - non-NULL pointer on success.
    ///  - NULL on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Find index of a specified element within the array.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param elt
    ///   Pointer to element to find index to.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Mark specified element as used.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param idx
    ///   Element index to mark as used.
    ///
    /// @return
    ///  - 0 on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Mark specified element as free.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param idx
    ///   Element index to mark as free.
    ///
    /// @return
    ///  - 0 on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check whether element at specified index is marked as used.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param idx
    ///   Element index to check as used.
    ///
    /// @return
    ///  - 1 if element is used.
    ///  - 0 if element is unused.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find index of next free element, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find index of next used element, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find index of next chunk of ``n`` free elements, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @param n
    ///   Number of free elements to look for.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find index of next chunk of ``n`` used elements, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @param n
    ///   Number of used elements to look for.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find how many more free entries there are, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find how many more used entries there are, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find index of previous free element, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find index of previous used element, starting at specified index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find lowest start index of chunk of ``n`` free elements, down from specified
    /// index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @param n
    ///   Number of free elements to look for.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find lowest start index of chunk of ``n`` used elements, down from specified
    /// index.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @param n
    ///   Number of used elements to look for.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find how many more free entries there are before specified index (like
    /// ``rte_fbarray_find_contig_free`` but going in reverse).
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Find how many more used entries there are before specified index (like
    /// ``rte_fbarray_find_contig_used`` but going in reverse).
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param start
    ///   Element index to start search from.
    ///
    /// @return
    ///  - non-negative integer on success.
    ///  - -1 on failure, with ``rte_errno`` indicating reason for failure.
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump ``rte_fbarray`` metadata.
    ///
    /// @param arr
    ///   Valid pointer to allocated and correctly set up ``rte_fbarray`` structure.
    ///
    /// @param f
    ///   File object to dump information into.
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
/// memseg list is a special case as we need to store a bunch of other data
/// together with the array itself.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    ///< Page size for all memsegs in this list.
    pub page_sz: u64,
    ///< Socket ID for all memsegs in this list.
    pub socket_id: ::std::os::raw::c_int,
    ///< version number for multiprocess sync.
    pub version: u32,
    ///< Length of memory area covered by this memseg list.
    pub len: usize,
    ///< 1 if this list points to external memory
    pub external: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg_list__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).base_va as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(base_va)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
impl Default for rte_memseg_list__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_memseg_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list>(),
        136usize,
        concat!("Size of: ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).page_sz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(page_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).socket_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).external as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).memseg_arr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(memseg_arr)
        )
    );
}
impl Default for rte_memseg_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// the structure for the memory configuration for the RTE.
/// Used by the rte_config structure. It is separated out, as for multi-process
/// support, the memory details should be shared across instances
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_mem_config {
    ///< Magic number - Sanity check.
    pub magic: u32,
    ///< Number of channels (0 if unknown).
    pub nchannel: u32,
    ///< Number of ranks (0 if unknown).
    pub nrank: u32,
    ///< only used by memzone LIB for thread-safe.
    pub mlock: rte_rwlock_t,
    ///< used for tailq operation for thread safe.
    pub qlock: rte_rwlock_t,
    ///< only used by mempool LIB for thread-safe.
    pub mplock: rte_rwlock_t,
    pub memory_hotplug_lock: rte_rwlock_t,
    ///< Memzone descriptors.
    pub memzones: rte_fbarray,
    pub memsegs: [rte_memseg_list; 64usize],
    ///< Tailqs for objects
    pub tailq_head: [rte_tailq_head; 32usize],
    pub malloc_heaps: [malloc_heap; 32usize],
    pub next_socket_id: ::std::os::raw::c_int,
    pub mem_cfg_addr: u64,
    pub legacy_mem: u32,
    pub single_file_segments: u32,
    pub dma_maskbits: u8,
}
#[test]
fn bindgen_test_layout_rte_mem_config() {
    assert_eq!(
        ::std::mem::size_of::<rte_mem_config>(),
        16529usize,
        concat!("Size of: ", stringify!(rte_mem_config))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mem_config>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_mem_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).nchannel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(nchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).nrank as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(nrank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).mlock as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(mlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).qlock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(qlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).mplock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(mplock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mem_config>())).memory_hotplug_lock as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(memory_hotplug_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).memzones as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(memzones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).memsegs as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(memsegs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).tailq_head as *const _ as usize },
        8828usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(tailq_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).malloc_heaps as *const _ as usize },
        10364usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(malloc_heaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).next_socket_id as *const _ as usize },
        16508usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(next_socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).mem_cfg_addr as *const _ as usize },
        16512usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(mem_cfg_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).legacy_mem as *const _ as usize },
        16520usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(legacy_mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mem_config>())).single_file_segments as *const _ as usize
        },
        16524usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(single_file_segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_config>())).dma_maskbits as *const _ as usize },
        16528usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_config),
            "::",
            stringify!(dma_maskbits)
        )
    );
}
impl Default for rte_mem_config {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Function to be registered for the specific interrupt
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
pub mod rte_intr_handle_type {
    /// The interrupt source type, e.g. UIO, VFIO, ALARM etc.
    pub type Type = u32;
    ///< generic unknown handle
    pub const RTE_INTR_HANDLE_UNKNOWN: Type = 0;
    ///< uio device handle
    pub const RTE_INTR_HANDLE_UIO: Type = 1;
    ///< uio generic handle
    pub const RTE_INTR_HANDLE_UIO_INTX: Type = 2;
    ///< vfio device handle (legacy)
    pub const RTE_INTR_HANDLE_VFIO_LEGACY: Type = 3;
    ///< vfio device handle (MSI)
    pub const RTE_INTR_HANDLE_VFIO_MSI: Type = 4;
    ///< vfio device handle (MSIX)
    pub const RTE_INTR_HANDLE_VFIO_MSIX: Type = 5;
    ///< alarm handle
    pub const RTE_INTR_HANDLE_ALARM: Type = 6;
    ///< external handler
    pub const RTE_INTR_HANDLE_EXT: Type = 7;
    ///< virtual device
    pub const RTE_INTR_HANDLE_VDEV: Type = 8;
    ///< device event handle
    pub const RTE_INTR_HANDLE_DEV_EVENT: Type = 9;
    ///< VFIO request handle
    pub const RTE_INTR_HANDLE_VFIO_REQ: Type = 10;
    ///< count of elements
    pub const RTE_INTR_HANDLE_MAX: Type = 11;
}
pub type rte_intr_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(fd: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_epoll_data {
    ///< event type
    pub event: u32,
    ///< User data
    pub data: *mut ::std::os::raw::c_void,
    ///< IN: callback fun
    pub cb_fun: rte_intr_event_cb_t,
    ///< IN: callback arg
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_epoll_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_data>(),
        32usize,
        concat!("Size of: ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_data>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_fun as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_fun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_arg)
        )
    );
}
impl Default for rte_epoll_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_13 {
    pub type Type = u32;
    pub const RTE_EPOLL_INVALID: Type = 0;
    pub const RTE_EPOLL_VALID: Type = 1;
    pub const RTE_EPOLL_EXEC: Type = 2;
}
/// interrupt epoll event obj, taken by epoll_event.ptr
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_epoll_event {
    ///< OUT: event status
    pub status: u32,
    ///< OUT: event fd
    pub fd: ::std::os::raw::c_int,
    ///< OUT: epoll instance the ev associated with
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
#[test]
fn bindgen_test_layout_rte_epoll_event() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_event>(),
        48usize,
        concat!("Size of: ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(epfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(epdata)
        )
    );
}
impl Default for rte_epoll_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Interrupt handle
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    ///< interrupt event file descriptor
    pub fd: ::std::os::raw::c_int,
    ///< handle type
    pub type_: rte_intr_handle_type::Type,
    ///< max interrupt requested
    pub max_intr: u32,
    ///< number of available efd(event fd)
    pub nb_efd: u32,
    ///< size of efd counter, used for vdev
    pub efd_counter_size: u8,
    ///< intr vectors/efds mapping
    pub efds: [::std::os::raw::c_int; 32usize],
    pub elist: [rte_epoll_event; 32usize],
    ///< intr vector number array
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_intr_handle__bindgen_ty_1 {
    ///< VFIO device file descriptor
    pub vfio_dev_fd: ::std::os::raw::c_int,
    ///< UIO cfg file desc for uio_pci_generic
    pub uio_cfg_fd: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1>())).vfio_dev_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1),
            "::",
            stringify!(vfio_dev_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1>())).uio_cfg_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1),
            "::",
            stringify!(uio_cfg_fd)
        )
    );
}
impl Default for rte_intr_handle__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_intr_handle() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle>(),
        1696usize,
        concat!("Size of: ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).max_intr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(max_intr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).nb_efd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(nb_efd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle>())).efd_counter_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(efd_counter_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).efds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(efds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).elist as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(elist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).intr_vec as *const _ as usize },
        1688usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(intr_vec)
        )
    );
}
impl Default for rte_intr_handle {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// It waits for events on the epoll instance.
    ///
    /// @param epfd
    ///   Epoll instance fd on which the caller wait for events.
    /// @param events
    ///   Memory area contains the events that will be available for the caller.
    /// @param maxevents
    ///   Up to maxevents are returned, must greater than zero.
    /// @param timeout
    ///   Specifying a timeout of -1 causes a block indefinitely.
    ///   Specifying a timeout equal to zero cause to return immediately.
    /// @return
    ///   - On success, returns the number of available event.
    ///   - On failure, a negative value.
    pub fn rte_epoll_wait(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It performs control operations on epoll instance referred by the epfd.
    /// It requests that the operation op be performed for the target fd.
    ///
    /// @param epfd
    ///   Epoll instance fd on which the caller perform control operations.
    /// @param op
    ///   The operation be performed for the target fd.
    /// @param fd
    ///   The target fd on which the control ops perform.
    /// @param event
    ///   Describes the object linked to the fd.
    ///   Note: The caller must take care the object deletion after CTL_DEL.
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_epoll_ctl(
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        event: *mut rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// The function returns the per thread epoll instance.
    ///
    /// @return
    ///   epfd the epoll instance referred to.
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
extern "C" {
    /// @param intr_handle
    ///   Pointer to the interrupt handle.
    /// @param epfd
    ///   Epoll instance fd which the intr vector associated to.
    /// @param op
    ///   The operation be performed for the vector.
    ///   Operation type of {ADD, DEL}.
    /// @param vec
    ///   RX intr vector number added to the epoll instance wait list.
    /// @param data
    ///   User raw data.
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_intr_rx_ctl(
        intr_handle: *mut rte_intr_handle,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It deletes registered eventfds.
    ///
    /// @param intr_handle
    ///   Pointer to the interrupt handle.
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    /// It enables the packet I/O interrupt event if it's necessary.
    /// It creates event fd for each interrupt vector when MSIX is used,
    /// otherwise it multiplexes a single event fd.
    ///
    /// @param intr_handle
    ///   Pointer to the interrupt handle.
    /// @param nb_efd
    ///   Number of interrupt vector trying to enable.
    ///   The value 0 is not allowed.
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_intr_efd_enable(
        intr_handle: *mut rte_intr_handle,
        nb_efd: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It disables the packet I/O interrupt event.
    /// It deletes registered eventfds and closes the open fds.
    ///
    /// @param intr_handle
    ///   Pointer to the interrupt handle.
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    /// The packet I/O interrupt on datapath is enabled or not.
    ///
    /// @param intr_handle
    ///   Pointer to the interrupt handle.
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    /// The interrupt handle instance allows other causes or not.
    /// Other causes stand for any none packet I/O interrupts.
    ///
    /// @param intr_handle
    ///   Pointer to the interrupt handle.
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    /// The multiple interrupt vector capability of interrupt handle instance.
    /// It returns zero if no multiple interrupt vector support.
    ///
    /// @param intr_handle
    ///   Pointer to the interrupt handle.
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It registers the callback for the specific interrupt. Multiple
    /// callbacks cal be registered at the same time.
    /// @param intr_handle
    ///  Pointer to the interrupt handle.
    /// @param cb
    ///  callback address.
    /// @param cb_arg
    ///  address of parameter for callback.
    ///
    /// @return
    ///  - On success, zero.
    ///  - On failure, a negative value.
    pub fn rte_intr_callback_register(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It unregisters the callback according to the specified interrupt handle.
    ///
    /// @param intr_handle
    ///  pointer to the interrupt handle.
    /// @param cb
    ///  callback address.
    /// @param cb_arg
    ///  address of parameter for callback, (void *)-1 means to remove all
    ///  registered which has the same callback address.
    ///
    /// @return
    ///  - On success, return the number of callback entities removed.
    ///  - On failure, a negative value.
    pub fn rte_intr_callback_unregister(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It enables the interrupt for the specified handle.
    ///
    /// @param intr_handle
    ///  pointer to the interrupt handle.
    ///
    /// @return
    ///  - On success, zero.
    ///  - On failure, a negative value.
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It disables the interrupt for the specified handle.
    ///
    /// @param intr_handle
    ///  pointer to the interrupt handle.
    ///
    /// @return
    ///  - On success, zero.
    ///  - On failure, a negative value.
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
/// A structure describing an ID for a PCI driver. Each driver provides a
/// table of these IDs for each device that it supports.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pci_id {
    ///< Class ID or RTE_CLASS_ANY_ID.
    pub class_id: u32,
    ///< Vendor ID or PCI_ANY_ID.
    pub vendor_id: u16,
    ///< Device ID or PCI_ANY_ID.
    pub device_id: u16,
    ///< Subsystem vendor ID or PCI_ANY_ID.
    pub subsystem_vendor_id: u16,
    ///< Subsystem device ID or PCI_ANY_ID.
    pub subsystem_device_id: u16,
}
#[test]
fn bindgen_test_layout_rte_pci_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_id>(),
        12usize,
        concat!("Size of: ", stringify!(rte_pci_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).class_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).vendor_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).device_id as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_vendor_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_device_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_device_id)
        )
    );
}
/// A structure describing the location of a PCI device.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_pci_addr {
    ///< Device domain
    pub domain: u32,
    ///< Device bus
    pub bus: u8,
    ///< Device ID
    pub devid: u8,
    ///< Device function.
    pub function: u8,
}
#[test]
fn bindgen_test_layout_rte_pci_addr() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_addr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).bus as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).devid as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).function as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(function)
        )
    );
}
/// A structure describing a PCI mapping.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct pci_map {
    pub addr: *mut ::std::os::raw::c_void,
    pub path: *mut ::std::os::raw::c_char,
    pub offset: u64,
    pub size: u64,
    pub phaddr: u64,
}
#[test]
fn bindgen_test_layout_pci_map() {
    assert_eq!(
        ::std::mem::size_of::<pci_map>(),
        40usize,
        concat!("Size of: ", stringify!(pci_map))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_map>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).phaddr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(phaddr)
        )
    );
}
impl Default for pci_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct pci_msix_table {
    pub bar_index: ::std::os::raw::c_int,
    pub offset: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_pci_msix_table() {
    assert_eq!(
        ::std::mem::size_of::<pci_msix_table>(),
        12usize,
        concat!("Size of: ", stringify!(pci_msix_table))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_msix_table>(),
        4usize,
        concat!("Alignment of ", stringify!(pci_msix_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_msix_table>())).bar_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_msix_table),
            "::",
            stringify!(bar_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_msix_table>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_msix_table),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_msix_table>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_msix_table),
            "::",
            stringify!(size)
        )
    );
}
/// A structure describing a mapped PCI resource.
/// For multi-process we need to reproduce all PCI mappings in secondary
/// processes, so save them in a tailq.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mapped_pci_resource {
    pub next: mapped_pci_resource__bindgen_ty_1,
    pub pci_addr: rte_pci_addr,
    pub path: [::std::os::raw::c_char; 4096usize],
    pub nb_maps: ::std::os::raw::c_int,
    pub maps: [pci_map; 6usize],
    pub msix_table: pci_msix_table,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct mapped_pci_resource__bindgen_ty_1 {
    pub tqe_next: *mut mapped_pci_resource,
    pub tqe_prev: *mut *mut mapped_pci_resource,
}
#[test]
fn bindgen_test_layout_mapped_pci_resource__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mapped_pci_resource__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mapped_pci_resource__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mapped_pci_resource__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(mapped_pci_resource__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mapped_pci_resource__bindgen_ty_1>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mapped_pci_resource__bindgen_ty_1>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for mapped_pci_resource__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_mapped_pci_resource() {
    assert_eq!(
        ::std::mem::size_of::<mapped_pci_resource>(),
        4384usize,
        concat!("Size of: ", stringify!(mapped_pci_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<mapped_pci_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(mapped_pci_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).pci_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(pci_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).path as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).nb_maps as *const _ as usize },
        4120usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(nb_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).maps as *const _ as usize },
        4128usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).msix_table as *const _ as usize },
        4368usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(msix_table)
        )
    );
}
impl Default for mapped_pci_resource {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// mapped pci device list
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct mapped_pci_res_list {
    pub tqh_first: *mut mapped_pci_resource,
    pub tqh_last: *mut *mut mapped_pci_resource,
}
#[test]
fn bindgen_test_layout_mapped_pci_res_list() {
    assert_eq!(
        ::std::mem::size_of::<mapped_pci_res_list>(),
        16usize,
        concat!("Size of: ", stringify!(mapped_pci_res_list))
    );
    assert_eq!(
        ::std::mem::align_of::<mapped_pci_res_list>(),
        8usize,
        concat!("Alignment of ", stringify!(mapped_pci_res_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_res_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_res_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_res_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_res_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for mapped_pci_res_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// @deprecated
    /// Utility function to produce a PCI Bus-Device-Function value
    /// given a string representation. Assumes that the BDF is provided without
    /// a domain prefix (i.e. domain returned is always 0)
    ///
    /// @param input
    ///	The input string to be parsed. Should have the format XX:XX.X
    /// @param dev_addr
    ///	The PCI Bus-Device-Function address to be returned.
    ///	Domain will always be returned as 0
    /// @return
    ///  0 on success, negative on error.
    pub fn eal_parse_pci_BDF(
        input: *const ::std::os::raw::c_char,
        dev_addr: *mut rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @deprecated
    /// Utility function to produce a PCI Bus-Device-Function value
    /// given a string representation. Assumes that the BDF is provided including
    /// a domain prefix.
    ///
    /// @param input
    ///	The input string to be parsed. Should have the format XXXX:XX:XX.X
    /// @param dev_addr
    ///	The PCI Bus-Device-Function address to be returned
    /// @return
    ///  0 on success, negative on error.
    pub fn eal_parse_pci_DomBDF(
        input: *const ::std::os::raw::c_char,
        dev_addr: *mut rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Utility function to write a pci device name, this device name can later be
    /// used to retrieve the corresponding rte_pci_addr using eal_parse_pci_*
    /// BDF helpers.
    ///
    /// @param addr
    ///	The PCI Bus-Device-Function address
    /// @param output
    ///	The output buffer string
    /// @param size
    ///	The output buffer size
    pub fn rte_pci_device_name(
        addr: *const rte_pci_addr,
        output: *mut ::std::os::raw::c_char,
        size: usize,
    );
}
extern "C" {
    /// @deprecated
    /// Utility function to compare two PCI device addresses.
    ///
    /// @param addr
    ///	The PCI Bus-Device-Function address to compare
    /// @param addr2
    ///	The PCI Bus-Device-Function address to compare
    /// @return
    ///	0 on equal PCI address.
    ///	Positive on addr is greater than addr2.
    ///	Negative on addr is less than addr2, or error.
    pub fn rte_eal_compare_pci_addr(
        addr: *const rte_pci_addr,
        addr2: *const rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Utility function to compare two PCI device addresses.
    ///
    /// @param addr
    ///	The PCI Bus-Device-Function address to compare
    /// @param addr2
    ///	The PCI Bus-Device-Function address to compare
    /// @return
    ///	0 on equal PCI address.
    ///	Positive on addr is greater than addr2.
    ///	Negative on addr is less than addr2, or error.
    pub fn rte_pci_addr_cmp(
        addr: *const rte_pci_addr,
        addr2: *const rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Utility function to parse a string into a PCI location.
    ///
    /// @param str
    ///	The string to parse
    /// @param addr
    ///	The reference to the structure where the location
    ///	is stored.
    /// @return
    ///	0 on success
    ///	<0 otherwise
    pub fn rte_pci_addr_parse(
        str: *const ::std::os::raw::c_char,
        addr: *mut rte_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Map a particular resource from a file.
    ///
    /// @param requested_addr
    ///      The starting address for the new mapping range.
    /// @param fd
    ///      The file descriptor.
    /// @param offset
    ///      The offset for the mapping range.
    /// @param size
    ///      The size for the mapping range.
    /// @param additional_flags
    ///      The additional flags for the mapping range.
    /// @return
    ///   - On success, the function returns a pointer to the mapped area.
    ///   - On error, the value MAP_FAILED is returned.
    pub fn pci_map_resource(
        requested_addr: *mut ::std::os::raw::c_void,
        fd: ::std::os::raw::c_int,
        offset: off_t,
        size: usize,
        additional_flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Unmap a particular resource.
    ///
    /// @param requested_addr
    ///      The address for the unmapping range.
    /// @param size
    ///      The size for the unmapping range.
    pub fn pci_unmap_resource(requested_addr: *mut ::std::os::raw::c_void, size: usize);
}
pub mod rte_devtype {
    /// Type of generic device
    pub type Type = u32;
    pub const RTE_DEVTYPE_WHITELISTED_PCI: Type = 0;
    pub const RTE_DEVTYPE_BLACKLISTED_PCI: Type = 1;
    pub const RTE_DEVTYPE_VIRTUAL: Type = 2;
}
/// Structure that stores a device given by the user with its arguments
///
/// A user device is a physical or a virtual device given by the user to
/// the DPDK application at startup through command line arguments.
///
/// The structure stores the configuration of the device, its PCI
/// identifier if it's a PCI device or the driver name if it's a virtual
/// device.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    /// Next in list.
    pub next: rte_devargs__bindgen_ty_1,
    /// Type of device.
    pub type_: rte_devtype::Type,
    /// Device policy.
    pub policy: rte_dev_policy::Type,
    /// Name of the device.
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    ///< bus handle.
    pub bus: *mut rte_bus,
    ///< class handle.
    pub cls: *mut rte_class,
    ///< bus-related part of device string.
    pub bus_str: *const ::std::os::raw::c_char,
    ///< class-related part of device string.
    pub cls_str: *const ::std::os::raw::c_char,
    ///< Device string storage.
    pub data: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
impl Default for rte_devargs__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    /// Arguments string as given by user or "" for no argument.
    pub args: *mut ::std::os::raw::c_char,
    pub drv_str: *const ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_devargs__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs__bindgen_ty_2>())).args as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_2),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_2>())).drv_str as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_2),
            "::",
            stringify!(drv_str)
        )
    );
}
impl Default for rte_devargs__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_devargs() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs>(),
        136usize,
        concat!("Size of: ", stringify!(rte_devargs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).policy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).bus as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).cls as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).bus_str as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(bus_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).cls_str as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(cls_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).data as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(data)
        )
    );
}
impl Default for rte_devargs {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Parse a device string.
    ///
    /// Verify that a bus is capable of handling the device passed
    /// in argument. Store which bus will handle the device, its name
    /// and the eventual device parameters.
    ///
    /// The syntax is:
    ///
    ///     bus:device_identifier,arg1=val1,arg2=val2
    ///
    /// where "bus:" is the bus name followed by any character separator.
    /// The bus name is optional. If no bus name is specified, each bus
    /// will attempt to recognize the device identifier. The first one
    /// to succeed will be used.
    ///
    /// Examples:
    ///
    ///     pci:0000:05.00.0,arg=val
    ///     05.00.0,arg=val
    ///     vdev:net_ring0
    ///
    /// @param da
    ///   The devargs structure holding the device information.
    ///
    /// @param dev
    ///   String describing a device.
    ///
    /// @return
    ///   - 0 on success.
    ///   - Negative errno on error.
    pub fn rte_devargs_parse(
        da: *mut rte_devargs,
        dev: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Parse a device string.
    ///
    /// Verify that a bus is capable of handling the device passed
    /// in argument. Store which bus will handle the device, its name
    /// and the eventual device parameters.
    ///
    /// The device string is built with a printf-like syntax.
    ///
    /// The syntax is:
    ///
    ///     bus:device_identifier,arg1=val1,arg2=val2
    ///
    /// where "bus:" is the bus name followed by any character separator.
    /// The bus name is optional. If no bus name is specified, each bus
    /// will attempt to recognize the device identifier. The first one
    /// to succeed will be used.
    ///
    /// Examples:
    ///
    ///     pci:0000:05.00.0,arg=val
    ///     05.00.0,arg=val
    ///     vdev:net_ring0
    ///
    /// @param da
    ///   The devargs structure holding the device information.
    /// @param format
    ///   Format string describing a device.
    ///
    /// @return
    ///   - 0 on success.
    ///   - Negative errno on error.
    pub fn rte_devargs_parsef(
        da: *mut rte_devargs,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Insert an rte_devargs in the global list.
    ///
    /// @param da
    ///  The devargs structure to insert.
    ///  If a devargs for the same device is already inserted,
    ///  it will be updated and returned. It means *da pointer can change.
    ///
    /// @return
    ///   - 0 on success
    ///   - Negative on error.
    pub fn rte_devargs_insert(da: *mut *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a device to the user device list
    /// See rte_devargs_parse() for details.
    ///
    /// @param devtype
    ///   The type of the device.
    /// @param devargs_str
    ///   The arguments as given by the user.
    ///
    /// @return
    ///   - 0 on success
    ///   - A negative value on error
    pub fn rte_devargs_add(
        devtype: rte_devtype::Type,
        devargs_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a device from the user device list.
    /// Its resources are freed.
    /// If the devargs cannot be found, nothing happens.
    ///
    /// @param devargs
    ///   The instance or a copy of devargs to remove.
    ///
    /// @return
    ///   0 on success.
    ///   <0 on error.
    ///   >0 if the devargs was not within the user device list.
    pub fn rte_devargs_remove(devargs: *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Count the number of user devices of a specified type
    ///
    /// @param devtype
    ///   The type of the devices to counted.
    ///
    /// @return
    ///   The number of devices.
    pub fn rte_devargs_type_count(devtype: rte_devtype::Type) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// This function dumps the list of user device and their arguments.
    ///
    /// @param f
    ///   A pointer to a file for output
    pub fn rte_devargs_dump(f: *mut FILE);
}
extern "C" {
    /// Find next rte_devargs matching the provided bus name.
    ///
    /// @param busname
    ///   Limit the iteration to devargs related to buses
    ///   matching this name.
    ///   Will return any next rte_devargs if NULL.
    ///
    /// @param start
    ///   Starting iteration point. The iteration will start at
    ///   the first rte_devargs if NULL.
    ///
    /// @return
    ///   Next rte_devargs entry matching the requested bus,
    ///   NULL if there is none.
    pub fn rte_devargs_next(
        busname: *const ::std::os::raw::c_char,
        start: *const rte_devargs,
    ) -> *mut rte_devargs;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
/// Ethernet address:
/// A universally administered address is uniquely assigned to a device by its
/// manufacturer. The first three octets (in transmission order) contain the
/// Organizationally Unique Identifier (OUI). The following three (MAC-48 and
/// EUI-48) octets are assigned by that organization with the only constraint
/// of uniqueness.
/// A locally administered address is assigned to a device by a network
/// administrator and does not contain OUIs.
/// See http://standards.ieee.org/regauth/groupmac/tutorial.html
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ether_addr {
    ///< Addr bytes in tx order
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(
        ::std::mem::size_of::<ether_addr>(),
        6usize,
        concat!("Size of: ", stringify!(ether_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(ether_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_addr>())).addr_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_addr),
            "::",
            stringify!(addr_bytes)
        )
    );
}
/// Ethernet header: Contains the destination address, source address
/// and frame type.
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ether_hdr {
    ///< Destination address.
    pub d_addr: ether_addr,
    ///< Source address.
    pub s_addr: ether_addr,
    ///< Frame type.
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_ether_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ether_hdr>(),
        14usize,
        concat!("Size of: ", stringify!(ether_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ether_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_hdr>())).d_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_hdr),
            "::",
            stringify!(d_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_hdr>())).s_addr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_hdr),
            "::",
            stringify!(s_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_hdr>())).ether_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_hdr),
            "::",
            stringify!(ether_type)
        )
    );
}
/// Ethernet VLAN Header.
/// Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type
/// of the encapsulated frame.
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vlan_hdr {
    ///< Priority (3) + CFI (1) + Identifier Code (12)
    pub vlan_tci: u16,
    ///< Ethernet type of encapsulated frame.
    pub eth_proto: u16,
}
#[test]
fn bindgen_test_layout_vlan_hdr() {
    assert_eq!(
        ::std::mem::size_of::<vlan_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(vlan_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<vlan_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(vlan_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vlan_hdr>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vlan_hdr),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vlan_hdr>())).eth_proto as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vlan_hdr),
            "::",
            stringify!(eth_proto)
        )
    );
}
/// VXLAN protocol header.
/// Contains the 8-bit flag, 24-bit VXLAN Network Identifier and
/// Reserved fields (24 bits and 8 bits)
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vxlan_hdr {
    ///< flag (8) + Reserved (24).
    pub vx_flags: u32,
    ///< VNI (24) + Reserved (8).
    pub vx_vni: u32,
}
#[test]
fn bindgen_test_layout_vxlan_hdr() {
    assert_eq!(
        ::std::mem::size_of::<vxlan_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(vxlan_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<vxlan_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(vxlan_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_hdr>())).vx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_hdr),
            "::",
            stringify!(vx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_hdr>())).vx_vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_hdr),
            "::",
            stringify!(vx_vni)
        )
    );
}
/// VXLAN-GPE protocol header (draft-ietf-nvo3-vxlan-gpe-05).
/// Contains the 8-bit flag, 8-bit next-protocol, 24-bit VXLAN Network
/// Identifier and Reserved fields (16 bits and 8 bits).
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct vxlan_gpe_hdr {
    ///< flag (8).
    pub vx_flags: u8,
    ///< Reserved (16).
    pub reserved: [u8; 2usize],
    ///< next-protocol (8).
    pub proto: u8,
    ///< VNI (24) + Reserved (8).
    pub vx_vni: u32,
}
#[test]
fn bindgen_test_layout_vxlan_gpe_hdr() {
    assert_eq!(
        ::std::mem::size_of::<vxlan_gpe_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(vxlan_gpe_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<vxlan_gpe_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(vxlan_gpe_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_gpe_hdr>())).vx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_gpe_hdr),
            "::",
            stringify!(vx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_gpe_hdr>())).reserved as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_gpe_hdr),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_gpe_hdr>())).proto as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_gpe_hdr),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_gpe_hdr>())).vx_vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_gpe_hdr),
            "::",
            stringify!(vx_vni)
        )
    );
}
pub mod rte_filter_type {
    /// Feature filter types
    pub type Type = u32;
    pub const RTE_ETH_FILTER_NONE: Type = 0;
    pub const RTE_ETH_FILTER_MACVLAN: Type = 1;
    pub const RTE_ETH_FILTER_ETHERTYPE: Type = 2;
    pub const RTE_ETH_FILTER_FLEXIBLE: Type = 3;
    pub const RTE_ETH_FILTER_SYN: Type = 4;
    pub const RTE_ETH_FILTER_NTUPLE: Type = 5;
    pub const RTE_ETH_FILTER_TUNNEL: Type = 6;
    pub const RTE_ETH_FILTER_FDIR: Type = 7;
    pub const RTE_ETH_FILTER_HASH: Type = 8;
    pub const RTE_ETH_FILTER_L2_TUNNEL: Type = 9;
    pub const RTE_ETH_FILTER_GENERIC: Type = 10;
    pub const RTE_ETH_FILTER_MAX: Type = 11;
}
pub mod rte_filter_op {
    /// Generic operations on filters
    pub type Type = u32;
    /// used to check whether the type filter is supported
    pub const RTE_ETH_FILTER_NOP: Type = 0;
    ///< add filter entry
    pub const RTE_ETH_FILTER_ADD: Type = 1;
    ///< update filter entry
    pub const RTE_ETH_FILTER_UPDATE: Type = 2;
    ///< delete filter entry
    pub const RTE_ETH_FILTER_DELETE: Type = 3;
    ///< flush all entries
    pub const RTE_ETH_FILTER_FLUSH: Type = 4;
    ///< get filter entry
    pub const RTE_ETH_FILTER_GET: Type = 5;
    ///< configurations
    pub const RTE_ETH_FILTER_SET: Type = 6;
    ///< retrieve information
    pub const RTE_ETH_FILTER_INFO: Type = 7;
    ///< retrieve statistics
    pub const RTE_ETH_FILTER_STATS: Type = 8;
    pub const RTE_ETH_FILTER_OP_MAX: Type = 9;
}
pub mod rte_mac_filter_type {
    /// MAC filter type
    pub type Type = u32;
    ///< exact match of MAC addr.
    pub const RTE_MAC_PERFECT_MATCH: Type = 1;
    ///< exact match of MAC addr and VLAN ID.
    pub const RTE_MACVLAN_PERFECT_MATCH: Type = 2;
    ///< hash match of MAC addr.
    pub const RTE_MAC_HASH_MATCH: Type = 3;
    /// hash match of MAC addr and exact match of VLAN ID.
    pub const RTE_MACVLAN_HASH_MATCH: Type = 4;
}
/// MAC filter info
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_mac_filter {
    ///< 1 for VF, 0 for port dev
    pub is_vf: u8,
    ///< VF ID, available when is_vf is 1
    pub dst_id: u16,
    ///< MAC filter type
    pub filter_type: rte_mac_filter_type::Type,
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_filter>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).is_vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).dst_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(dst_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).filter_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(mac_addr)
        )
    );
}
impl Default for rte_eth_mac_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to define the ethertype filter entry
/// to support RTE_ETH_FILTER_ETHERTYPE with RTE_ETH_FILTER_ADD,
/// RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ethertype_filter {
    ///< Mac address to match.
    pub mac_addr: ether_addr,
    ///< Ether type to match
    pub ether_type: u16,
    ///< Flags from RTE_ETHTYPE_FLAGS_*
    pub flags: u16,
    ///< Queue assigned to when match
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ethertype_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ethertype_filter>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ethertype_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).mac_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).ether_type as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).queue as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(queue)
        )
    );
}
///  A structure used to define the flex filter entry
///  to support RTE_ETH_FILTER_FLEXIBLE with RTE_ETH_FILTER_ADD,
///  RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_flex_filter {
    pub len: u16,
    ///< flex bytes in big endian.
    pub bytes: [u8; 128usize],
    ///< if mask bit is 1b, do
    ///not compare corresponding byte.
    pub mask: [u8; 16usize],
    pub priority: u8,
    ///< Queue assigned to when match.
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_flex_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_filter>(),
        150usize,
        concat!("Size of: ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).mask as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).priority as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).queue as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(queue)
        )
    );
}
impl Default for rte_eth_flex_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to define the TCP syn filter entry
/// to support RTE_ETH_FILTER_SYN with RTE_ETH_FILTER_ADD,
/// RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_syn_filter {
    ///< 1 - higher priority than other filters,
    ///0 - lower priority.
    pub hig_pri: u8,
    ///< Queue assigned to when match
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_syn_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_syn_filter>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_syn_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).hig_pri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(hig_pri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(queue)
        )
    );
}
/// A structure used to define the ntuple filter entry
/// to support RTE_ETH_FILTER_NTUPLE with RTE_ETH_FILTER_ADD,
/// RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ntuple_filter {
    ///< Flags from RTE_NTUPLE_FLAGS_*
    pub flags: u16,
    ///< Destination IP address in big endian.
    pub dst_ip: u32,
    ///< Mask of destination IP address.
    pub dst_ip_mask: u32,
    ///< Source IP address in big endian.
    pub src_ip: u32,
    ///< Mask of destination IP address.
    pub src_ip_mask: u32,
    ///< Destination port in big endian.
    pub dst_port: u16,
    ///< Mask of destination port.
    pub dst_port_mask: u16,
    ///< Source Port in big endian.
    pub src_port: u16,
    ///< Mask of source port.
    pub src_port_mask: u16,
    ///< L4 protocol.
    pub proto: u8,
    ///< Mask of L4 protocol.
    pub proto_mask: u8,
    /// tcp_flags only meaningful when the proto is TCP.
    ///The packet matched above ntuple fields and contain
    ///any set bit in tcp_flags will hit this filter.
    pub tcp_flags: u8,
    ///< seven levels (001b-111b), 111b is highest,
    ///used when more than one filter matches.
    pub priority: u16,
    ///< Queue assigned to when match
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ntuple_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ntuple_filter>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ntuple_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port_mask as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port_mask as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto_mask as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).tcp_flags as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).priority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).queue as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(queue)
        )
    );
}
pub mod rte_eth_tunnel_type {
    /// Tunneled type.
    pub type Type = u32;
    pub const RTE_TUNNEL_TYPE_NONE: Type = 0;
    pub const RTE_TUNNEL_TYPE_VXLAN: Type = 1;
    pub const RTE_TUNNEL_TYPE_GENEVE: Type = 2;
    pub const RTE_TUNNEL_TYPE_TEREDO: Type = 3;
    pub const RTE_TUNNEL_TYPE_NVGRE: Type = 4;
    pub const RTE_TUNNEL_TYPE_IP_IN_GRE: Type = 5;
    pub const RTE_L2_TUNNEL_TYPE_E_TAG: Type = 6;
    pub const RTE_TUNNEL_TYPE_MAX: Type = 7;
}
pub mod rte_tunnel_iptype {
    ///  Select IPv4 or IPv6 for tunnel filters.
    pub type Type = u32;
    ///< IPv4.
    pub const RTE_TUNNEL_IPTYPE_IPV4: Type = 0;
    ///< IPv6.
    pub const RTE_TUNNEL_IPTYPE_IPV6: Type = 1;
}
/// Tunneling Packet filter configuration.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tunnel_filter_conf {
    ///< Outer MAC address to match.
    pub outer_mac: ether_addr,
    ///< Inner MAC address to match.
    pub inner_mac: ether_addr,
    ///< Inner VLAN to match.
    pub inner_vlan: u16,
    ///< IP address type.
    pub ip_type: rte_tunnel_iptype::Type,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    /// Flags from ETH_TUNNEL_FILTER_XX - see above.
    pub filter_type: u16,
    ///< Tunnel Type.
    pub tunnel_type: rte_eth_tunnel_type::Type,
    ///< Tenant ID to match. VNI, GRE key...
    pub tenant_id: u32,
    ///< Queue assigned to if match.
    pub queue_id: u16,
}
/// Outer destination IP address to match if ETH_TUNNEL_FILTER_OIP
///is set in filter_type, or inner destination IP address to match
///if ETH_TUNNEL_FILTER_IIP is set in filter_type .
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    ///< IPv4 address in big endian.
    pub ipv4_addr: u32,
    ///< IPv6 address in big endian.
    pub ipv6_addr: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv4_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv4_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv6_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
impl Default for rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf>(),
        52usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).outer_mac as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(outer_mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_mac as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_vlan as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_vlan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_addr as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).filter_type as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tunnel_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tenant_id as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tenant_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).queue_id as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(queue_id)
        )
    );
}
impl Default for rte_eth_tunnel_filter_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_global_cfg_type {
    /// Global eth device configuration type.
    pub type Type = u32;
    pub const RTE_ETH_GLOBAL_CFG_TYPE_UNKNOWN: Type = 0;
    pub const RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN: Type = 1;
    pub const RTE_ETH_GLOBAL_CFG_TYPE_MAX: Type = 2;
}
/// Global eth device configuration.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_global_cfg {
    ///< Global config type.
    pub cfg_type: rte_eth_global_cfg_type::Type,
    pub cfg: rte_eth_global_cfg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_global_cfg__bindgen_ty_1 {
    ///< Valid GRE key length in byte.
    pub gre_key_len: u8,
    ///< Reserve space for future use.
    pub reserved: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).gre_key_len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(gre_key_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for rte_eth_global_cfg__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg)
        )
    );
}
impl Default for rte_eth_global_cfg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_input_set_field {
    /// Input set fields for Flow Director and Hash filters
    pub type Type = u32;
    pub const RTE_ETH_INPUT_SET_UNKNOWN: Type = 0;
    pub const RTE_ETH_INPUT_SET_L2_SRC_MAC: Type = 1;
    pub const RTE_ETH_INPUT_SET_L2_DST_MAC: Type = 2;
    pub const RTE_ETH_INPUT_SET_L2_OUTER_VLAN: Type = 3;
    pub const RTE_ETH_INPUT_SET_L2_INNER_VLAN: Type = 4;
    pub const RTE_ETH_INPUT_SET_L2_ETHERTYPE: Type = 5;
    pub const RTE_ETH_INPUT_SET_L3_SRC_IP4: Type = 129;
    pub const RTE_ETH_INPUT_SET_L3_DST_IP4: Type = 130;
    pub const RTE_ETH_INPUT_SET_L3_SRC_IP6: Type = 131;
    pub const RTE_ETH_INPUT_SET_L3_DST_IP6: Type = 132;
    pub const RTE_ETH_INPUT_SET_L3_IP4_TOS: Type = 133;
    pub const RTE_ETH_INPUT_SET_L3_IP4_PROTO: Type = 134;
    pub const RTE_ETH_INPUT_SET_L3_IP6_TC: Type = 135;
    pub const RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER: Type = 136;
    pub const RTE_ETH_INPUT_SET_L3_IP4_TTL: Type = 137;
    pub const RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS: Type = 138;
    pub const RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT: Type = 257;
    pub const RTE_ETH_INPUT_SET_L4_UDP_DST_PORT: Type = 258;
    pub const RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT: Type = 259;
    pub const RTE_ETH_INPUT_SET_L4_TCP_DST_PORT: Type = 260;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT: Type = 261;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT: Type = 262;
    pub const RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG: Type = 263;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC: Type = 385;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC: Type = 386;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN: Type = 387;
    pub const RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY: Type = 388;
    pub const RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY: Type = 389;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD: Type = 641;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD: Type = 642;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD: Type = 643;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD: Type = 644;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD: Type = 645;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD: Type = 646;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD: Type = 647;
    pub const RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD: Type = 648;
    pub const RTE_ETH_INPUT_SET_DEFAULT: Type = 65533;
    pub const RTE_ETH_INPUT_SET_NONE: Type = 65534;
    pub const RTE_ETH_INPUT_SET_MAX: Type = 65535;
}
pub mod rte_filter_input_set_op {
    /// Filters input set operations
    pub type Type = u32;
    pub const RTE_ETH_INPUT_SET_OP_UNKNOWN: Type = 0;
    ///< select input set
    pub const RTE_ETH_INPUT_SET_SELECT: Type = 1;
    ///< add input set entry
    pub const RTE_ETH_INPUT_SET_ADD: Type = 2;
    pub const RTE_ETH_INPUT_SET_OP_MAX: Type = 3;
}
/// A structure used to define the input set configuration for
/// flow director and hash filters
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field::Type; 128usize],
    pub op: rte_filter_input_set_op::Type,
}
#[test]
fn bindgen_test_layout_rte_eth_input_set_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_input_set_conf>(),
        520usize,
        concat!("Size of: ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_input_set_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_input_set_conf>())).flow_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_input_set_conf>())).inset_size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(inset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).field as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).op as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(op)
        )
    );
}
impl Default for rte_eth_input_set_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to define the input for L2 flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_l2_flow {
    ///< Ether type in big endian
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Size of: ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_flow>())).ether_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_flow),
            "::",
            stringify!(ether_type)
        )
    );
}
/// A structure used to define the input for IPV4 flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ipv4_flow {
    ///< IPv4 source address in big endian.
    pub src_ip: u32,
    ///< IPv4 destination address in big endian.
    pub dst_ip: u32,
    ///< Type of service to match.
    pub tos: u8,
    ///< Time to live to match.
    pub ttl: u8,
    ///< Protocol, next header in big endian.
    pub proto: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv4_flow>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).tos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).ttl as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).proto as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(proto)
        )
    );
}
/// A structure used to define the input for IPV4 UDP flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udpv4_flow {
    ///< IPv4 fields to match.
    pub ip: rte_eth_ipv4_flow,
    ///< UDP source port in big endian.
    pub src_port: u16,
    ///< UDP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
/// A structure used to define the input for IPV4 TCP flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_tcpv4_flow {
    ///< IPv4 fields to match.
    pub ip: rte_eth_ipv4_flow,
    ///< TCP source port in big endian.
    pub src_port: u16,
    ///< TCP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
/// A structure used to define the input for IPV4 SCTP flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_sctpv4_flow {
    ///< IPv4 fields to match.
    pub ip: rte_eth_ipv4_flow,
    ///< SCTP source port in big endian.
    pub src_port: u16,
    ///< SCTP destination port in big endian.
    pub dst_port: u16,
    ///< Verify tag in big endian
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv4_flow>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).verify_tag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
/// A structure used to define the input for IPV6 flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_ipv6_flow {
    ///< IPv6 source address in big endian.
    pub src_ip: [u32; 4usize],
    ///< IPv6 destination address in big endian.
    pub dst_ip: [u32; 4usize],
    ///< Traffic class to match.
    pub tc: u8,
    ///< Protocol, next header to match.
    pub proto: u8,
    ///< Hop limits to match.
    pub hop_limits: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv6_flow>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).tc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).proto as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).hop_limits as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(hop_limits)
        )
    );
}
/// A structure used to define the input for IPV6 UDP flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udpv6_flow {
    ///< IPv6 fields to match.
    pub ip: rte_eth_ipv6_flow,
    ///< UDP source port in big endian.
    pub src_port: u16,
    ///< UDP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
/// A structure used to define the input for IPV6 TCP flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_tcpv6_flow {
    ///< IPv6 fields to match.
    pub ip: rte_eth_ipv6_flow,
    ///< TCP source port to in big endian.
    pub src_port: u16,
    ///< TCP destination port in big endian.
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
/// A structure used to define the input for IPV6 SCTP flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_sctpv6_flow {
    ///< IPv6 fields to match.
    pub ip: rte_eth_ipv6_flow,
    ///< SCTP source port in big endian.
    pub src_port: u16,
    ///< SCTP destination port in big endian.
    pub dst_port: u16,
    ///< Verify tag in big endian.
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv6_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).verify_tag as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
/// A structure used to define the input for MAC VLAN flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_mac_vlan_flow {
    ///< Mac address to match.
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_vlan_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_vlan_flow>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_vlan_flow>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_vlan_flow>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_vlan_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
pub mod rte_eth_fdir_tunnel_type {
    /// Tunnel type for flow director.
    pub type Type = u32;
    pub const RTE_FDIR_TUNNEL_TYPE_UNKNOWN: Type = 0;
    pub const RTE_FDIR_TUNNEL_TYPE_NVGRE: Type = 1;
    pub const RTE_FDIR_TUNNEL_TYPE_VXLAN: Type = 2;
}
/// A structure used to define the input for tunnel flow, now it's VxLAN or
/// NVGRE
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_tunnel_flow {
    ///< Tunnel type to match.
    pub tunnel_type: rte_eth_fdir_tunnel_type::Type,
    /// Tunnel ID to match. TNI, VNI... in big endian.
    pub tunnel_id: u32,
    ///< Mac address to match.
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
impl Default for rte_eth_tunnel_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// An union contains the inputs for all types of flow
/// Items in flows need to be in big endian
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_flow {
    pub l2_flow: rte_eth_l2_flow,
    pub udp4_flow: rte_eth_udpv4_flow,
    pub tcp4_flow: rte_eth_tcpv4_flow,
    pub sctp4_flow: rte_eth_sctpv4_flow,
    pub ip4_flow: rte_eth_ipv4_flow,
    pub udp6_flow: rte_eth_udpv6_flow,
    pub tcp6_flow: rte_eth_tcpv6_flow,
    pub sctp6_flow: rte_eth_sctpv6_flow,
    pub ipv6_flow: rte_eth_ipv6_flow,
    pub mac_vlan_flow: rte_eth_mac_vlan_flow,
    pub tunnel_flow: rte_eth_tunnel_flow,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).l2_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(l2_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ip4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ip4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ipv6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ipv6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).mac_vlan_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(mac_vlan_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tunnel_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tunnel_flow)
        )
    );
}
impl Default for rte_eth_fdir_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to contain extend input of flow
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    ///< 1 for VF, 0 for port dev
    pub is_vf: u8,
    ///< VF ID, available when is_vf is 1
    pub dst_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow_ext>(),
        22usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow_ext>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).flexbytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(flexbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).is_vf as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).dst_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(dst_id)
        )
    );
}
/// A structure used to define the input for a flow director filter entry
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_input() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_input>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_input>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_ext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_ext)
        )
    );
}
impl Default for rte_eth_fdir_input {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_fdir_behavior {
    /// Behavior will be taken if FDIR match
    pub type Type = u32;
    pub const RTE_ETH_FDIR_ACCEPT: Type = 0;
    pub const RTE_ETH_FDIR_REJECT: Type = 1;
    pub const RTE_ETH_FDIR_PASSTHRU: Type = 2;
}
pub mod rte_eth_fdir_status {
    /// Flow director report status
    /// It defines what will be reported if FDIR entry is matched.
    pub type Type = u32;
    ///< Report nothing.
    pub const RTE_ETH_FDIR_NO_REPORT_STATUS: Type = 0;
    ///< Only report FD ID.
    pub const RTE_ETH_FDIR_REPORT_ID: Type = 1;
    ///< Report FD ID and 4 flex bytes.
    pub const RTE_ETH_FDIR_REPORT_ID_FLEX_4: Type = 2;
    ///< Report 8 flex bytes.
    pub const RTE_ETH_FDIR_REPORT_FLEX_8: Type = 3;
}
/// A structure used to define an action when match FDIR packet filter.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_action {
    ///< Queue assigned to if FDIR match.
    pub rx_queue: u16,
    ///< Behavior will be taken
    pub behavior: rte_eth_fdir_behavior::Type,
    ///< Status report option
    pub report_status: rte_eth_fdir_status::Type,
    pub flex_off: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_action() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_action>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_action>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).rx_queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(rx_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).behavior as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_action>())).report_status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(report_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).flex_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(flex_off)
        )
    );
}
impl Default for rte_eth_fdir_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to define the flow director filter entry by filter_ctrl API
/// It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_ADD and
/// RTE_ETH_FILTER_DELETE operations.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    ///< Input set
    pub input: rte_eth_fdir_input,
    ///< Action taken when match
    pub action: rte_eth_fdir_action,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter>(),
        92usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).soft_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(soft_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).input as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).action as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(action)
        )
    );
}
impl Default for rte_eth_fdir_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///  A structure used to configure FDIR masks that are used by the device
///  to match the various fields of RX packet headers.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_masks {
    ///< Bit mask for vlan_tci in big endian
    pub vlan_tci_mask: u16,
    /// Bit mask for ipv4 flow in big endian.
    pub ipv4_mask: rte_eth_ipv4_flow,
    /// Bit maks for ipv6 flow in big endian.
    pub ipv6_mask: rte_eth_ipv6_flow,
    /// Bit mask for L4 source port in big endian.
    pub src_port_mask: u16,
    /// Bit mask for L4 destination port in big endian.
    pub dst_port_mask: u16,
    /// 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the
    ///first byte on the wire
    pub mac_addr_byte_mask: u8,
    /// Bit mask for tunnel ID in big endian.
    pub tunnel_id_mask: u32,
    ///< 1 - Match tunnel type,
    ///0 - Ignore tunnel type.
    pub tunnel_type_mask: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_masks() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_masks>(),
        68usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_masks>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).vlan_tci_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(vlan_tci_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv4_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv4_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv6_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv6_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).src_port_mask as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).dst_port_mask as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).mac_addr_byte_mask as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(mac_addr_byte_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_id_mask as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_id_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_type_mask as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_type_mask)
        )
    );
}
pub mod rte_eth_payload_type {
    /// Payload type
    pub type Type = u32;
    pub const RTE_ETH_PAYLOAD_UNKNOWN: Type = 0;
    pub const RTE_ETH_RAW_PAYLOAD: Type = 1;
    pub const RTE_ETH_L2_PAYLOAD: Type = 2;
    pub const RTE_ETH_L3_PAYLOAD: Type = 3;
    pub const RTE_ETH_L4_PAYLOAD: Type = 4;
    pub const RTE_ETH_PAYLOAD_MAX: Type = 8;
}
/// A structure used to select bytes extracted from the protocol layers to
/// flexible payload for filter
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_flex_payload_cfg {
    ///< Payload type
    pub type_: rte_eth_payload_type::Type,
    pub src_offset: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_flex_payload_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_payload_cfg>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_payload_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).src_offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(src_offset)
        )
    );
}
impl Default for rte_eth_flex_payload_cfg {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to define FDIR masks for flexible payload
/// for each flow type
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_mask() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_mask>(),
        18usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_mask>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).flow_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).mask as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(mask)
        )
    );
}
/// A structure used to define all flexible payload related setting
/// include flex payload and flex mask
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_flex_conf {
    ///< The number of following payload cfg
    pub nb_payloads: u16,
    ///< The number of following mask
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 23usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_conf>(),
        708usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_payloads as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_payloads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_flexmasks as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_flexmasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_set as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_mask as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_mask)
        )
    );
}
impl Default for rte_eth_fdir_flex_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_fdir_mode {
    ///  Flow Director setting modes: none, signature or perfect.
    pub type Type = u32;
    ///< Disable FDIR support.
    pub const RTE_FDIR_MODE_NONE: Type = 0;
    ///< Enable FDIR signature filter mode.
    pub const RTE_FDIR_MODE_SIGNATURE: Type = 1;
    ///< Enable FDIR perfect filter mode.
    pub const RTE_FDIR_MODE_PERFECT: Type = 2;
    ///< Enable FDIR filter mode - MAC VLAN.
    pub const RTE_FDIR_MODE_PERFECT_MAC_VLAN: Type = 3;
    ///< Enable FDIR filter mode - tunnel.
    pub const RTE_FDIR_MODE_PERFECT_TUNNEL: Type = 4;
}
/// A structure used to get the information of flow director filter.
/// It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation.
/// It includes the mode, flexible payload configuration information,
/// capabilities and supported flow types, flexible payload characters.
/// It can be gotten to help taking specific configurations per device.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_info {
    ///< Flow director mode
    pub mode: rte_fdir_mode::Type,
    pub mask: rte_eth_fdir_masks,
    /// Flex payload configuration information
    pub flex_conf: rte_eth_fdir_flex_conf,
    ///< Guaranteed spaces.
    pub guarant_spc: u32,
    ///< Best effort spaces.
    pub best_spc: u32,
    /// Bit mask for every supported flow type.
    pub flow_types_mask: [u64; 1usize],
    ///< Total flex payload in bytes.
    pub max_flexpayload: u32,
    /// Flexible payload unit in bytes. Size and alignments of all flex
    ///payload segments should be multiplies of this value.
    pub flex_payload_unit: u32,
    /// Max number of flexible payload continuous segments.
    ///Each segment should be a multiple of flex_payload_unit.
    pub max_flex_payload_segment_num: u32,
    /// Maximum src_offset in bytes allowed. It indicates that
    ///src_offset[i] in struct rte_eth_flex_payload_cfg should be less
    ///than this value.
    pub flex_payload_limit: u16,
    /// Flex bitmask unit in bytes. Size of flex bitmasks should be a
    ///multiply of this value.
    pub flex_bitmask_unit: u32,
    /// Max supported size of flex bitmasks in flex_bitmask_unit
    pub max_flex_bitmask_num: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_info>(),
        824usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_conf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).guarant_spc as *const _ as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(guarant_spc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).best_spc as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(best_spc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flow_types_mask as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flow_types_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flexpayload as *const _ as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flexpayload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_unit as *const _ as usize
        },
        804usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_payload_segment_num as *const _
                as usize
        },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_payload_segment_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_limit as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_bitmask_unit as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_bitmask_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_bitmask_num as *const _ as usize
        },
        820usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_bitmask_num)
        )
    );
}
impl Default for rte_eth_fdir_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to define the statistics of flow director.
/// It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_fdir_stats {
    ///< Number of filters with collision.
    pub collision: u32,
    ///< Number of free filters.
    pub free: u32,
    pub maxhash: u32,
    ///< Longest linked list of filters.
    pub maxlen: u32,
    ///< Number of added filters.
    pub add: u64,
    ///< Number of removed filters.
    pub remove: u64,
    ///< Number of failed added filters.
    pub f_add: u64,
    ///< Number of failed removed filters.
    pub f_remove: u64,
    ///< Number of filters in guaranteed spaces.
    pub guarant_cnt: u32,
    ///< Number of filters in best effort spaces.
    pub best_cnt: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_stats>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).collision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(collision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).free as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxhash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).add as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).remove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_add as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_remove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).guarant_cnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(guarant_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).best_cnt as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(best_cnt)
        )
    );
}
pub mod rte_eth_fdir_filter_info_type {
    /// Flow Director filter information types.
    pub type Type = u32;
    pub const RTE_ETH_FDIR_FILTER_INFO_TYPE_UNKNOWN: Type = 0;
    /// Flow Director filter input set configuration
    pub const RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT: Type = 1;
    /// Flow Director filter input set configuration
    pub const RTE_ETH_FDIR_FILTER_INFO_TYPE_MAX: Type = 2;
}
/// A structure used to set FDIR filter information, to support filter type
/// of 'RTE_ETH_FILTER_FDIR' RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT operation.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter_info {
    ///< Information type
    pub info_type: rte_eth_fdir_filter_info_type::Type,
    pub info: rte_eth_fdir_filter_info__bindgen_ty_1,
}
/// Details of fdir filter information
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_filter_info__bindgen_ty_1 {
    /// Flow Director input set configuration per port
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        520usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_filter_info__bindgen_ty_1>())).input_set_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
impl Default for rte_eth_fdir_filter_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info>(),
        524usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info)
        )
    );
}
impl Default for rte_eth_fdir_filter_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_hash_filter_info_type {
    /// Hash filter information types.
    /// - RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT is for getting/setting the
    ///   information/configuration of 'symmetric hash enable' per port.
    /// - RTE_ETH_HASH_FILTER_GLOBAL_CONFIG is for getting/setting the global
    ///   configurations of hash filters. Those global configurations are valid
    ///   for all ports of the same NIC.
    /// - RTE_ETH_HASH_FILTER_INPUT_SET_SELECT is for setting the global
    ///   hash input set fields
    pub type Type = u32;
    pub const RTE_ETH_HASH_FILTER_INFO_TYPE_UNKNOWN: Type = 0;
    /// Symmetric hash enable per port
    pub const RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT: Type = 1;
    /// Configure globally for hash filter
    pub const RTE_ETH_HASH_FILTER_GLOBAL_CONFIG: Type = 2;
    /// Global Hash filter input set configuration
    pub const RTE_ETH_HASH_FILTER_INPUT_SET_SELECT: Type = 3;
    /// Global Hash filter input set configuration
    pub const RTE_ETH_HASH_FILTER_INFO_TYPE_MAX: Type = 4;
}
pub mod rte_eth_hash_function {
    /// Hash function types.
    pub type Type = u32;
    pub const RTE_ETH_HASH_FUNCTION_DEFAULT: Type = 0;
    ///< Toeplitz
    pub const RTE_ETH_HASH_FUNCTION_TOEPLITZ: Type = 1;
    ///< Simple XOR
    pub const RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: Type = 2;
    pub const RTE_ETH_HASH_FUNCTION_MAX: Type = 3;
}
/// A structure used to set or get global hash function configurations which
/// include symmetric hash enable per flow type and hash function type.
/// Each bit in sym_hash_enable_mask[] indicates if the symmetric hash of the
/// corresponding flow type is enabled or not.
/// Each bit in valid_bit_mask[] indicates if the corresponding bit in
/// sym_hash_enable_mask[] is valid or not. For the configurations gotten, it
/// also means if the flow type is supported by hardware or not.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_hash_global_conf {
    ///< Hash function type
    pub hash_func: rte_eth_hash_function::Type,
    /// Bit mask for symmetric hash enable per flow type
    pub sym_hash_enable_mask: [u64; 1usize],
    /// Bit mask indicates if the corresponding bit is valid
    pub valid_bit_mask: [u64; 1usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_global_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_global_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_global_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).hash_func as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(hash_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).sym_hash_enable_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(sym_hash_enable_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).valid_bit_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(valid_bit_mask)
        )
    );
}
impl Default for rte_eth_hash_global_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to set or get hash filter information, to support filter
/// type of 'RTE_ETH_FILTER_HASH' and its operations.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hash_filter_info {
    ///< Information type
    pub info_type: rte_eth_hash_filter_info_type::Type,
    pub info: rte_eth_hash_filter_info__bindgen_ty_1,
}
/// Details of hash filter information
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_hash_filter_info__bindgen_ty_1 {
    /// For RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT
    pub enable: u8,
    /// Global configurations of hash filter
    pub global_conf: rte_eth_hash_global_conf,
    /// Global configurations of hash filter input set
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u64; 65usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        520usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).enable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).global_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(global_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).input_set_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
impl Default for rte_eth_hash_filter_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info>(),
        528usize,
        concat!("Size of: ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info)
        )
    );
}
impl Default for rte_eth_hash_filter_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// l2 tunnel configuration.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_l2_tunnel_conf {
    pub l2_tunnel_type: rte_eth_tunnel_type::Type,
    pub ether_type: u16,
    pub tunnel_id: u32,
    pub vf_id: u16,
    pub pool: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_tunnel_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_tunnel_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_tunnel_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).l2_tunnel_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(l2_tunnel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).ether_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).tunnel_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).vf_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(vf_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(pool)
        )
    );
}
impl Default for rte_eth_l2_tunnel_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_reg_info {
    ///< Buffer for return registers
    pub data: *mut ::std::os::raw::c_void,
    ///< Start register table location for access
    pub offset: u32,
    ///< Number of registers to fetch
    pub length: u32,
    ///< Size of device register
    pub width: u32,
    ///< Device version
    pub version: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_reg_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_reg_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_reg_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(version)
        )
    );
}
impl Default for rte_dev_reg_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_dev_eeprom_info {
    ///< Buffer for return eeprom
    pub data: *mut ::std::os::raw::c_void,
    ///< Start eeprom address for access
    pub offset: u32,
    ///< Length of eeprom region to access
    pub length: u32,
    ///< Device-specific key, such as device-id
    pub magic: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_eeprom_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_eeprom_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_eeprom_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).magic as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for rte_dev_eeprom_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Placeholder for accessing plugin module eeprom
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_module_info {
    ///< Type of plugin module eeprom
    pub type_: u32,
    ///< Length of plugin module eeprom
    pub eeprom_len: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_module_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_module_info>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_dev_module_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_module_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_module_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_module_info>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_module_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_module_info>())).eeprom_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_module_info),
            "::",
            stringify!(eeprom_len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}rte_eth_dev_logtype"]
    pub static mut rte_eth_dev_logtype: ::std::os::raw::c_int;
}
extern "C" {
    /// Initializes a device iterator.
    ///
    /// This iterator allows accessing a list of devices matching some devargs.
    ///
    /// @param iter
    ///   Device iterator handle initialized by the function.
    ///   The fields bus_str and cls_str might be dynamically allocated,
    ///   and could be freed by calling rte_eth_iterator_cleanup().
    ///
    /// @param devargs
    ///   Device description string.
    ///
    /// @return
    ///   0 on successful initialization, negative otherwise.
    pub fn rte_eth_iterator_init(
        iter: *mut rte_dev_iterator,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Iterates on devices with devargs filter.
    /// The ownership is not checked.
    ///
    /// The next port id is returned, and the iterator is updated.
    ///
    /// @param iter
    ///   Device iterator handle initialized by rte_eth_iterator_init().
    ///   Some fields bus_str and cls_str might be freed when no more port is found,
    ///   by calling rte_eth_iterator_cleanup().
    ///
    /// @return
    ///   A port id if found, RTE_MAX_ETHPORTS otherwise.
    pub fn rte_eth_iterator_next(iter: *mut rte_dev_iterator) -> u16;
}
extern "C" {
    /// Free some allocated fields of the iterator.
    ///
    /// This function is automatically called by rte_eth_iterator_next()
    /// on the last iteration (i.e. when no more matching port is found).
    ///
    /// It is safe to call this function twice; it will do nothing more.
    ///
    /// @param iter
    ///   Device iterator handle initialized by rte_eth_iterator_init().
    ///   The fields bus_str and cls_str are freed if needed.
    pub fn rte_eth_iterator_cleanup(iter: *mut rte_dev_iterator);
}
/// A structure used to retrieve statistics for an Ethernet port.
/// Not all statistics fields in struct rte_eth_stats are supported
/// by any type of network interface card (NIC). If any statistics
/// field is not supported, its value is 0.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_stats {
    ///< Total number of successfully received packets.
    pub ipackets: u64,
    ///< Total number of successfully transmitted packets.
    pub opackets: u64,
    ///< Total number of successfully received bytes.
    pub ibytes: u64,
    ///< Total number of successfully transmitted bytes.
    pub obytes: u64,
    pub imissed: u64,
    ///< Total number of erroneous received packets.
    pub ierrors: u64,
    ///< Total number of failed transmitted packets.
    pub oerrors: u64,
    ///< Total number of RX mbuf allocation failures.
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_stats>(),
        704usize,
        concat!("Size of: ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ipackets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).opackets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ibytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).obytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).imissed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(imissed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ierrors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ierrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).oerrors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(oerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).rx_nombuf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(rx_nombuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ipackets as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_opackets as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ibytes as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_obytes as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_errors as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_errors)
        )
    );
}
/// A structure used to retrieve link-level information of an Ethernet port.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_link {
    ///< ETH_SPEED_NUM_
    pub link_speed: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_link>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_link))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_link>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_link))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_link>())).link_speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_link),
            "::",
            stringify!(link_speed)
        )
    );
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
/// A structure used to configure the ring threshold registers of an RX/TX
/// queue for an Ethernet port.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_thresh {
    ///< Ring prefetch threshold.
    pub pthresh: u8,
    ///< Ring host threshold.
    pub hthresh: u8,
    ///< Ring writeback threshold.
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_thresh>(),
        3usize,
        concat!("Size of: ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_thresh>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).pthresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(pthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).hthresh as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(hthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).wthresh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(wthresh)
        )
    );
}
pub mod rte_eth_rx_mq_mode {
    ///  A set of values to identify what method is to be used to route
    ///  packets to multiple queues.
    pub type Type = u32;
    /// None of DCB,RSS or VMDQ mode
    pub const ETH_MQ_RX_NONE: Type = 0;
    /// For RX side, only RSS is on
    pub const ETH_MQ_RX_RSS: Type = 1;
    /// For RX side,only DCB is on.
    pub const ETH_MQ_RX_DCB: Type = 2;
    /// Both DCB and RSS enable
    pub const ETH_MQ_RX_DCB_RSS: Type = 3;
    /// Only VMDQ, no RSS nor DCB
    pub const ETH_MQ_RX_VMDQ_ONLY: Type = 4;
    /// RSS mode with VMDQ
    pub const ETH_MQ_RX_VMDQ_RSS: Type = 5;
    /// Use VMDQ+DCB to route traffic to queues
    pub const ETH_MQ_RX_VMDQ_DCB: Type = 6;
    /// Enable both VMDQ and DCB in VMDq
    pub const ETH_MQ_RX_VMDQ_DCB_RSS: Type = 7;
}
pub mod rte_eth_tx_mq_mode {
    /// A set of values to identify what method is to be used to transmit
    /// packets using multi-TCs.
    pub type Type = u32;
    ///< It is in neither DCB nor VT mode.
    pub const ETH_MQ_TX_NONE: Type = 0;
    ///< For TX side,only DCB is on.
    pub const ETH_MQ_TX_DCB: Type = 1;
    ///< For TX side,both DCB and VT is on.
    pub const ETH_MQ_TX_VMDQ_DCB: Type = 2;
    ///< Only VT on, no DCB
    pub const ETH_MQ_TX_VMDQ_ONLY: Type = 3;
}
/// A structure used to configure the RX features of an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rxmode {
    /// The multi-queue packet distribution mode to be used, e.g. RSS.
    pub mq_mode: rte_eth_rx_mq_mode::Type,
    ///< Only used if JUMBO_FRAME enabled.
    pub max_rx_pkt_len: u32,
    ///< hdr buf size (header_split enabled).
    pub split_hdr_size: u16,
    /// Per-port Rx offloads to be set using DEV_RX_OFFLOAD_* flags.
    /// Only offloads set on rx_offload_capa field on rte_eth_dev_info
    /// structure are allowed to be set.
    pub offloads: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxmode>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).max_rx_pkt_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_rx_pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).split_hdr_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(split_hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(offloads)
        )
    );
}
impl Default for rte_eth_rxmode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_vlan_type {
    /// VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN.
    /// Note that single VLAN is treated the same as inner VLAN.
    pub type Type = u32;
    pub const ETH_VLAN_TYPE_UNKNOWN: Type = 0;
    ///< Inner VLAN.
    pub const ETH_VLAN_TYPE_INNER: Type = 1;
    ///< Single VLAN, or outer VLAN.
    pub const ETH_VLAN_TYPE_OUTER: Type = 2;
    pub const ETH_VLAN_TYPE_MAX: Type = 3;
}
/// A structure used to describe a vlan filter.
/// If the bit corresponding to a VID is set, such VID is on.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[test]
fn bindgen_test_layout_rte_vlan_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_vlan_filter_conf>(),
        512usize,
        concat!("Size of: ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vlan_filter_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_filter_conf>())).ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_filter_conf),
            "::",
            stringify!(ids)
        )
    );
}
impl Default for rte_vlan_filter_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure the Receive Side Scaling (RSS) feature
/// of an Ethernet port.
/// If not NULL, the *rss_key* pointer of the *rss_conf* structure points
/// to an array holding the RSS key to use for hashing specific header
/// fields of received packets. The length of this array should be indicated
/// by *rss_key_len* below. Otherwise, a default random hash key is used by
/// the device driver.
///
/// The *rss_key_len* field of the *rss_conf* structure indicates the length
/// in bytes of the array pointed by *rss_key*. To be compatible, this length
/// will be checked in i40e only. Others assume 40 bytes to be used as before.
///
/// The *rss_hf* field of the *rss_conf* structure indicates the different
/// types of IPv4/IPv6 packets to which the RSS hashing must be applied.
/// Supplying an *rss_hf* equal to zero disables the RSS feature.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_rss_conf {
    ///< If not NULL, 40-byte hash key.
    pub rss_key: *mut u8,
    ///< hash key length in bytes.
    pub rss_key_len: u8,
    ///< Hash functions to apply - see below.
    pub rss_hf: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_hf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_hf)
        )
    );
}
impl Default for rte_eth_rss_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure VLAN traffic mirror of an Ethernet port.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vlan_mirror {
    ///< mask for valid VLAN ID.
    pub vlan_mask: u64,
    /// VLAN ID list for vlan mirroring.
    pub vlan_id: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vlan_mirror() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vlan_mirror>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vlan_mirror>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_id)
        )
    );
}
impl Default for rte_eth_vlan_mirror {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure traffic mirror of an Ethernet port.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_mirror_conf {
    ///< Mirroring rule type
    pub rule_type: u8,
    ///< Destination pool for this mirror rule.
    pub dst_pool: u8,
    ///< Bitmap of pool for pool mirroring
    pub pool_mask: u64,
    /// VLAN ID setting for VLAN mirroring.
    pub vlan: rte_eth_vlan_mirror,
}
#[test]
fn bindgen_test_layout_rte_eth_mirror_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mirror_conf>(),
        152usize,
        concat!("Size of: ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mirror_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).rule_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(rule_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).dst_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(dst_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).pool_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(pool_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).vlan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(vlan)
        )
    );
}
impl Default for rte_eth_mirror_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure 64 entries of Redirection Table of the
/// Receive Side Scaling (RSS) feature of an Ethernet port. To configure
/// more than 64 entries supported by hardware, an array of this structure
/// is needed.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rss_reta_entry64() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_reta_entry64>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_reta_entry64>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).reta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(reta)
        )
    );
}
impl Default for rte_eth_rss_reta_entry64 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_nb_tcs {
    /// This enum indicates the possible number of traffic classes
    /// in DCB configurations
    pub type Type = u32;
    ///< 4 TCs with DCB.
    pub const ETH_4_TCS: Type = 4;
    ///< 8 TCs with DCB.
    pub const ETH_8_TCS: Type = 8;
}
pub mod rte_eth_nb_pools {
    /// This enum indicates the possible number of queue pools
    /// in VMDQ configurations.
    pub type Type = u32;
    ///< 8 VMDq pools.
    pub const ETH_8_POOLS: Type = 8;
    ///< 16 VMDq pools.
    pub const ETH_16_POOLS: Type = 16;
    ///< 32 VMDq pools.
    pub const ETH_32_POOLS: Type = 32;
    ///< 64 VMDq pools.
    pub const ETH_64_POOLS: Type = 64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_rx_conf {
    ///< Possible DCB TCs, 4 or 8 TCs
    pub nb_tcs: rte_eth_nb_tcs::Type,
    /// Traffic class each UP mapped to.
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_rx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_rx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_dcb_rx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    ///< With DCB, 16 or 32 pools.
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    /// Traffic class each UP mapped to.
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_vmdq_dcb_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tx_conf {
    ///< Possible DCB TCs, 4 or 8 TCs.
    pub nb_tcs: rte_eth_nb_tcs::Type,
    /// Traffic class each UP mapped to.
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_dcb_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_tx_conf {
    ///< VMDq mode, 64 pools.
    pub nb_queue_pools: rte_eth_nb_pools::Type,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_tx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
}
impl Default for rte_eth_vmdq_tx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure the VMDQ+DCB feature
/// of an Ethernet port.
///
/// Using this feature, packets are routed to a pool of queues, based
/// on the vlan id in the vlan tag, and then to a specific queue within
/// that pool, using the user priority vlan tag field.
///
/// A default pool may be used, if desired, to route all traffic which
/// does not match the vlan filter rules.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    ///< With DCB, 16 or 32 pools
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    ///< If non-zero, use a default pool
    pub enable_default_pool: u8,
    ///< The default pool, if applicable
    pub default_pool: u8,
    ///< We can have up to 64 filters/mappings
    pub nb_pool_maps: u8,
    ///< VMDq vlan pool maps.
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    ///< The vlan id of the received frame
    pub vlan_id: u16,
    ///< Bitmask of pools for packet rx
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).vlan_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).pools as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).enable_default_pool as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).default_pool as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_pool_maps as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).pool_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(pool_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).dcb_tc as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
impl Default for rte_eth_vmdq_dcb_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure the VMDQ feature of an Ethernet port when
/// not combined with the DCB feature.
///
/// Using this feature, packets are routed to a pool of queues. By default,
/// the pool selection is based on the MAC address, the vlan id in the
/// vlan tag as specified in the pool_map array.
/// Passing the ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool
/// selection using only the MAC address. MAC address to pool mapping is done
/// using the rte_eth_dev_mac_addr_add function, with the pool parameter
/// corresponding to the pool id.
///
/// Queue selection within the selected pool will be done using RSS when
/// it is enabled or revert to the first queue of the pool if not.
///
/// A default pool may be used, if desired, to route all traffic which
/// does not match the vlan filter rules or any pool MAC address.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    ///< VMDq only mode, 8 or 64 pools
    pub nb_queue_pools: rte_eth_nb_pools::Type,
    ///< If non-zero, use a default pool
    pub enable_default_pool: u8,
    ///< The default pool, if applicable
    pub default_pool: u8,
    ///< Enable VT loop back
    pub enable_loop_back: u8,
    ///< We can have up to 64 filters/mappings
    pub nb_pool_maps: u8,
    ///< Flags from ETH_VMDQ_ACCEPT_*
    pub rx_mode: u32,
    ///< VMDq vlan pool maps.
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    ///< The vlan id of the received frame
    pub vlan_id: u16,
    ///< Bitmask of pools for packet rx
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).vlan_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).pools as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_default_pool as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).default_pool as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_loop_back as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_loop_back)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_pool_maps as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).rx_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(rx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).pool_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(pool_map)
        )
    );
}
impl Default for rte_eth_vmdq_rx_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure the TX features of an Ethernet port.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_txmode {
    ///< TX multi-queues mode.
    pub mq_mode: rte_eth_tx_mq_mode::Type,
    /// Per-port Tx offloads to be set using DEV_TX_OFFLOAD_* flags.
    /// Only offloads set on tx_offload_capa field on rte_eth_dev_info
    /// structure are allowed to be set.
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txmode>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).offloads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).pvid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(pvid)
        )
    );
}
impl Default for rte_eth_txmode {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
/// A structure used to configure an RX ring of an Ethernet port.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_rxconf {
    ///< RX ring threshold registers.
    pub rx_thresh: rte_eth_thresh,
    ///< Drives the freeing of RX descriptors.
    pub rx_free_thresh: u16,
    ///< Drop packets if no descriptors are available.
    pub rx_drop_en: u8,
    ///< Do not start queue with rte_eth_dev_start().
    pub rx_deferred_start: u8,
    /// Per-queue Rx offloads to be set using DEV_RX_OFFLOAD_* flags.
    /// Only offloads set on rx_queue_offload_capa or rx_offload_capa
    /// fields on rte_eth_dev_info structure are allowed to be set.
    pub offloads: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxconf>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_free_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_drop_en as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_drop_en)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_deferred_start as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).offloads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(offloads)
        )
    );
}
/// A structure used to configure a TX ring of an Ethernet port.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_txconf {
    ///< TX ring threshold registers.
    pub tx_thresh: rte_eth_thresh,
    ///< Drives the setting of RS bit on TXDs.
    pub tx_rs_thresh: u16,
    ///< Start freeing TX buffers if there are
    ///less free descriptors than this value.
    pub tx_free_thresh: u16,
    ///< Do not start queue with rte_eth_dev_start().
    pub tx_deferred_start: u8,
    /// Per-queue Tx offloads to be set  using DEV_TX_OFFLOAD_* flags.
    /// Only offloads set on tx_queue_offload_capa or tx_offload_capa
    /// fields on rte_eth_dev_info structure are allowed to be set.
    pub offloads: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txconf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_rs_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_rs_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_free_thresh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_free_thresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_txconf>())).tx_deferred_start as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).offloads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(offloads)
        )
    );
}
/// A structure contains information about HW descriptor ring limitations.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_desc_lim {
    ///< Max allowed number of descriptors.
    pub nb_max: u16,
    ///< Min allowed number of descriptors.
    pub nb_min: u16,
    ///< Number of descriptors should be aligned to.
    pub nb_align: u16,
    /// Max allowed number of segments per whole packet.
    ///
    /// - For TSO packet this is the total number of data descriptors allowed
    ///   by device.
    ///
    /// @see nb_mtu_seg_max
    pub nb_seg_max: u16,
    /// Max number of segments per one MTU.
    ///
    /// - For non-TSO packet, this is the maximum allowed number of segments
    ///   in a single transmit packet.
    ///
    /// - For TSO packet each segment within the TSO may span up to this
    ///   value.
    ///
    /// @see nb_seg_max
    pub nb_mtu_seg_max: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_desc_lim>(),
        10usize,
        concat!("Size of: ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_desc_lim>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_min as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_seg_max as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_seg_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_mtu_seg_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_mtu_seg_max)
        )
    );
}
pub mod rte_eth_fc_mode {
    /// This enum indicates the flow control mode
    pub type Type = u32;
    ///< Disable flow control.
    pub const RTE_FC_NONE: Type = 0;
    ///< RX pause frame, enable flowctrl on TX side.
    pub const RTE_FC_RX_PAUSE: Type = 1;
    ///< TX pause frame, enable flowctrl on RX side.
    pub const RTE_FC_TX_PAUSE: Type = 2;
    ///< Enable flow control on both side.
    pub const RTE_FC_FULL: Type = 3;
}
/// A structure used to configure Ethernet flow control parameter.
/// These parameters will be configured into the register of the NIC.
/// Please refer to the corresponding data sheet for proper value.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_fc_conf {
    ///< High threshold value to trigger XOFF
    pub high_water: u32,
    ///< Low threshold value to trigger XON
    pub low_water: u32,
    ///< Pause quota in the Pause frame
    pub pause_time: u16,
    ///< Is XON frame need be sent
    pub send_xon: u16,
    ///< Link flow control mode
    pub mode: rte_eth_fc_mode::Type,
    ///< Forward MAC control frames
    pub mac_ctrl_frame_fwd: u8,
    ///< Use Pause autoneg
    pub autoneg: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fc_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).high_water as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(high_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).low_water as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(low_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).pause_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(pause_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).send_xon as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(send_xon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).mode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fc_conf>())).mac_ctrl_frame_fwd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mac_ctrl_frame_fwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).autoneg as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(autoneg)
        )
    );
}
impl Default for rte_eth_fc_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to configure Ethernet priority flow control parameter.
/// These parameters will be configured into the register of the NIC.
/// Please refer to the corresponding data sheet for proper value.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_pfc_conf {
    ///< General flow control parameter.
    pub fc: rte_eth_fc_conf,
    ///< VLAN User Priority.
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_pfc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_pfc_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_pfc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).fc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(priority)
        )
    );
}
impl Default for rte_eth_pfc_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_fdir_pballoc_type {
    ///  Memory space that can be configured to store Flow Director filters
    ///  in the board memory.
    pub type Type = u32;
    ///< 64k.
    pub const RTE_FDIR_PBALLOC_64K: Type = 0;
    ///< 128k.
    pub const RTE_FDIR_PBALLOC_128K: Type = 1;
    ///< 256k.
    pub const RTE_FDIR_PBALLOC_256K: Type = 2;
}
pub mod rte_fdir_status_mode {
    ///  Select report mode of FDIR hash information in RX descriptors.
    pub type Type = u32;
    ///< Never report FDIR hash.
    pub const RTE_FDIR_NO_REPORT_STATUS: Type = 0;
    ///< Only report FDIR hash for matching pkts.
    pub const RTE_FDIR_REPORT_STATUS: Type = 1;
    ///< Always report FDIR hash.
    pub const RTE_FDIR_REPORT_STATUS_ALWAYS: Type = 2;
}
/// A structure used to configure the Flow Director (FDIR) feature
/// of an Ethernet port.
///
/// If mode is RTE_FDIR_DISABLE, the pballoc value is ignored.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_fdir_conf {
    ///< Flow Director mode.
    pub mode: rte_fdir_mode::Type,
    ///< Space for FDIR filters.
    pub pballoc: rte_fdir_pballoc_type::Type,
    ///< How to report FDIR hash.
    pub status: rte_fdir_status_mode::Type,
    /// RX queue of packets matching a "drop" filter in perfect mode.
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[test]
fn bindgen_test_layout_rte_fdir_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_fdir_conf>(),
        792usize,
        concat!("Size of: ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fdir_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).pballoc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(pballoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).drop_queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(drop_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).flex_conf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(flex_conf)
        )
    );
}
impl Default for rte_fdir_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// UDP tunneling configuration.
/// Used to config the UDP port for a type of tunnel.
/// NICs need the UDP port to identify the tunnel type.
/// Normally a type of tunnel has a default UDP port, this structure can be used
/// in case if the users want to change or support more UDP port.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_udp_tunnel {
    ///< UDP port used for the tunnel.
    pub udp_port: u16,
    ///< Tunnel type. Defined in rte_eth_tunnel_type.
    pub prot_type: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_udp_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udp_tunnel>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udp_tunnel>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).udp_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(udp_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).prot_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(prot_type)
        )
    );
}
/// A structure used to enable/disable specific device interrupts.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_intr_conf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_rte_intr_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_conf))
    );
}
impl rte_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
/// A structure used to configure an Ethernet port.
/// Depending upon the RX multi-queue mode, extra advanced
/// configuration settings may be needed.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    ///< bitmap of ETH_LINK_SPEED_XXX of speeds to be
    ///used. ETH_LINK_SPEED_FIXED disables link
    ///autonegotiation, and a unique speed shall be
    ///set. Otherwise, the bitmap defines the set of
    ///speeds to be advertised. If the special value
    ///ETH_LINK_SPEED_AUTONEG (0) is used, all speeds
    ///supported are advertised.
    pub link_speeds: u32,
    ///< Port RX configuration.
    pub rxmode: rte_eth_rxmode,
    ///< Port TX configuration.
    pub txmode: rte_eth_txmode,
    ///< Loopback operation mode. By default the value
    ///is 0, meaning the loopback mode is disabled.
    ///Read the datasheet of given ethernet controller
    ///for details. The possible values of this field
    ///are defined in implementation of each driver.
    pub lpbk_mode: u32,
    ///< Port RX filtering configuration.
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    ///< Port TX DCB configuration (union).
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    /// Currently,Priority Flow Control(PFC) are supported,if DCB with PFC
    ///is needed,and the variable must be set ETH_DCB_PFC_SUPPORT.
    pub dcb_capability_en: u32,
    ///< FDIR configuration.
    pub fdir_conf: rte_fdir_conf,
    ///< Interrupt mode configuration.
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    ///< Port RSS configuration
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>(),
        2120usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).rss_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(rss_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_dcb_conf as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_dcb_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).dcb_rx_conf as *const _ as usize
        },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(dcb_rx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_rx_conf as *const _ as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_rx_conf)
        )
    );
}
impl Default for rte_eth_conf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_dcb_tx_conf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).dcb_tx_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_tx_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_tx_conf)
        )
    );
}
impl Default for rte_eth_conf__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf>(),
        3000usize,
        concat!("Size of: ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).link_speeds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(link_speeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rxmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rxmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).txmode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(txmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).lpbk_mode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(lpbk_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rx_adv_conf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).tx_adv_conf as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(tx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).dcb_capability_en as *const _ as usize },
        2196usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(dcb_capability_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).fdir_conf as *const _ as usize },
        2200usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(fdir_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).intr_conf as *const _ as usize },
        2992usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(intr_conf)
        )
    );
}
impl Default for rte_eth_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Preferred Rx/Tx port parameters.
/// There are separate instances of this structure for transmission
/// and reception respectively.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_portconf {
    ///< Device-preferred burst size
    pub burst_size: u16,
    ///< Device-preferred size of queue rings
    pub ring_size: u16,
    ///< Device-preferred number of queues
    pub nb_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_portconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_portconf>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_portconf>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).burst_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(burst_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).ring_size as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_portconf>())).nb_queues as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(nb_queues)
        )
    );
}
/// Ethernet device associated switch information
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_switch_info {
    ///< switch name
    pub name: *const ::std::os::raw::c_char,
    ///< switch domain id
    pub domain_id: u16,
    pub port_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_switch_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_switch_info>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_switch_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).domain_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_switch_info>())).port_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(port_id)
        )
    );
}
impl Default for rte_eth_switch_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to retrieve the contextual information of
/// an Ethernet device, such as the controlling driver of the
/// device, etc...
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_info {
    pub device: *mut rte_device,
    ///< Device Driver name.
    pub driver_name: *const ::std::os::raw::c_char,
    ///< Index to bound host interface, or 0 if none.
    ///Use if_indextoname() to translate into an interface name.
    pub if_index: ::std::os::raw::c_uint,
    ///< Device flags
    pub dev_flags: *const u32,
    ///< Minimum size of RX buffer.
    pub min_rx_bufsize: u32,
    ///< Maximum configurable length of RX pkt.
    pub max_rx_pktlen: u32,
    ///< Maximum number of RX queues.
    pub max_rx_queues: u16,
    ///< Maximum number of TX queues.
    pub max_tx_queues: u16,
    ///< Maximum number of MAC addresses.
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    ///< Maximum number of VFs.
    pub max_vfs: u16,
    ///< Maximum number of VMDq pools.
    pub max_vmdq_pools: u16,
    pub rx_offload_capa: u64,
    pub tx_offload_capa: u64,
    pub rx_queue_offload_capa: u64,
    pub tx_queue_offload_capa: u64,
    pub reta_size: u16,
    ///< Hash key size in bytes
    pub hash_key_size: u8,
    /// Bit mask of RSS offloads, the bit offset also means flow type
    pub flow_type_rss_offloads: u64,
    ///< Default RX configuration
    pub default_rxconf: rte_eth_rxconf,
    ///< Default TX configuration
    pub default_txconf: rte_eth_txconf,
    ///< First queue ID for VMDQ pools.
    pub vmdq_queue_base: u16,
    ///< Queue number for VMDQ pools.
    pub vmdq_queue_num: u16,
    ///< First ID of VMDQ pools.
    pub vmdq_pool_base: u16,
    ///< RX descriptors limits
    pub rx_desc_lim: rte_eth_desc_lim,
    ///< TX descriptors limits
    pub tx_desc_lim: rte_eth_desc_lim,
    ///< Supported speeds bitmap (ETH_LINK_SPEED_).
    pub speed_capa: u32,
    ///< Number of RX queues.
    pub nb_rx_queues: u16,
    ///< Number of TX queues.
    pub nb_tx_queues: u16,
    /// Rx parameter recommendations
    pub default_rxportconf: rte_eth_dev_portconf,
    /// Tx parameter recommendations
    pub default_txportconf: rte_eth_dev_portconf,
    /// Generic device capabilities (RTE_ETH_DEV_CAPA_).
    pub dev_capa: u64,
    /// Switching information for ports on a device with a
    /// embedded managed interconnect/switch.
    pub switch_info: rte_eth_switch_info,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_info>(),
        216usize,
        concat!("Size of: ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).driver_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(driver_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).if_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(if_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).min_rx_bufsize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_rx_bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_pktlen as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_pktlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_queues as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_tx_queues as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_mac_addrs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mac_addrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).max_hash_mac_addrs as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vfs as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vmdq_pools as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vmdq_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_offload_capa as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_offload_capa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_offload_capa as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_offload_capa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_queue_offload_capa as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_queue_offload_capa as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reta_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reta_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).hash_key_size as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(hash_key_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).flow_type_rss_offloads as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(flow_type_rss_offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxconf as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txconf as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txconf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_base as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_num as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_pool_base as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_pool_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_desc_lim as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_desc_lim as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).speed_capa as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(speed_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_rx_queues as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_tx_queues as *const _ as usize },
        178usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxportconf as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxportconf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txportconf as *const _ as usize
        },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txportconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).dev_capa as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).switch_info as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(switch_info)
        )
    );
}
impl Default for rte_eth_dev_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Ethernet device RX queue information structure.
/// Used to retieve information about configured queue.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxq_info {
    ///< mempool used by that queue.
    pub mp: *mut rte_mempool,
    ///< queue config parameters.
    pub conf: rte_eth_rxconf,
    ///< scattered packets RX supported.
    pub scattered_rx: u8,
    ///< configured number of RXDs.
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxq_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).mp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).conf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).scattered_rx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(scattered_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).nb_desc as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
impl Default for rte_eth_rxq_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Ethernet device TX queue information structure.
/// Used to retrieve information about configured queue.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_txq_info {
    ///< queue config parameters.
    pub conf: rte_eth_txconf,
    ///< configured number of TXDs.
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u16; 19usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txq_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).nb_desc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
impl Default for rte_eth_txq_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// An Ethernet device extended statistic structure
///
/// This structure is used by rte_eth_xstats_get() to provide
/// statistics that are not provided in the generic *rte_eth_stats*
/// structure.
/// It maps a name id, corresponding to an index in the array returned
/// by rte_eth_xstats_get_names(), to a statistic value.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_xstat {
    ///< The index in xstats name array.
    pub id: u64,
    ///< The statistic counter value.
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_xstat() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat),
            "::",
            stringify!(value)
        )
    );
}
/// A name element for extended statistics.
///
/// An array of this structure is returned by rte_eth_xstats_get_names().
/// It lists the names of extended statistics for a PMD. The *rte_eth_xstat*
/// structure references these names by their array index.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    ///< The statistic name.
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_xstat_name() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat_name>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat_name>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat_name>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat_name),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_eth_xstat_name {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to get the information of queue and
/// TC mapping on both TX and RX paths.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
/// rx queues assigned to tc per Pool
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).nb_queue
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(nb_queue)
        )
    );
}
/// rx queues assigned to tc per Pool
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).nb_queue
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>(),
        2048usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_rxq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_rxq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_txq as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_txq)
        )
    );
}
impl Default for rte_eth_dcb_tc_queue_mapping {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// A structure used to get the information of DCB.
/// It includes TC UP mapping and queue TC mapping.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    ///< number of TCs
    pub nb_tcs: u8,
    ///< Priority to tc
    pub prio_tc: [u8; 8usize],
    ///< TX BW percentage for each TC
    pub tc_bws: [u8; 8usize],
    /// rx queues assigned to tc
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_info>(),
        2065usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).prio_tc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(prio_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_bws as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_bws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_queue as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_queue)
        )
    );
}
impl Default for rte_eth_dcb_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Function type used for RX packet processing packet callbacks.
///
/// The callback function is called on RX with a burst of packets that have
/// been received on the given port and queue.
///
/// @param port_id
///   The Ethernet port on which RX is being performed.
/// @param queue
///   The queue on the Ethernet port which is being used to receive the packets.
/// @param pkts
///   The burst of packets that have just been received.
/// @param nb_pkts
///   The number of packets in the burst pointed to by "pkts".
/// @param max_pkts
///   The max number of packets that can be stored in the "pkts" array.
/// @param user_param
///   The arbitrary user parameter passed in by the application when the callback
///   was originally configured.
/// @return
///   The number of packets returned to the user.
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
/// Function type used for TX packet processing packet callbacks.
///
/// The callback function is called on TX with a burst of packets immediately
/// before the packets are put onto the hardware queue for transmission.
///
/// @param port_id
///   The Ethernet port on which TX is being performed.
/// @param queue
///   The queue on the Ethernet port which is being used to transmit the packets.
/// @param pkts
///   The burst of packets that are about to be transmitted.
/// @param nb_pkts
///   The number of packets in the burst pointed to by "pkts".
/// @param user_param
///   The arbitrary user parameter passed in by the application when the callback
///   was originally configured.
/// @return
///   The number of packets to be written to the NIC.
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
pub mod rte_eth_dev_state {
    /// Possible states of an ethdev port.
    pub type Type = u32;
    /// Device is unused before being probed.
    pub const RTE_ETH_DEV_UNUSED: Type = 0;
    /// Device is attached when allocated in probing.
    pub const RTE_ETH_DEV_ATTACHED: Type = 1;
    /// Device is in removed state when plug-out is detected.
    pub const RTE_ETH_DEV_REMOVED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_sriov {
    ///< SRIOV is active with 16, 32 or 64 pools
    pub active: u8,
    ///< rx queue number per pool
    pub nb_q_per_pool: u8,
    ///< Default pool num used for PF
    pub def_vmdq_idx: u16,
    ///< Default pool queue start reg index
    pub def_pool_q_idx: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_sriov() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_sriov>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_sriov>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).nb_q_per_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(nb_q_per_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_vmdq_idx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_vmdq_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_pool_q_idx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_pool_q_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_owner {
    ///< The owner unique identifier.
    pub id: u64,
    ///< The owner name.
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_owner() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_owner>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_owner>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_owner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_owner),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_owner>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_owner),
            "::",
            stringify!(name)
        )
    );
}
impl Default for rte_eth_dev_owner {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Iterates over valid ethdev ports owned by a specific owner.
    ///
    /// @param port_id
    ///   The id of the next possible valid owned port.
    /// @param	owner_id
    ///  The owner identifier.
    ///  RTE_ETH_DEV_NO_OWNER means iterate over all valid ownerless ports.
    /// @return
    ///   Next valid port id owned by owner_id, RTE_MAX_ETHPORTS if there is none.
    pub fn rte_eth_find_next_owned_by(port_id: u16, owner_id: u64) -> u64;
}
extern "C" {
    /// Iterates over valid ethdev ports.
    ///
    /// @param port_id
    ///   The id of the next possible valid port.
    /// @return
    ///   Next valid port id, RTE_MAX_ETHPORTS if there is none.
    pub fn rte_eth_find_next(port_id: u16) -> u16;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Get a new unique owner identifier.
    /// An owner identifier is used to owns Ethernet devices by only one DPDK entity
    /// to avoid multiple management of device by different entities.
    ///
    /// @param	owner_id
    ///   Owner identifier pointer.
    /// @return
    ///   Negative errno value on error, 0 on success.
    pub fn rte_eth_dev_owner_new(owner_id: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Set an Ethernet device owner.
    ///
    /// @param	port_id
    ///  The identifier of the port to own.
    /// @param	owner
    ///  The owner pointer.
    /// @return
    ///  Negative errno value on error, 0 on success.
    pub fn rte_eth_dev_owner_set(
        port_id: u16,
        owner: *const rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Unset Ethernet device owner to make the device ownerless.
    ///
    /// @param	port_id
    ///  The identifier of port to make ownerless.
    /// @param	owner_id
    ///  The owner identifier.
    /// @return
    ///  0 on success, negative errno value on error.
    pub fn rte_eth_dev_owner_unset(port_id: u16, owner_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Remove owner from all Ethernet devices owned by a specific owner.
    ///
    /// @param	owner_id
    ///  The owner identifier.
    pub fn rte_eth_dev_owner_delete(owner_id: u64);
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Get the owner of an Ethernet device.
    ///
    /// @param	port_id
    ///  The port identifier.
    /// @param	owner
    ///  The owner structure pointer to fill.
    /// @return
    ///  0 on success, negative errno value on error..
    pub fn rte_eth_dev_owner_get(
        port_id: u16,
        owner: *mut rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the total number of Ethernet devices that have been successfully
    /// initialized by the matching Ethernet driver during the PCI probing phase
    /// and that are available for applications to use. These devices must be
    /// accessed by using the ``RTE_ETH_FOREACH_DEV()`` macro to deal with
    /// non-contiguous ranges of devices.
    /// These non-contiguous ranges can be created by calls to hotplug functions or
    /// by some PMDs.
    ///
    /// @return
    ///   - The total number of usable Ethernet devices.
    pub fn rte_eth_dev_count() -> u16;
}
extern "C" {
    /// Get the number of ports which are usable for the application.
    ///
    /// These devices must be iterated by using the macro
    /// ``RTE_ETH_FOREACH_DEV`` or ``RTE_ETH_FOREACH_DEV_OWNED_BY``
    /// to deal with non-contiguous ranges of devices.
    ///
    /// @return
    ///   The count of available Ethernet devices.
    pub fn rte_eth_dev_count_avail() -> u16;
}
extern "C" {
    /// Get the total number of ports which are allocated.
    ///
    /// Some devices may not be available for the application.
    ///
    /// @return
    ///   The total count of Ethernet devices.
    pub fn rte_eth_dev_count_total() -> u16;
}
extern "C" {
    /// Convert a numerical speed in Mbps to a bitmap flag that can be used in
    /// the bitmap link_speeds of the struct rte_eth_conf
    ///
    /// @param speed
    ///   Numerical speed value in Mbps
    /// @param duplex
    ///   ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)
    /// @return
    ///   0 if the speed cannot be mapped
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    /// Get DEV_RX_OFFLOAD_* flag name.
    ///
    /// @param offload
    ///   Offload flag.
    /// @return
    ///   Offload name or 'UNKNOWN' if the flag cannot be recognised.
    pub fn rte_eth_dev_rx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get DEV_TX_OFFLOAD_* flag name.
    ///
    /// @param offload
    ///   Offload flag.
    /// @return
    ///   Offload name or 'UNKNOWN' if the flag cannot be recognised.
    pub fn rte_eth_dev_tx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Configure an Ethernet device.
    /// This function must be invoked first before any other function in the
    /// Ethernet API. This function can also be re-invoked when a device is in the
    /// stopped state.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device to configure.
    /// @param nb_rx_queue
    ///   The number of receive queues to set up for the Ethernet device.
    /// @param nb_tx_queue
    ///   The number of transmit queues to set up for the Ethernet device.
    /// @param eth_conf
    ///   The pointer to the configuration data to be used for the Ethernet device.
    ///   The *rte_eth_conf* structure includes:
    ///     -  the hardware offload features to activate, with dedicated fields for
    ///        each statically configurable offload hardware feature provided by
    ///        Ethernet devices, such as IP checksum or VLAN tag stripping for
    ///        example.
    ///        The Rx offload bitfield API is obsolete and will be deprecated.
    ///        Applications should set the ignore_bitfield_offloads bit on *rxmode*
    ///        structure and use offloads field to set per-port offloads instead.
    ///     -  Any offloading set in eth_conf->[rt]xmode.offloads must be within
    ///        the [rt]x_offload_capa returned from rte_eth_dev_infos_get().
    ///        Any type of device supported offloading set in the input argument
    ///        eth_conf->[rt]xmode.offloads to rte_eth_dev_configure() is enabled
    ///        on all queues and it can't be disabled in rte_eth_[rt]x_queue_setup()
    ///     -  the Receive Side Scaling (RSS) configuration when using multiple RX
    ///        queues per port. Any RSS hash function set in eth_conf->rss_conf.rss_hf
    ///        must be within the flow_type_rss_offloads provided by drivers via
    ///        rte_eth_dev_infos_get() API.
    ///
    ///   Embedding all configuration information in a single data structure
    ///   is the more flexible method that allows the addition of new features
    ///   without changing the syntax of the API.
    /// @return
    ///   - 0: Success, device configured.
    ///   - <0: Error code returned by the driver configuration function.
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Check if an Ethernet device was physically removed.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   1 when the Ethernet device is removed, otherwise 0.
    pub fn rte_eth_dev_is_removed(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate and set up a receive queue for an Ethernet device.
    ///
    /// The function allocates a contiguous block of memory for *nb_rx_desc*
    /// receive descriptors from a memory zone associated with *socket_id*
    /// and initializes each receive descriptor with a network buffer allocated
    /// from the memory pool *mb_pool*.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param rx_queue_id
    ///   The index of the receive queue to set up.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @param nb_rx_desc
    ///   The number of receive descriptors to allocate for the receive ring.
    /// @param socket_id
    ///   The *socket_id* argument is the socket identifier in case of NUMA.
    ///   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for
    ///   the DMA memory allocated for the receive descriptors of the ring.
    /// @param rx_conf
    ///   The pointer to the configuration data to be used for the receive queue.
    ///   NULL value is allowed, in which case default RX configuration
    ///   will be used.
    ///   The *rx_conf* structure contains an *rx_thresh* structure with the values
    ///   of the Prefetch, Host, and Write-Back threshold registers of the receive
    ///   ring.
    ///   In addition it contains the hardware offloads features to activate using
    ///   the DEV_RX_OFFLOAD_* flags.
    ///   If an offloading set in rx_conf->offloads
    ///   hasn't been set in the input argument eth_conf->rxmode.offloads
    ///   to rte_eth_dev_configure(), it is a new added offloading, it must be
    ///   per-queue type and it is enabled for the queue.
    ///   No need to repeat any bit in rx_conf->offloads which has already been
    ///   enabled in rte_eth_dev_configure() at port level. An offloading enabled
    ///   at port level can't be disabled at queue level.
    /// @param mb_pool
    ///   The pointer to the memory pool from which to allocate *rte_mbuf* network
    ///   memory buffers to populate each descriptor of the receive ring.
    /// @return
    ///   - 0: Success, receive queue correctly set up.
    ///   - -EIO: if device is removed.
    ///   - -EINVAL: The size of network buffers which can be allocated from the
    ///      memory pool does not fit the various buffer sizes allowed by the
    ///      device controller.
    ///   - -ENOMEM: Unable to allocate the receive ring descriptors or to
    ///      allocate network memory buffers from the memory pool when
    ///      initializing receive descriptors.
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate and set up a transmit queue for an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param tx_queue_id
    ///   The index of the transmit queue to set up.
    ///   The value must be in the range [0, nb_tx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @param nb_tx_desc
    ///   The number of transmit descriptors to allocate for the transmit ring.
    /// @param socket_id
    ///   The *socket_id* argument is the socket identifier in case of NUMA.
    ///   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for
    ///   the DMA memory allocated for the transmit descriptors of the ring.
    /// @param tx_conf
    ///   The pointer to the configuration data to be used for the transmit queue.
    ///   NULL value is allowed, in which case default TX configuration
    ///   will be used.
    ///   The *tx_conf* structure contains the following data:
    ///   - The *tx_thresh* structure with the values of the Prefetch, Host, and
    ///     Write-Back threshold registers of the transmit ring.
    ///     When setting Write-Back threshold to the value greater then zero,
    ///     *tx_rs_thresh* value should be explicitly set to one.
    ///   - The *tx_free_thresh* value indicates the [minimum] number of network
    ///     buffers that must be pending in the transmit ring to trigger their
    ///     [implicit] freeing by the driver transmit function.
    ///   - The *tx_rs_thresh* value indicates the [minimum] number of transmit
    ///     descriptors that must be pending in the transmit ring before setting the
    ///     RS bit on a descriptor by the driver transmit function.
    ///     The *tx_rs_thresh* value should be less or equal then
    ///     *tx_free_thresh* value, and both of them should be less then
    ///     *nb_tx_desc* - 3.
    ///   - The *offloads* member contains Tx offloads to be enabled.
    ///     If an offloading set in tx_conf->offloads
    ///     hasn't been set in the input argument eth_conf->txmode.offloads
    ///     to rte_eth_dev_configure(), it is a new added offloading, it must be
    ///     per-queue type and it is enabled for the queue.
    ///     No need to repeat any bit in tx_conf->offloads which has already been
    ///     enabled in rte_eth_dev_configure() at port level. An offloading enabled
    ///     at port level can't be disabled at queue level.
    ///
    ///     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces
    ///     the transmit function to use default values.
    /// @return
    ///   - 0: Success, the transmit queue is correctly set up.
    ///   - -ENOMEM: Unable to allocate the transmit ring descriptors.
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the NUMA socket to which an Ethernet device is connected
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device
    /// @return
    ///   The NUMA socket id to which the Ethernet device is connected or
    ///   a default of zero if the socket could not be determined.
    ///   -1 is returned is the port_id value is out of range.
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if port_id of device is attached
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device
    /// @return
    ///   - 0 if port is out of range or not attached
    ///   - 1 if device is attached
    pub fn rte_eth_dev_is_valid_port(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start specified RX queue of a port. It is used when rx_deferred_start
    /// flag of the specified queue is true.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device
    /// @param rx_queue_id
    ///   The index of the rx queue to update the ring.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @return
    ///   - 0: Success, the receive queue is started.
    ///   - -EINVAL: The port_id or the queue_id out of range.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_rx_queue_start(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop specified RX queue of a port
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device
    /// @param rx_queue_id
    ///   The index of the rx queue to update the ring.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @return
    ///   - 0: Success, the receive queue is stopped.
    ///   - -EINVAL: The port_id or the queue_id out of range.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_rx_queue_stop(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start TX for specified queue of a port. It is used when tx_deferred_start
    /// flag of the specified queue is true.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device
    /// @param tx_queue_id
    ///   The index of the tx queue to update the ring.
    ///   The value must be in the range [0, nb_tx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @return
    ///   - 0: Success, the transmit queue is started.
    ///   - -EINVAL: The port_id or the queue_id out of range.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_tx_queue_start(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop specified TX queue of a port
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device
    /// @param tx_queue_id
    ///   The index of the tx queue to update the ring.
    ///   The value must be in the range [0, nb_tx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @return
    ///   - 0: Success, the transmit queue is stopped.
    ///   - -EINVAL: The port_id or the queue_id out of range.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function not supported in PMD driver.
    pub fn rte_eth_dev_tx_queue_stop(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Start an Ethernet device.
    ///
    /// The device start step is the last one and consists of setting the configured
    /// offload features and in starting the transmit and the receive units of the
    /// device.
    ///
    /// Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before
    /// PMD port start callback function is invoked.
    ///
    /// On success, all basic functions exported by the Ethernet API (link status,
    /// receive/transmit, and so on) can be invoked.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - 0: Success, Ethernet device started.
    ///   - <0: Error code of the driver device start function.
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Stop an Ethernet device. The device can be restarted with a call to
    /// rte_eth_dev_start()
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_dev_stop(port_id: u16);
}
extern "C" {
    /// Link up an Ethernet device.
    ///
    /// Set device link up will re-enable the device rx/tx
    /// functionality after it is previously set device linked down.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - 0: Success, Ethernet device linked up.
    ///   - <0: Error code of the driver device link up function.
    pub fn rte_eth_dev_set_link_up(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Link down an Ethernet device.
    /// The device rx/tx functionality will be disabled if success,
    /// and it can be re-enabled with a call to
    /// rte_eth_dev_set_link_up()
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_dev_set_link_down(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Close a stopped Ethernet device. The device cannot be restarted!
    /// The function frees all port resources if the driver supports
    /// the flag RTE_ETH_DEV_CLOSE_REMOVE.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_dev_close(port_id: u16);
}
extern "C" {
    /// Reset a Ethernet device and keep its port id.
    ///
    /// When a port has to be reset passively, the DPDK application can invoke
    /// this function. For example when a PF is reset, all its VFs should also
    /// be reset. Normally a DPDK application can invoke this function when
    /// RTE_ETH_EVENT_INTR_RESET event is detected, but can also use it to start
    /// a port reset in other circumstances.
    ///
    /// When this function is called, it first stops the port and then calls the
    /// PMD specific dev_uninit( ) and dev_init( ) to return the port to initial
    /// state, in which no Tx and Rx queues are setup, as if the port has been
    /// reset and not started. The port keeps the port id it had before the
    /// function call.
    ///
    /// After calling rte_eth_dev_reset( ), the application should use
    /// rte_eth_dev_configure( ), rte_eth_rx_queue_setup( ),
    /// rte_eth_tx_queue_setup( ), and rte_eth_dev_start( )
    /// to reconfigure the device as appropriate.
    ///
    /// Note: To avoid unexpected behavior, the application should stop calling
    /// Tx and Rx functions before calling rte_eth_dev_reset( ). For thread
    /// safety, all these controlling functions should be called from the same
    /// thread.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    ///
    /// @return
    ///   - (0) if successful.
    ///   - (-EINVAL) if port identifier is invalid.
    ///   - (-ENOTSUP) if hardware doesn't support this function.
    ///   - (-EPERM) if not ran from the primary process.
    ///   - (-EIO) if re-initialisation failed or device is removed.
    ///   - (-ENOMEM) if the reset failed due to OOM.
    ///   - (-EAGAIN) if the reset temporarily failed and should be retried later.
    pub fn rte_eth_dev_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable receipt in promiscuous mode for an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_promiscuous_enable(port_id: u16);
}
extern "C" {
    /// Disable receipt in promiscuous mode for an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_promiscuous_disable(port_id: u16);
}
extern "C" {
    /// Return the value of promiscuous mode for an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - (1) if promiscuous is enabled
    ///   - (0) if promiscuous is disabled.
    ///   - (-1) on error
    pub fn rte_eth_promiscuous_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable the receipt of any multicast frame by an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_allmulticast_enable(port_id: u16);
}
extern "C" {
    /// Disable the receipt of all multicast frames by an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_allmulticast_disable(port_id: u16);
}
extern "C" {
    /// Return the value of allmulticast mode for an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - (1) if allmulticast is enabled
    ///   - (0) if allmulticast is disabled.
    ///   - (-1) on error
    pub fn rte_eth_allmulticast_get(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX
    /// or FULL-DUPLEX) of the physical link of an Ethernet device. It might need
    /// to wait up to 9 seconds in it.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param link
    ///   A pointer to an *rte_eth_link* structure to be filled with
    ///   the status, the speed and the mode of the Ethernet device link.
    pub fn rte_eth_link_get(port_id: u16, link: *mut rte_eth_link);
}
extern "C" {
    /// Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX
    /// or FULL-DUPLEX) of the physical link of an Ethernet device. It is a no-wait
    /// version of rte_eth_link_get().
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param link
    ///   A pointer to an *rte_eth_link* structure to be filled with
    ///   the status, the speed and the mode of the Ethernet device link.
    pub fn rte_eth_link_get_nowait(port_id: u16, link: *mut rte_eth_link);
}
extern "C" {
    /// Retrieve the general I/O statistics of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param stats
    ///   A pointer to a structure of type *rte_eth_stats* to be filled with
    ///   the values of device counters for the following set of statistics:
    ///   - *ipackets* with the total of successfully received packets.
    ///   - *opackets* with the total of successfully transmitted packets.
    ///   - *ibytes*   with the total of successfully received bytes.
    ///   - *obytes*   with the total of successfully transmitted bytes.
    ///   - *ierrors*  with the total of erroneous received packets.
    ///   - *oerrors*  with the total of failed transmitted packets.
    /// @return
    ///   Zero if successful. Non-zero otherwise.
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset the general I/O statistics of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - (0) if device notified to reset stats.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_stats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve names of extended statistics of an Ethernet device.
    ///
    /// There is an assumption that 'xstat_names' and 'xstats' arrays are matched
    /// by array index:
    ///  xstats_names[i].name => xstats[i].value
    ///
    /// And the array index is same with id field of 'struct rte_eth_xstat':
    ///  xstats[i].id == i
    ///
    /// This assumption makes key-value pair matching less flexible but simpler.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param xstats_names
    ///   An rte_eth_xstat_name array of at least *size* elements to
    ///   be filled. If set to NULL, the function returns the required number
    ///   of elements.
    /// @param size
    ///   The size of the xstats_names array (number of elements).
    /// @return
    ///   - A positive value lower or equal to size: success. The return value
    ///     is the number of entries filled in the stats table.
    ///   - A positive value higher than size: error, the given statistics table
    ///     is too small. The return value corresponds to the size that should
    ///     be given to succeed. The entries in the table are not valid and
    ///     shall not be used by the caller.
    ///   - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get_names(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve extended statistics of an Ethernet device.
    ///
    /// There is an assumption that 'xstat_names' and 'xstats' arrays are matched
    /// by array index:
    ///  xstats_names[i].name => xstats[i].value
    ///
    /// And the array index is same with id field of 'struct rte_eth_xstat':
    ///  xstats[i].id == i
    ///
    /// This assumption makes key-value pair matching less flexible but simpler.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param xstats
    ///   A pointer to a table of structure of type *rte_eth_xstat*
    ///   to be filled with device statistics ids and values.
    ///   This parameter can be set to NULL if n is 0.
    /// @param n
    ///   The size of the xstats array (number of elements).
    /// @return
    ///   - A positive value lower or equal to n: success. The return value
    ///     is the number of entries filled in the stats table.
    ///   - A positive value higher than n: error, the given statistics table
    ///     is too small. The return value corresponds to the size that should
    ///     be given to succeed. The entries in the table are not valid and
    ///     shall not be used by the caller.
    ///   - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get(
        port_id: u16,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve names of extended statistics of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param xstats_names
    ///   An rte_eth_xstat_name array of at least *size* elements to
    ///   be filled. If set to NULL, the function returns the required number
    ///   of elements.
    /// @param ids
    ///   IDs array given by app to retrieve specific statistics
    /// @param size
    ///   The size of the xstats_names array (number of elements).
    /// @return
    ///   - A positive value lower or equal to size: success. The return value
    ///     is the number of entries filled in the stats table.
    ///   - A positive value higher than size: error, the given statistics table
    ///     is too small. The return value corresponds to the size that should
    ///     be given to succeed. The entries in the table are not valid and
    ///     shall not be used by the caller.
    ///   - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve extended statistics of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param ids
    ///   A pointer to an ids array passed by application. This tells which
    ///   statistics values function should retrieve. This parameter
    ///   can be set to NULL if size is 0. In this case function will retrieve
    ///   all avalible statistics.
    /// @param values
    ///   A pointer to a table to be filled with device statistics values.
    /// @param size
    ///   The size of the ids array (number of elements).
    /// @return
    ///   - A positive value lower or equal to size: success. The return value
    ///     is the number of entries filled in the stats table.
    ///   - A positive value higher than size: error, the given statistics table
    ///     is too small. The return value corresponds to the size that should
    ///     be given to succeed. The entries in the table are not valid and
    ///     shall not be used by the caller.
    ///   - A negative value on error (invalid port id).
    pub fn rte_eth_xstats_get_by_id(
        port_id: u16,
        ids: *const u64,
        values: *mut u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Gets the ID of a statistic from its name.
    ///
    /// This function searches for the statistics using string compares, and
    /// as such should not be used on the fast-path. For fast-path retrieval of
    /// specific statistics, store the ID as provided in *id* from this function,
    /// and pass the ID to rte_eth_xstats_get()
    ///
    /// @param port_id The port to look up statistics from
    /// @param xstat_name The name of the statistic to return
    /// @param[out] id A pointer to an app-supplied uint64_t which should be
    ///                set to the ID of the stat if the stat exists.
    /// @return
    ///    0 on success
    ///    -ENODEV for invalid port_id,
    ///    -EIO if device is removed,
    ///    -EINVAL if the xstat_name doesn't exist in port_id
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u16,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset extended statistics of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    pub fn rte_eth_xstats_reset(port_id: u16);
}
extern "C" {
    ///  Set a mapping for the specified transmit queue to the specified per-queue
    ///  statistics counter.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param tx_queue_id
    ///   The index of the transmit queue for which a queue stats mapping is required.
    ///   The value must be in the range [0, nb_tx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @param stat_idx
    ///   The per-queue packet statistics functionality number that the transmit
    ///   queue is to be assigned.
    ///   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1].
    /// @return
    ///   Zero if successful. Non-zero otherwise.
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u16,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Set a mapping for the specified receive queue to the specified per-queue
    ///  statistics counter.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param rx_queue_id
    ///   The index of the receive queue for which a queue stats mapping is required.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @param stat_idx
    ///   The per-queue packet statistics functionality number that the receive
    ///   queue is to be assigned.
    ///   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1].
    /// @return
    ///   Zero if successful. Non-zero otherwise.
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u16,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the Ethernet address of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mac_addr
    ///   A pointer to a structure of type *ether_addr* to be filled with
    ///   the Ethernet address of the Ethernet device.
    pub fn rte_eth_macaddr_get(port_id: u16, mac_addr: *mut ether_addr);
}
extern "C" {
    /// Retrieve the contextual information of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param dev_info
    ///   A pointer to a structure of type *rte_eth_dev_info* to be filled with
    ///   the contextual information of the Ethernet device.
    pub fn rte_eth_dev_info_get(port_id: u16, dev_info: *mut rte_eth_dev_info);
}
extern "C" {
    /// Retrieve the firmware version of a device.
    ///
    /// @param port_id
    ///   The port identifier of the device.
    /// @param fw_version
    ///   A pointer to a string array storing the firmware version of a device,
    ///   the string includes terminating null. This pointer is allocated by caller.
    /// @param fw_size
    ///   The size of the string array pointed by fw_version, which should be
    ///   large enough to store firmware version of the device.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if operation is not supported.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (>0) if *fw_size* is not enough to store firmware version, return
    ///          the size of the non truncated string.
    pub fn rte_eth_dev_fw_version_get(
        port_id: u16,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the supported packet types of an Ethernet device.
    ///
    /// When a packet type is announced as supported, it *must* be recognized by
    /// the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN
    /// and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following
    /// packet types for these packets:
    /// - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4
    /// - Ether/Vlan/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4
    /// - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER
    /// - Ether/Vlan/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN
    ///
    /// When a packet is received by a PMD, the most precise type must be
    /// returned among the ones supported. However a PMD is allowed to set
    /// packet type that is not in the supported list, at the condition that it
    /// is more precise. Therefore, a PMD announcing no supported packet types
    /// can still set a matching packet type in a received packet.
    ///
    /// @note
    ///   Better to invoke this API after the device is already started or rx burst
    ///   function is decided, to obtain correct supported ptypes.
    /// @note
    ///   if a given PMD does not report what ptypes it supports, then the supported
    ///   ptype count is reported as 0.
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param ptype_mask
    ///   A hint of what kind of packet type which the caller is interested in.
    /// @param ptypes
    ///   An array pointer to store adequate packet types, allocated by caller.
    /// @param num
    ///  Size of the array pointed by param ptypes.
    /// @return
    ///   - (>=0) Number of supported ptypes. If the number of types exceeds num,
    ///           only num entries will be filled into the ptypes array, but the full
    ///           count of supported ptypes will be returned.
    ///   - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u16,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve the MTU of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mtu
    ///   A pointer to a uint16_t where the retrieved MTU is to be stored.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_get_mtu(port_id: u16, mtu: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Change the MTU of an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mtu
    ///   A uint16_t for the MTU to be applied.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if operation is not supported.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-EINVAL) if *mtu* invalid.
    ///   - (-EBUSY) if operation is not allowed when the port is running
    pub fn rte_eth_dev_set_mtu(port_id: u16, mtu: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable hardware filtering by an Ethernet device of received
    /// VLAN packets tagged with a given VLAN Tag Identifier.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param vlan_id
    ///   The VLAN Tag Identifier whose filtering must be enabled or disabled.
    /// @param on
    ///   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*.
    ///   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOSUP) if hardware-assisted VLAN filtering not configured.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOSYS) if VLAN filtering on *port_id* disabled.
    ///   - (-EINVAL) if *vlan_id* > 4095.
    pub fn rte_eth_dev_vlan_filter(
        port_id: u16,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device.
    /// 82599/X540/X550 can support VLAN stripping at the rx queue level
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param rx_queue_id
    ///   The index of the receive queue for which a queue stats mapping is required.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @param on
    ///   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port.
    ///   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOSUP) if hardware-assisted VLAN stripping not configured.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EINVAL) if *rx_queue_id* invalid.
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u16,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to
    /// the VLAN Header. This is a register setup available on some Intel NIC, not
    /// but all, please check the data sheet for availability.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param vlan_type
    ///   The vlan type.
    /// @param tag_type
    ///   The Tag Protocol ID
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOSUP) if hardware-assisted VLAN TPID setup is not supported.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u16,
        vlan_type: rte_vlan_type::Type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set VLAN offload configuration on an Ethernet device
    /// Enable/Disable Extended VLAN by an Ethernet device, This is a register setup
    /// available on some Intel NIC, not but all, please check the data sheet for
    /// availability.
    /// Enable/Disable VLAN Strip can be done on rx queue for certain NIC, but here
    /// the configuration is applied on the port level.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param offload_mask
    ///   The VLAN Offload bit mask can be mixed use with "OR"
    ///       ETH_VLAN_STRIP_OFFLOAD
    ///       ETH_VLAN_FILTER_OFFLOAD
    ///       ETH_VLAN_EXTEND_OFFLOAD
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOSUP) if hardware-assisted VLAN filtering not configured.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_dev_set_vlan_offload(
        port_id: u16,
        offload_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read VLAN Offload configuration from an Ethernet device
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - (>0) if successful. Bit mask to indicate
    ///       ETH_VLAN_STRIP_OFFLOAD
    ///       ETH_VLAN_FILTER_OFFLOAD
    ///       ETH_VLAN_EXTEND_OFFLOAD
    ///   - (-ENODEV) if *port_id* invalid.
    pub fn rte_eth_dev_get_vlan_offload(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set port based TX VLAN insertion on or off.
    ///
    /// @param port_id
    ///  The port identifier of the Ethernet device.
    /// @param pvid
    ///  Port based TX VLAN identifier together with user priority.
    /// @param on
    ///  Turn on or off the port based TX VLAN insertion.
    ///
    /// @return
    ///   - (0) if successful.
    ///   - negative if failed.
    pub fn rte_eth_dev_set_vlan_pvid(
        port_id: u16,
        pvid: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(
        unsent: *mut *mut rte_mbuf,
        count: u16,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
/// Structure used to buffer packets for future TX
/// Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush
#[repr(C)]
#[derive(Debug)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    ///< Size of buffer for buffered tx
    pub size: u16,
    ///< Number of packets in the array
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_tx_buffer() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_tx_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_dev_tx_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_tx_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_tx_buffer))
    );
}
impl Default for rte_eth_dev_tx_buffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Initialize default values for buffered transmitting
    ///
    /// @param buffer
    ///   Tx buffer to be initialized.
    /// @param size
    ///   Buffer size
    /// @return
    ///   0 if no error
    pub fn rte_eth_tx_buffer_init(
        buffer: *mut rte_eth_dev_tx_buffer,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure a callback for buffered packets which cannot be sent
    ///
    /// Register a specific callback to be called when an attempt is made to send
    /// all packets buffered on an ethernet port, but not all packets can
    /// successfully be sent. The callback registered here will be called only
    /// from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs.
    /// The default callback configured for each queue by default just frees the
    /// packets back to the calling mempool. If additional behaviour is required,
    /// for example, to count dropped packets, or to retry transmission of packets
    /// which cannot be sent, this function should be used to register a suitable
    /// callback function to implement the desired behaviour.
    /// The example callback "rte_eth_count_unsent_packet_callback()" is also
    /// provided as reference.
    ///
    /// @param buffer
    ///   The port identifier of the Ethernet device.
    /// @param callback
    ///   The function to be used as the callback.
    /// @param userdata
    ///   Arbitrary parameter to be passed to the callback function
    /// @return
    ///   0 on success, or -1 on error with rte_errno set appropriately
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Callback function for silently dropping unsent buffered packets.
    ///
    /// This function can be passed to rte_eth_tx_buffer_set_err_callback() to
    /// adjust the default behavior when buffered packets cannot be sent. This
    /// function drops any unsent packets silently and is used by tx buffered
    /// operations as default behavior.
    ///
    /// NOTE: this function should not be called directly, instead it should be used
    ///       as a callback for packet buffering.
    ///
    /// NOTE: when configuring this function as a callback with
    ///       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter
    ///       should point to an uint64_t value.
    ///
    /// @param pkts
    ///   The previously buffered packets which could not be sent
    /// @param unsent
    ///   The number of unsent packets in the pkts array
    /// @param userdata
    ///   Not used
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Callback function for tracking unsent buffered packets.
    ///
    /// This function can be passed to rte_eth_tx_buffer_set_err_callback() to
    /// adjust the default behavior when buffered packets cannot be sent. This
    /// function drops any unsent packets, but also updates a user-supplied counter
    /// to track the overall number of packets dropped. The counter should be an
    /// uint64_t variable.
    ///
    /// NOTE: this function should not be called directly, instead it should be used
    ///       as a callback for packet buffering.
    ///
    /// NOTE: when configuring this function as a callback with
    ///       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter
    ///       should point to an uint64_t value.
    ///
    /// @param pkts
    ///   The previously buffered packets which could not be sent
    /// @param unsent
    ///   The number of unsent packets in the pkts array
    /// @param userdata
    ///   Pointer to an uint64_t value, which will be incremented by unsent
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Request the driver to free mbufs currently cached by the driver. The
    /// driver will only free the mbuf if it is no longer in use. It is the
    /// application's responsibity to ensure rte_eth_tx_buffer_flush(..) is
    /// called if needed.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The index of the transmit queue through which output packets must be
    ///   sent.
    ///   The value must be in the range [0, nb_tx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @param free_cnt
    ///   Maximum number of packets to free. Use 0 to indicate all possible packets
    ///   should be freed. Note that a packet may be using multiple mbufs.
    /// @return
    ///   Failure: < 0
    ///     -ENODEV: Invalid interface
    ///     -EIO: device is removed
    ///     -ENOTSUP: Driver does not support function
    ///   Success: >= 0
    ///     0-n: Number of packets freed. More packets may still remain in ring that
    ///     are in use.
    pub fn rte_eth_tx_done_cleanup(
        port_id: u16,
        queue_id: u16,
        free_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
pub mod rte_eth_event_ipsec_subtype {
    /// Subtypes for IPsec offload event(@ref RTE_ETH_EVENT_IPSEC) raised by
    /// eth device.
    pub type Type = u32;
    pub const RTE_ETH_EVENT_IPSEC_UNKNOWN: Type = 0;
    pub const RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW: Type = 1;
    pub const RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY: Type = 2;
    pub const RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY: Type = 3;
    pub const RTE_ETH_EVENT_IPSEC_MAX: Type = 4;
}
/// Descriptor for @ref RTE_ETH_EVENT_IPSEC event. Used by eth dev to send extra
/// information of the IPsec offload event.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_event_ipsec_desc {
    pub subtype: rte_eth_event_ipsec_subtype::Type,
    pub metadata: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_event_ipsec_desc() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_event_ipsec_desc>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_event_ipsec_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_event_ipsec_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_event_ipsec_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_event_ipsec_desc>())).subtype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_event_ipsec_desc),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_event_ipsec_desc>())).metadata as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_event_ipsec_desc),
            "::",
            stringify!(metadata)
        )
    );
}
impl Default for rte_eth_event_ipsec_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod rte_eth_event_type {
    /// The eth device event type for interrupt, and maybe others in the future.
    pub type Type = u32;
    ///< unknown event type
    pub const RTE_ETH_EVENT_UNKNOWN: Type = 0;
    ///< lsc interrupt event
    pub const RTE_ETH_EVENT_INTR_LSC: Type = 1;
    pub const RTE_ETH_EVENT_QUEUE_STATE: Type = 2;
    pub const RTE_ETH_EVENT_INTR_RESET: Type = 3;
    ///< message from the VF received by PF
    pub const RTE_ETH_EVENT_VF_MBOX: Type = 4;
    ///< MACsec offload related event
    pub const RTE_ETH_EVENT_MACSEC: Type = 5;
    ///< device removal event
    pub const RTE_ETH_EVENT_INTR_RMV: Type = 6;
    ///< port is probed
    pub const RTE_ETH_EVENT_NEW: Type = 7;
    ///< port is released
    pub const RTE_ETH_EVENT_DESTROY: Type = 8;
    ///< IPsec offload related event
    pub const RTE_ETH_EVENT_IPSEC: Type = 9;
    ///< max value of this enum
    pub const RTE_ETH_EVENT_MAX: Type = 10;
}
pub type rte_eth_dev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    /// Register a callback function for port event.
    ///
    /// @param port_id
    ///  Port id.
    ///  RTE_ETH_ALL means register the event for all port ids.
    /// @param event
    ///  Event interested.
    /// @param cb_fn
    ///  User supplied callback function to be called.
    /// @param cb_arg
    ///  Pointer to the parameters for the registered callback.
    ///
    /// @return
    ///  - On success, zero.
    ///  - On failure, a negative value.
    pub fn rte_eth_dev_callback_register(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unregister a callback function for port event.
    ///
    /// @param port_id
    ///  Port id.
    ///  RTE_ETH_ALL means unregister the event for all port ids.
    /// @param event
    ///  Event interested.
    /// @param cb_fn
    ///  User supplied callback function to be called.
    /// @param cb_arg
    ///  Pointer to the parameters for the registered callback. -1 means to
    ///  remove all for the same callback address and same event.
    ///
    /// @return
    ///  - On success, zero.
    ///  - On failure, a negative value.
    pub fn rte_eth_dev_callback_unregister(
        port_id: u16,
        event: rte_eth_event_type::Type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// When there is no rx packet coming in Rx Queue for a long time, we can
    /// sleep lcore related to RX Queue for power saving, and enable rx interrupt
    /// to be triggered when Rx packet arrives.
    ///
    /// The rte_eth_dev_rx_intr_enable() function enables rx queue
    /// interrupt on specific rx queue of a port.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The index of the receive queue from which to retrieve input packets.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if underlying hardware OR driver doesn't support
    ///     that operation.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_dev_rx_intr_enable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// When lcore wakes up from rx interrupt indicating packet coming, disable rx
    /// interrupt and returns to polling mode.
    ///
    /// The rte_eth_dev_rx_intr_disable() function disables rx queue
    /// interrupt on specific rx queue of a port.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The index of the receive queue from which to retrieve input packets.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if underlying hardware OR driver doesn't support
    ///     that operation.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_dev_rx_intr_disable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// RX Interrupt control per port.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param epfd
    ///   Epoll instance fd which the intr vector associated to.
    ///   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.
    /// @param op
    ///   The operation be performed for the vector.
    ///   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.
    /// @param data
    ///   User raw data.
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_eth_dev_rx_intr_ctl(
        port_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// RX Interrupt control per queue.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The index of the receive queue from which to retrieve input packets.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @param epfd
    ///   Epoll instance fd which the intr vector associated to.
    ///   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.
    /// @param op
    ///   The operation be performed for the vector.
    ///   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.
    /// @param data
    ///   User raw data.
    /// @return
    ///   - On success, zero.
    ///   - On failure, a negative value.
    pub fn rte_eth_dev_rx_intr_ctl_q(
        port_id: u16,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Get interrupt fd per Rx queue.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The index of the receive queue from which to retrieve input packets.
    ///   The value must be in the range [0, nb_rx_queue - 1] previously supplied
    ///   to rte_eth_dev_configure().
    /// @return
    ///   - (>=0) the interrupt fd associated to the requested Rx queue if
    ///           successful.
    ///   - (-1) on error.
    pub fn rte_eth_dev_rx_intr_ctl_q_get_fd(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Turn on the LED on the Ethernet device.
    /// This function turns on the LED on the Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if underlying hardware OR driver doesn't support
    ///     that operation.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_led_on(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Turn off the LED on the Ethernet device.
    /// This function turns off the LED on the Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if underlying hardware OR driver doesn't support
    ///     that operation.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_led_off(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get current status of the Ethernet link flow control for Ethernet device
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param fc_conf
    ///   The pointer to the structure where to store the flow control parameters.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support flow control.
    ///   - (-ENODEV)  if *port_id* invalid.
    ///   - (-EIO)  if device is removed.
    pub fn rte_eth_dev_flow_ctrl_get(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure the Ethernet link flow control for Ethernet device
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param fc_conf
    ///   The pointer to the structure of the flow control parameters.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support flow control mode.
    ///   - (-ENODEV)  if *port_id* invalid.
    ///   - (-EINVAL)  if bad parameter
    ///   - (-EIO)     if flow control setup failure or device is removed.
    pub fn rte_eth_dev_flow_ctrl_set(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure the Ethernet priority flow control under DCB environment
    /// for Ethernet device.
    ///
    /// @param port_id
    /// The port identifier of the Ethernet device.
    /// @param pfc_conf
    /// The pointer to the structure of the priority flow control parameters.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support priority flow control mode.
    ///   - (-ENODEV)  if *port_id* invalid.
    ///   - (-EINVAL)  if bad parameter
    ///   - (-EIO)     if flow control setup failure or device is removed.
    pub fn rte_eth_dev_priority_flow_ctrl_set(
        port_id: u16,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a MAC address to an internal array of addresses used to enable whitelist
    /// filtering to accept packets only if the destination MAC address matches.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mac_addr
    ///   The MAC address to add.
    /// @param pool
    ///   VMDq pool index to associate address with (if VMDq is enabled). If VMDq is
    ///   not enabled, this should be set to 0.
    /// @return
    ///   - (0) if successfully added or *mac_addr* was already added.
    ///   - (-ENOTSUP) if hardware doesn't support this feature.
    ///   - (-ENODEV) if *port* is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOSPC) if no more MAC addresses can be added.
    ///   - (-EINVAL) if MAC address is invalid.
    pub fn rte_eth_dev_mac_addr_add(
        port_id: u16,
        mac_addr: *mut ether_addr,
        pool: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a MAC address from the internal array of addresses.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mac_addr
    ///   MAC address to remove.
    /// @return
    ///   - (0) if successful, or *mac_addr* didn't exist.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port* invalid.
    ///   - (-EADDRINUSE) if attempting to remove the default MAC address
    pub fn rte_eth_dev_mac_addr_remove(
        port_id: u16,
        mac_addr: *mut ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the default MAC address.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mac_addr
    ///   New default MAC address.
    /// @return
    ///   - (0) if successful, or *mac_addr* didn't exist.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port* invalid.
    ///   - (-EINVAL) if MAC address is invalid.
    pub fn rte_eth_dev_default_mac_addr_set(
        port_id: u16,
        mac_addr: *mut ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param reta_conf
    ///   RETA to update.
    /// @param reta_size
    ///   Redirection table size. The table size can be queried by
    ///   rte_eth_dev_info_get().
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-EINVAL) if bad parameter.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_dev_rss_reta_update(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param reta_conf
    ///   RETA to query.
    /// @param reta_size
    ///   Redirection table size. The table size can be queried by
    ///   rte_eth_dev_info_get().
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-EINVAL) if bad parameter.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_dev_rss_reta_query(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Updates unicast hash table for receiving packet with the given destination
    /// MAC address, and the packet is routed to all VFs for which the RX mode is
    /// accept packets that match the unicast hash table.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param addr
    ///   Unicast MAC address.
    /// @param on
    ///    1 - Set an unicast hash bit for receiving packets with the MAC address.
    ///    0 - Clear an unicast hash bit.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///  - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_uc_hash_table_set(
        port_id: u16,
        addr: *mut ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Updates all unicast hash bitmaps for receiving packet with any Unicast
    /// Ethernet MAC addresses,the packet is routed to all VFs for which the RX
    /// mode is accept packets that match the unicast hash table.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param on
    ///    1 - Set all unicast hash bitmaps for receiving all the Ethernet
    ///         MAC addresses
    ///    0 - Clear all unicast hash bitmaps
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///  - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_uc_all_hash_table_set(port_id: u16, on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set a traffic mirroring rule on an Ethernet device
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mirror_conf
    ///   The pointer to the traffic mirroring structure describing the mirroring rule.
    ///   The *rte_eth_vm_mirror_conf* structure includes the type of mirroring rule,
    ///   destination pool and the value of rule if enable vlan or pool mirroring.
    ///
    /// @param rule_id
    ///   The index of traffic mirroring rule, we support four separated rules.
    /// @param on
    ///   1 - Enable a mirroring rule.
    ///   0 - Disable a mirroring rule.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support this feature.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-EINVAL) if the mr_conf information is not correct.
    pub fn rte_eth_mirror_rule_set(
        port_id: u16,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset a traffic mirroring rule on an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param rule_id
    ///   The index of traffic mirroring rule, we support four separated rules.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support this feature.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-EINVAL) if bad parameter.
    pub fn rte_eth_mirror_rule_reset(port_id: u16, rule_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the rate limitation for a queue on an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_idx
    ///   The queue id.
    /// @param tx_rate
    ///   The tx rate in Mbps. Allocated from the total port link speed.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support this feature.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-EINVAL) if bad parameter.
    pub fn rte_eth_set_queue_rate_limit(
        port_id: u16,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configuration of Receive Side Scaling hash computation of Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param rss_conf
    ///   The new configuration to use for RSS hash computation on the port.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if port identifier is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-EINVAL) if bad parameter.
    pub fn rte_eth_dev_rss_hash_update(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve current configuration of Receive Side Scaling hash computation
    /// of Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param rss_conf
    ///   Where to store the current RSS hash configuration of the Ethernet device.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if port identifier is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if hardware doesn't support RSS.
    pub fn rte_eth_dev_rss_hash_conf_get(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add UDP tunneling port for a specific type of tunnel.
    /// The packets with this UDP port will be identified as this type of tunnel.
    /// Before enabling any offloading function for a tunnel, users can call this API
    /// to change or add more UDP port for the tunnel. So the offloading function
    /// can take effect on the packets with the specific UDP port.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param tunnel_udp
    ///   UDP tunneling configuration.
    ///
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if port identifier is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_udp_tunnel_port_add(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Delete UDP tunneling port a specific type of tunnel.
    /// The packets with this UDP port will not be identified as this type of tunnel
    /// any more.
    /// Before enabling any offloading function for a tunnel, users can call this API
    /// to delete a UDP port for the tunnel. So the offloading function will not take
    /// effect on the packets with the specific UDP port.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param tunnel_udp
    ///   UDP tunneling configuration.
    ///
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if port identifier is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_udp_tunnel_port_delete(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check whether the filter type is supported on an Ethernet device.
    /// All the supported filter types are defined in 'rte_eth_ctrl.h'.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param filter_type
    ///   Filter type.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support this filter type.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    pub fn rte_eth_dev_filter_supported(
        port_id: u16,
        filter_type: rte_filter_type::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Take operations to assigned filter type on an Ethernet device.
    /// All the supported operations and filter types are defined in 'rte_eth_ctrl.h'.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param filter_type
    ///   Filter type.
    /// @param filter_op
    ///   Type of operation.
    /// @param arg
    ///   A pointer to arguments defined specifically for the operation.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - others depends on the specific operations implementation.
    pub fn rte_eth_dev_filter_ctrl(
        port_id: u16,
        filter_type: rte_filter_type::Type,
        filter_op: rte_filter_op::Type,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get DCB information on an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param dcb_info
    ///   dcb information.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if port identifier is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if hardware doesn't support.
    pub fn rte_eth_dev_get_dcb_info(
        port_id: u16,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a callback to be called on packet RX on a given port and queue.
    ///
    /// This API configures a function to be called for each burst of
    /// packets received on a given NIC port queue. The return value is a pointer
    /// that can be used to later remove the callback using
    /// rte_eth_remove_rx_callback().
    ///
    /// Multiple functions are called in the order that they are added.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The queue on the Ethernet device on which the callback is to be added.
    /// @param fn
    ///   The callback function
    /// @param user_param
    ///   A generic pointer parameter which will be passed to each invocation of the
    ///   callback function on this port and queue.
    ///
    /// @return
    ///   NULL on error.
    ///   On success, a pointer value which can later be used to remove the callback.
    pub fn rte_eth_add_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    /// Add a callback that must be called first on packet RX on a given port
    /// and queue.
    ///
    /// This API configures a first function to be called for each burst of
    /// packets received on a given NIC port queue. The return value is a pointer
    /// that can be used to later remove the callback using
    /// rte_eth_remove_rx_callback().
    ///
    /// Multiple functions are called in the order that they are added.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The queue on the Ethernet device on which the callback is to be added.
    /// @param fn
    ///   The callback function
    /// @param user_param
    ///   A generic pointer parameter which will be passed to each invocation of the
    ///   callback function on this port and queue.
    ///
    /// @return
    ///   NULL on error.
    ///   On success, a pointer value which can later be used to remove the callback.
    pub fn rte_eth_add_first_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    /// Add a callback to be called on packet TX on a given port and queue.
    ///
    /// This API configures a function to be called for each burst of
    /// packets sent on a given NIC port queue. The return value is a pointer
    /// that can be used to later remove the callback using
    /// rte_eth_remove_tx_callback().
    ///
    /// Multiple functions are called in the order that they are added.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The queue on the Ethernet device on which the callback is to be added.
    /// @param fn
    ///   The callback function
    /// @param user_param
    ///   A generic pointer parameter which will be passed to each invocation of the
    ///   callback function on this port and queue.
    ///
    /// @return
    ///   NULL on error.
    ///   On success, a pointer value which can later be used to remove the callback.
    pub fn rte_eth_add_tx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_tx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
extern "C" {
    /// Remove an RX packet callback from a given port and queue.
    ///
    /// This function is used to removed callbacks that were added to a NIC port
    /// queue using rte_eth_add_rx_callback().
    ///
    /// Note: the callback is removed from the callback list but it isn't freed
    /// since the it may still be in use. The memory for the callback can be
    /// subsequently freed back by the application by calling rte_free():
    ///
    /// - Immediately - if the port is stopped, or the user knows that no
    ///   callbacks are in flight e.g. if called from the thread doing RX/TX
    ///   on that queue.
    ///
    /// - After a short delay - where the delay is sufficient to allow any
    ///   in-flight callbacks to complete.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The queue on the Ethernet device from which the callback is to be removed.
    /// @param user_cb
    ///   User supplied callback created via rte_eth_add_rx_callback().
    ///
    /// @return
    ///   - 0: Success. Callback was removed.
    ///   - -ENOTSUP: Callback support is not available.
    ///   - -EINVAL:  The port_id or the queue_id is out of range, or the callback
    ///               is NULL or not found for the port/queue.
    pub fn rte_eth_remove_rx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a TX packet callback from a given port and queue.
    ///
    /// This function is used to removed callbacks that were added to a NIC port
    /// queue using rte_eth_add_tx_callback().
    ///
    /// Note: the callback is removed from the callback list but it isn't freed
    /// since the it may still be in use. The memory for the callback can be
    /// subsequently freed back by the application by calling rte_free():
    ///
    /// - Immediately - if the port is stopped, or the user knows that no
    ///   callbacks are in flight e.g. if called from the thread doing RX/TX
    ///   on that queue.
    ///
    /// - After a short delay - where the delay is sufficient to allow any
    ///   in-flight callbacks to complete.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The queue on the Ethernet device from which the callback is to be removed.
    /// @param user_cb
    ///   User supplied callback created via rte_eth_add_tx_callback().
    ///
    /// @return
    ///   - 0: Success. Callback was removed.
    ///   - -ENOTSUP: Callback support is not available.
    ///   - -EINVAL:  The port_id or the queue_id is out of range, or the callback
    ///               is NULL or not found for the port/queue.
    pub fn rte_eth_remove_tx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve information about given port's RX queue.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The RX queue on the Ethernet device for which information
    ///   will be retrieved.
    /// @param qinfo
    ///   A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with
    ///   the information of the Ethernet device.
    ///
    /// @return
    ///   - 0: Success
    ///   - -ENOTSUP: routine is not supported by the device PMD.
    ///   - -EINVAL:  The port_id or the queue_id is out of range.
    pub fn rte_eth_rx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_rxq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve information about given port's TX queue.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param queue_id
    ///   The TX queue on the Ethernet device for which information
    ///   will be retrieved.
    /// @param qinfo
    ///   A pointer to a structure of type *rte_eth_txq_info_info* to be filled with
    ///   the information of the Ethernet device.
    ///
    /// @return
    ///   - 0: Success
    ///   - -ENOTSUP: routine is not supported by the device PMD.
    ///   - -EINVAL:  The port_id or the queue_id is out of range.
    pub fn rte_eth_tx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_txq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve device registers and register attributes (number of registers and
    /// register size)
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param info
    ///   Pointer to rte_dev_reg_info structure to fill in. If info->data is
    ///   NULL the function fills in the width and length fields. If non-NULL
    ///   the registers are put into the buffer pointed at by the data field.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_reg_info(
        port_id: u16,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve size of device EEPROM
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @return
    ///   - (>=0) EEPROM size if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_eeprom_length(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve EEPROM and EEPROM attribute
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param info
    ///   The template includes buffer for return EEPROM data and
    ///   EEPROM attributes to be filled.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Program EEPROM with provided data
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param info
    ///   The template includes EEPROM data for programming and
    ///   EEPROM attributes to be filled
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - others depends on the specific operations implementation.
    pub fn rte_eth_dev_set_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Retrieve the type and size of plugin module EEPROM
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param modinfo
    ///   The type and size of plugin module EEPROM.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_module_info(
        port_id: u16,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice.
    ///
    /// Retrieve the data of plugin module EEPROM
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param info
    ///   The template includes the plugin module EEPROM attributes, and the
    ///   buffer for return plugin module EEPROM data.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP) if hardware doesn't support.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - others depends on the specific operations implementation.
    pub fn rte_eth_dev_get_module_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the list of multicast addresses to filter on an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param mc_addr_set
    ///   The array of multicast addresses to set. Equal to NULL when the function
    ///   is invoked to flush the set of filtered addresses.
    /// @param nb_mc_addr
    ///   The number of multicast addresses in the *mc_addr_set* array. Equal to 0
    ///   when the function is invoked to flush the set of filtered addresses.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if *port_id* invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering.
    ///   - (-ENOSPC) if *port_id* has not enough multicast filtering resources.
    pub fn rte_eth_dev_set_mc_addr_list(
        port_id: u16,
        mc_addr_set: *mut ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable IEEE1588/802.1AS timestamping for an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    ///
    /// @return
    ///   - 0: Success.
    ///   - -ENODEV: The port ID is invalid.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disable IEEE1588/802.1AS timestamping for an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    ///
    /// @return
    ///   - 0: Success.
    ///   - -ENODEV: The port ID is invalid.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read an IEEE1588/802.1AS RX timestamp from an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param timestamp
    ///   Pointer to the timestamp struct.
    /// @param flags
    ///   Device specific flags. Used to pass the RX timesync register index to
    ///   i40e. Unused in igb/ixgbe, pass 0 instead.
    ///
    /// @return
    ///   - 0: Success.
    ///   - -EINVAL: No timestamp is available.
    ///   - -ENODEV: The port ID is invalid.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_read_rx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read an IEEE1588/802.1AS TX timestamp from an Ethernet device.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param timestamp
    ///   Pointer to the timestamp struct.
    ///
    /// @return
    ///   - 0: Success.
    ///   - -EINVAL: No timestamp is available.
    ///   - -ENODEV: The port ID is invalid.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_read_tx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Adjust the timesync clock on an Ethernet device.
    ///
    /// This is usually used in conjunction with other Ethdev timesync functions to
    /// synchronize the device time using the IEEE1588/802.1AS protocol.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param delta
    ///   The adjustment in nanoseconds.
    ///
    /// @return
    ///   - 0: Success.
    ///   - -ENODEV: The port ID is invalid.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_adjust_time(port_id: u16, delta: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read the time from the timesync clock on an Ethernet device.
    ///
    /// This is usually used in conjunction with other Ethdev timesync functions to
    /// synchronize the device time using the IEEE1588/802.1AS protocol.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param time
    ///   Pointer to the timespec struct that holds the time.
    ///
    /// @return
    ///   - 0: Success.
    pub fn rte_eth_timesync_read_time(port_id: u16, time: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the time of the timesync clock on an Ethernet device.
    ///
    /// This is usually used in conjunction with other Ethdev timesync functions to
    /// synchronize the device time using the IEEE1588/802.1AS protocol.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param time
    ///   Pointer to the timespec struct that holds the time.
    ///
    /// @return
    ///   - 0: Success.
    ///   - -EINVAL: No timestamp is available.
    ///   - -ENODEV: The port ID is invalid.
    ///   - -EIO: if device is removed.
    ///   - -ENOTSUP: The function is not supported by the Ethernet driver.
    pub fn rte_eth_timesync_write_time(
        port_id: u16,
        time: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Config l2 tunnel ether type of an Ethernet device for filtering specific
    /// tunnel packets by ether type.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param l2_tunnel
    ///   l2 tunnel configuration.
    ///
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if port identifier is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_l2_tunnel_eth_type_conf(
        port_id: u16,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable/disable l2 tunnel offload functions. Include,
    /// 1, The ability of parsing a type of l2 tunnel of an Ethernet device.
    ///    Filtering, forwarding and offloading this type of tunnel packets depend on
    ///    this ability.
    /// 2, Stripping the l2 tunnel tag.
    /// 3, Insertion of the l2 tunnel tag.
    /// 4, Forwarding the packets based on the l2 tunnel tag.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param l2_tunnel
    ///   l2 tunnel parameters.
    /// @param mask
    ///   Indicate the offload function.
    /// @param en
    ///   Enable or disable this function.
    ///
    /// @return
    ///   - (0) if successful.
    ///   - (-ENODEV) if port identifier is invalid.
    ///   - (-EIO) if device is removed.
    ///   - (-ENOTSUP) if hardware doesn't support tunnel type.
    pub fn rte_eth_dev_l2_tunnel_offload_set(
        port_id: u16,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the port id from device name. The device name should be specified
    /// as below:
    /// - PCIe address (Domain:Bus:Device.Function), for example- 0000:2:00.0
    /// - SoC device name, for example- fsl-gmac0
    /// - vdev dpdk name, for example- net_[pcap0|null0|tap0]
    ///
    /// @param name
    ///  pci address or name of the device
    /// @param port_id
    ///   pointer to port identifier of the device
    /// @return
    ///   - (0) if successful and port_id is filled.
    ///   - (-ENODEV or -EINVAL) on failure.
    pub fn rte_eth_dev_get_port_by_name(
        name: *const ::std::os::raw::c_char,
        port_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the device name from port id. The device name is specified as below:
    /// - PCIe address (Domain:Bus:Device.Function), for example- 0000:02:00.0
    /// - SoC device name, for example- fsl-gmac0
    /// - vdev dpdk name, for example- net_[pcap0|null0|tun0|tap0]
    ///
    /// @param port_id
    ///   Port identifier of the device.
    /// @param name
    ///   Buffer of size RTE_ETH_NAME_MAX_LEN to store the name.
    /// @return
    ///   - (0) if successful.
    ///   - (-EINVAL) on failure.
    pub fn rte_eth_dev_get_name_by_port(
        port_id: u16,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check that numbers of Rx and Tx descriptors satisfy descriptors limits from
    /// the ethernet device information, otherwise adjust them to boundaries.
    ///
    /// @param port_id
    ///   The port identifier of the Ethernet device.
    /// @param nb_rx_desc
    ///   A pointer to a uint16_t where the number of receive
    ///   descriptors stored.
    /// @param nb_tx_desc
    ///   A pointer to a uint16_t where the number of transmit
    ///   descriptors stored.
    /// @return
    ///   - (0) if successful.
    ///   - (-ENOTSUP, -ENODEV or -EINVAL) on failure.
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(
        port_id: u16,
        nb_rx_desc: *mut u16,
        nb_tx_desc: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Test if a port supports specific mempool ops.
    ///
    /// @param port_id
    ///   Port identifier of the Ethernet device.
    /// @param [in] pool
    ///   The name of the pool operations to test.
    /// @return
    ///   - 0: best mempool ops choice for this port.
    ///   - 1: mempool ops are supported for this port.
    ///   - -ENOTSUP: mempool ops not supported for this port.
    ///   - -ENODEV: Invalid port Identifier.
    ///   - -EINVAL: Pool param is null.
    pub fn rte_eth_dev_pool_ops_supported(
        port_id: u16,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the security context for the Ethernet device.
    ///
    /// @param port_id
    ///   Port identifier of the Ethernet device
    /// @return
    ///   - NULL on error.
    ///   - pointer to security context on success.
    pub fn rte_eth_dev_get_sec_ctx(port_id: u16) -> *mut ::std::os::raw::c_void;
}
/// @file
///
/// RTE Ethernet Device internal header.
///
/// This header contains internal data types. But they are still part of the
/// public API because they are used by inline functions in the published API.
///
/// Applications should not use these directly.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
/// @internal Structure to keep track of registered callbacks
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_cb_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_cb_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_cb_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
impl Default for rte_eth_dev_cb_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_stop_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_close_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
/// <@internal Function used to reset a configured Ethernet device.
pub type eth_is_removed_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_link_update_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, wait_to_complete: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int,
>;
pub type eth_stats_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, igb_stats: *mut rte_eth_stats)
        -> ::std::os::raw::c_int,
>;
pub type eth_stats_reset_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_reset_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_names_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        ids: *const u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stats_mapping_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16, stat_idx: u8, is_rx: u8)
        -> ::std::os::raw::c_int,
>;
pub type eth_dev_infos_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, dev_info: *mut rte_eth_dev_info),
>;
pub type eth_dev_supported_ptypes_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> *const u32>;
pub type eth_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_rx_enable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_disable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(queue: *mut ::std::os::raw::c_void)>;
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> u32>;
pub type eth_rx_descriptor_done_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_fw_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_done_cleanup_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, free_cnt: u32) -> ::std::os::raw::c_int,
>;
pub type eth_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, qinfo: *mut rte_eth_rxq_info),
>;
pub type eth_txq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tx_queue_id: u16, qinfo: *mut rte_eth_txq_info),
>;
pub type mtu_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int,
>;
pub type vlan_filter_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, vlan_id: u16, on: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int,
>;
pub type vlan_tpid_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, type_: rte_vlan_type::Type, tpid: u16)
        -> ::std::os::raw::c_int,
>;
pub type vlan_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mask: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int,
>;
pub type vlan_pvid_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, vlan_id: u16, on: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int,
>;
pub type vlan_strip_queue_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, on: ::std::os::raw::c_int),
>;
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type flow_ctrl_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fc_conf: *mut rte_eth_fc_conf)
        -> ::std::os::raw::c_int,
>;
pub type flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, fc_conf: *mut rte_eth_fc_conf)
        -> ::std::os::raw::c_int,
>;
pub type priority_flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, pfc_conf: *mut rte_eth_pfc_conf)
        -> ::std::os::raw::c_int,
>;
pub type reta_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type reta_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type rss_hash_update_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rss_conf: *mut rte_eth_rss_conf)
        -> ::std::os::raw::c_int,
>;
pub type rss_hash_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rss_conf: *mut rte_eth_rss_conf)
        -> ::std::os::raw::c_int,
>;
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, index: u32)>;
pub type eth_mac_addr_add_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mac_addr: *mut ether_addr, index: u32, vmdq: u32)
        -> ::std::os::raw::c_int,
>;
pub type eth_mac_addr_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mac_addr: *mut ether_addr) -> ::std::os::raw::c_int,
>;
pub type eth_uc_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mac_addr: *mut ether_addr, on: u8)
        -> ::std::os::raw::c_int,
>;
pub type eth_uc_all_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8) -> ::std::os::raw::c_int,
>;
pub type eth_set_queue_rate_limit_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_idx: u16, tx_rate: u16)
        -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_reset_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rule_id: u8) -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_add_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tunnel_udp: *mut rte_eth_udp_tunnel)
        -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_del_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tunnel_udp: *mut rte_eth_udp_tunnel)
        -> ::std::os::raw::c_int,
>;
pub type eth_set_mc_addr_list_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mc_addr_set: *mut ether_addr, nb_mc_addr: u32)
        -> ::std::os::raw::c_int,
>;
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_read_rx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec, flags: u32)
        -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_tx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_adjust_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_write_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *const timespec)
        -> ::std::os::raw::c_int,
>;
pub type eth_get_reg_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, info: *mut rte_dev_reg_info)
        -> ::std::os::raw::c_int,
>;
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, info: *mut rte_dev_eeprom_info)
        -> ::std::os::raw::c_int,
>;
pub type eth_set_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, info: *mut rte_dev_eeprom_info)
        -> ::std::os::raw::c_int,
>;
pub type eth_get_module_info_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, modinfo: *mut rte_eth_dev_module_info)
        -> ::std::os::raw::c_int,
>;
pub type eth_get_module_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, info: *mut rte_dev_eeprom_info)
        -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_eth_type_conf_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, l2_tunnel: *mut rte_eth_l2_tunnel_conf)
        -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_filter_ctrl_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        filter_type: rte_filter_type::Type,
        filter_op: rte_filter_op::Type,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tm_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, ops: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
pub type eth_mtr_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, ops: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int,
>;
pub type eth_get_dcb_info = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, dcb_info: *mut rte_eth_dcb_info)
        -> ::std::os::raw::c_int,
>;
pub type eth_pool_ops_supported_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, pool: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int,
>;
/// @internal A structure containing the functions exported by an Ethernet driver.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct eth_dev_ops {
    ///< Configure device.
    pub dev_configure: eth_dev_configure_t,
    ///< Start device.
    pub dev_start: eth_dev_start_t,
    ///< Stop device.
    pub dev_stop: eth_dev_stop_t,
    ///< Device link up.
    pub dev_set_link_up: eth_dev_set_link_up_t,
    ///< Device link down.
    pub dev_set_link_down: eth_dev_set_link_down_t,
    ///< Close device.
    pub dev_close: eth_dev_close_t,
    ///< Reset device.
    pub dev_reset: eth_dev_reset_t,
    ///< Get device link state.
    pub link_update: eth_link_update_t,
    pub is_removed: eth_is_removed_t,
    ///< Promiscuous ON.
    pub promiscuous_enable: eth_promiscuous_enable_t,
    ///< Promiscuous OFF.
    pub promiscuous_disable: eth_promiscuous_disable_t,
    ///< RX multicast ON.
    pub allmulticast_enable: eth_allmulticast_enable_t,
    ///< RX multicast OFF.
    pub allmulticast_disable: eth_allmulticast_disable_t,
    ///< Remove MAC address.
    pub mac_addr_remove: eth_mac_addr_remove_t,
    ///< Add a MAC address.
    pub mac_addr_add: eth_mac_addr_add_t,
    ///< Set a MAC address.
    pub mac_addr_set: eth_mac_addr_set_t,
    ///< set list of mcast addrs.
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    ///< Set MTU.
    pub mtu_set: mtu_set_t,
    ///< Get generic device statistics.
    pub stats_get: eth_stats_get_t,
    ///< Reset generic device statistics.
    pub stats_reset: eth_stats_reset_t,
    ///< Get extended device statistics.
    pub xstats_get: eth_xstats_get_t,
    ///< Reset extended device statistics.
    pub xstats_reset: eth_xstats_reset_t,
    pub xstats_get_names: eth_xstats_get_names_t,
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    ///< Get device info.
    pub dev_infos_get: eth_dev_infos_get_t,
    ///< retrieve RX queue information.
    pub rxq_info_get: eth_rxq_info_get_t,
    ///< retrieve TX queue information.
    pub txq_info_get: eth_txq_info_get_t,
    ///< Get firmware version.
    pub fw_version_get: eth_fw_version_get_t,
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    ///< Filter VLAN Setup.
    pub vlan_filter_set: vlan_filter_set_t,
    ///< Outer/Inner VLAN TPID Setup.
    pub vlan_tpid_set: vlan_tpid_set_t,
    ///< VLAN Stripping on queue.
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    ///< Set VLAN Offload.
    pub vlan_offload_set: vlan_offload_set_t,
    ///< Set port based TX VLAN insertion.
    pub vlan_pvid_set: vlan_pvid_set_t,
    ///< Start RX for a queue.
    pub rx_queue_start: eth_queue_start_t,
    ///< Stop RX for a queue.
    pub rx_queue_stop: eth_queue_stop_t,
    ///< Start TX for a queue.
    pub tx_queue_start: eth_queue_start_t,
    ///< Stop TX for a queue.
    pub tx_queue_stop: eth_queue_stop_t,
    ///< Set up device RX queue.
    pub rx_queue_setup: eth_rx_queue_setup_t,
    ///< Release RX queue.
    pub rx_queue_release: eth_queue_release_t,
    pub rx_queue_count: eth_rx_queue_count_t,
    ///< Check rxd DD bit.
    pub rx_descriptor_done: eth_rx_descriptor_done_t,
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    ///< Enable Rx queue interrupt.
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    ///< Disable Rx queue interrupt.
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    ///< Set up device TX queue.
    pub tx_queue_setup: eth_tx_queue_setup_t,
    ///< Release TX queue.
    pub tx_queue_release: eth_queue_release_t,
    ///< Free tx ring mbufs
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    ///< Turn on LED.
    pub dev_led_on: eth_dev_led_on_t,
    ///< Turn off LED.
    pub dev_led_off: eth_dev_led_off_t,
    ///< Get flow control.
    pub flow_ctrl_get: flow_ctrl_get_t,
    ///< Setup flow control.
    pub flow_ctrl_set: flow_ctrl_set_t,
    ///< Setup priority flow control.
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    ///< Set Unicast Table Array.
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    ///< Set Unicast hash bitmap.
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    ///< Add a traffic mirror rule.
    pub mirror_rule_set: eth_mirror_rule_set_t,
    ///< reset a traffic mirror rule.
    pub mirror_rule_reset: eth_mirror_rule_reset_t,
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    /// Add UDP tunnel port.
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    /// Del UDP tunnel port.
    pub l2_tunnel_eth_type_conf: eth_l2_tunnel_eth_type_conf_t,
    /// Config ether type of l2 tunnel.
    pub l2_tunnel_offload_set: eth_l2_tunnel_offload_set_t,
    ///< Set queue rate limit.
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    pub rss_hash_update: rss_hash_update_t,
    /// Configure RSS hash protocols.
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    /// Get current RSS hash configuration.
    pub reta_update: reta_update_t,
    /// Update redirection table.
    pub reta_query: reta_query_t,
    ///< Get registers.
    pub get_reg: eth_get_reg_t,
    ///< Get eeprom length.
    pub get_eeprom_length: eth_get_eeprom_length_t,
    ///< Get eeprom data.
    pub get_eeprom: eth_get_eeprom_t,
    ///< Set eeprom.
    pub set_eeprom: eth_set_eeprom_t,
    pub get_module_info: eth_get_module_info_t,
    /// Get plugin module eeprom attribute.
    pub get_module_eeprom: eth_get_module_eeprom_t,
    ///< common filter control.
    pub filter_ctrl: eth_filter_ctrl_t,
    pub get_dcb_info: eth_get_dcb_info,
    /// Get DCB information.
    pub timesync_enable: eth_timesync_enable_t,
    /// Turn IEEE1588/802.1AS timestamping on.
    pub timesync_disable: eth_timesync_disable_t,
    /// Turn IEEE1588/802.1AS timestamping off.
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    /// Read the IEEE1588/802.1AS RX timestamp.
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    /// Read the IEEE1588/802.1AS TX timestamp.
    pub timesync_adjust_time: eth_timesync_adjust_time,
    /// Adjust the device clock.
    pub timesync_read_time: eth_timesync_read_time,
    /// Get the device clock time.
    pub timesync_write_time: eth_timesync_write_time,
    /// Set the device clock time.
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    pub tm_ops_get: eth_tm_ops_get_t,
    pub mtr_ops_get: eth_mtr_ops_get_t,
    pub pool_ops_supported: eth_pool_ops_supported_t,
}
#[test]
fn bindgen_test_layout_eth_dev_ops() {
    assert_eq!(
        ::std::mem::size_of::<eth_dev_ops>(),
        696usize,
        concat!("Size of: ", stringify!(eth_dev_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<eth_dev_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(eth_dev_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_configure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_stop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_set_link_up as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_set_link_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_set_link_down as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_set_link_down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_reset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).link_update as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(link_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).is_removed as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(is_removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).promiscuous_enable as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(promiscuous_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).promiscuous_disable as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(promiscuous_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).allmulticast_enable as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(allmulticast_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).allmulticast_disable as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(allmulticast_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_remove as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_add as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_set as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).set_mc_addr_list as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_mc_addr_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mtu_set as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mtu_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).stats_get as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(stats_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).stats_reset as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(stats_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_reset as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_names as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).queue_stats_mapping_set as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(queue_stats_mapping_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_infos_get as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_infos_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rxq_info_get as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rxq_info_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).txq_info_get as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(txq_info_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).fw_version_get as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(fw_version_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).dev_supported_ptypes_get as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_supported_ptypes_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_filter_set as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_filter_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_tpid_set as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_tpid_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).vlan_strip_queue_set as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_strip_queue_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_offload_set as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_offload_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_pvid_set as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_pvid_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_start as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_stop as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_start as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_stop as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_setup as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_release as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_count as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_descriptor_done as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_descriptor_done)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_descriptor_status as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).tx_descriptor_status as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_intr_enable as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_intr_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_intr_disable as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_intr_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_setup as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_release as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_done_cleanup as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_done_cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_led_on as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_led_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_led_off as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_led_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).flow_ctrl_get as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(flow_ctrl_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).flow_ctrl_set as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(flow_ctrl_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).priority_flow_ctrl_set as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(priority_flow_ctrl_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).uc_hash_table_set as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(uc_hash_table_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).uc_all_hash_table_set as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(uc_all_hash_table_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mirror_rule_set as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mirror_rule_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mirror_rule_reset as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mirror_rule_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).udp_tunnel_port_add as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(udp_tunnel_port_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).udp_tunnel_port_del as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(udp_tunnel_port_del)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).l2_tunnel_eth_type_conf as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(l2_tunnel_eth_type_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).l2_tunnel_offload_set as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(l2_tunnel_offload_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).set_queue_rate_limit as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_queue_rate_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rss_hash_update as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rss_hash_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rss_hash_conf_get as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rss_hash_conf_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).reta_update as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(reta_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).reta_query as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(reta_query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_reg as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_eeprom_length as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_eeprom_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_eeprom as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).set_eeprom as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_module_info as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_module_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_module_eeprom as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_module_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).filter_ctrl as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(filter_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_dcb_info as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_dcb_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_enable as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_disable as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_disable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_rx_timestamp as *const _ as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_rx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_tx_timestamp as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_tx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_adjust_time as *const _ as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_adjust_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_time as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_write_time as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_write_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_by_id as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_by_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_names_by_id as *const _ as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_names_by_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tm_ops_get as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tm_ops_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mtr_ops_get as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mtr_ops_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).pool_ops_supported as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(pool_ops_supported)
        )
    );
}
impl Default for eth_dev_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// @internal
/// Structure used to hold information about the callbacks to be called for a
/// queue on RX and TX.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).rx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).tx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(tx)
        )
    );
}
impl Default for rte_eth_rxtx_callback__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).fn_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(param)
        )
    );
}
impl Default for rte_eth_rxtx_callback {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// @internal
/// The generic data structure associated with each ethernet device.
///
/// Pointers to burst-oriented packet receive and transmit functions are
/// located at the beginning of the structure, along with the pointer to
/// where all the data elements for the particular device are stored in shared
/// memory. This split allows the function pointer and driver data to be per-
/// process, while the actual configuration data for the device is shared.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev {
    ///< Pointer to PMD receive function.
    pub rx_pkt_burst: eth_rx_burst_t,
    ///< Pointer to PMD transmit function.
    pub tx_pkt_burst: eth_tx_burst_t,
    ///< Pointer to PMD transmit prepare function.
    pub tx_pkt_prepare: eth_tx_prep_t,
    ///< Pointer to device data.
    pub data: *mut rte_eth_dev_data,
    ///< Pointer to per-process device data.
    pub process_private: *mut ::std::os::raw::c_void,
    ///< Functions exported by PMD
    pub dev_ops: *const eth_dev_ops,
    ///< Backing device
    pub device: *mut rte_device,
    ///< Device interrupt handle
    pub intr_handle: *mut rte_intr_handle,
    /// User application callbacks for NIC interrupts
    pub link_intr_cbs: rte_eth_dev_cb_list,
    /// User-supplied functions called from rx_burst to post-process
    /// received packets before passing them to the user
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    /// User-supplied functions called from tx_burst to pre-process
    /// received packets before passing them to the driver for transmission.
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    ///< Flag indicating the port state
    pub state: rte_eth_dev_state::Type,
    ///< Context for security ops
    pub security_ctx: *mut ::std::os::raw::c_void,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev>(),
        16512usize,
        concat!("Size of: ", stringify!(rte_eth_dev))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).rx_pkt_burst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(rx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_burst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_prepare as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).process_private as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(process_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).dev_ops as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(dev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).device as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).intr_handle as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(intr_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).link_intr_cbs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(link_intr_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).post_rx_burst_cbs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(post_rx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).pre_tx_burst_cbs as *const _ as usize },
        8272usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(pre_tx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).state as *const _ as usize },
        16464usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).security_ctx as *const _ as usize },
        16472usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(security_ctx)
        )
    );
}
impl Default for rte_eth_dev {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// @internal
/// The data part, with no function pointers, associated with each ethernet device.
///
/// This structure is safe to place in shared memory to be common among different
/// processes in a multi-process configuration.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    ///< Unique identifier name
    pub name: [::std::os::raw::c_char; 64usize],
    ///< Array of pointers to RX queues.
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    ///< Array of pointers to TX queues.
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    ///< Number of RX queues.
    pub nb_rx_queues: u16,
    ///< Number of TX queues.
    pub nb_tx_queues: u16,
    ///< SRIOV data
    pub sriov: rte_eth_dev_sriov,
    pub dev_private: *mut ::std::os::raw::c_void,
    ///< Link-level information & status.
    pub dev_link: rte_eth_link,
    ///< Configuration applied to device.
    pub dev_conf: rte_eth_conf,
    ///< Maximum Transmission Unit.
    pub mtu: u16,
    pub min_rx_buf_size: u32,
    ///< RX ring mbuf allocation failures.
    pub rx_mbuf_alloc_failed: u64,
    pub mac_addrs: *mut ether_addr,
    pub mac_pool_sel: [u64; 128usize],
    pub hash_mac_addrs: *mut ether_addr,
    ///< Device [external] port identifier.
    pub port_id: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rx_queue_state: [u8; 1024usize],
    pub tx_queue_state: [u8; 1024usize],
    ///< Capabilities.
    pub dev_flags: u32,
    ///< Kernel driver passthrough.
    pub kdrv: rte_kernel_driver::Type,
    ///< NUMA node connection.
    pub numa_node: ::std::os::raw::c_int,
    pub vlan_filter_conf: rte_vlan_filter_conf,
    ///< The port owner.
    pub owner: rte_eth_dev_owner,
    pub representor_id: u16,
    pub __bindgen_padding_0: [u16; 15usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_data>(),
        6848usize,
        concat!("Size of: ", stringify!(rte_eth_dev_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queues as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queues as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_rx_queues as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_tx_queues as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).sriov as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(sriov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_private as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_link as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_conf as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mtu as *const _ as usize },
        3112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).min_rx_buf_size as *const _ as usize
        },
        3116usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(min_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_mbuf_alloc_failed as *const _ as usize
        },
        3120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_mbuf_alloc_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_addrs as *const _ as usize },
        3128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_pool_sel as *const _ as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_pool_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).hash_mac_addrs as *const _ as usize },
        4160usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).port_id as *const _ as usize },
        4168usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queue_state as *const _ as usize },
        4171usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queue_state as *const _ as usize },
        5195usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_flags as *const _ as usize },
        6220usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).kdrv as *const _ as usize },
        6224usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(kdrv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).numa_node as *const _ as usize },
        6228usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).vlan_filter_conf as *const _ as usize
        },
        6232usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(vlan_filter_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).owner as *const _ as usize },
        6744usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).representor_id as *const _ as usize },
        6816usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(representor_id)
        )
    );
}
impl Default for rte_eth_dev_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}rte_eth_devices"]
    pub static mut rte_eth_devices: [rte_eth_dev; 0usize];
}
pub mod rte_kni_req_id {
    pub type Type = u32;
    pub const RTE_KNI_REQ_UNKNOWN: Type = 0;
    pub const RTE_KNI_REQ_CHANGE_MTU: Type = 1;
    pub const RTE_KNI_REQ_CFG_NETWORK_IF: Type = 2;
    pub const RTE_KNI_REQ_CHANGE_MAC_ADDR: Type = 3;
    pub const RTE_KNI_REQ_CHANGE_PROMISC: Type = 4;
    pub const RTE_KNI_REQ_MAX: Type = 5;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_kni_request {
    ///< Request id
    pub req_id: u32,
    pub __bindgen_anon_1: rte_kni_request__bindgen_ty_1,
    ///< Result for processing request
    pub result: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_kni_request__bindgen_ty_1 {
    ///< New MTU
    pub new_mtu: u32,
    ///< 1: interface up, 0: interface down
    pub if_up: u8,
    ///< MAC address for interface
    pub mac_addr: [u8; 6usize],
    ///< 1: promisc mode enable, 0: disable
    pub promiscusity: u8,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_rte_kni_request__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_request__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_kni_request__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_request__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_kni_request__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).new_mtu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(new_mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).if_up as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(if_up)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).mac_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_kni_request__bindgen_ty_1>())).promiscusity as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request__bindgen_ty_1),
            "::",
            stringify!(promiscusity)
        )
    );
}
impl Default for rte_kni_request__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rte_kni_request() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_request>(),
        16usize,
        concat!("Size of: ", stringify!(rte_kni_request))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_request>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_kni_request))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request>())).req_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request),
            "::",
            stringify!(req_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_request>())).result as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_request),
            "::",
            stringify!(result)
        )
    );
}
impl Default for rte_kni_request {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rte_kni_fifo {
    ///< Next position to be written
    pub write: ::std::os::raw::c_uint,
    ///< Next position to be read
    pub read: ::std::os::raw::c_uint,
    ///< Circular buffer length
    pub len: ::std::os::raw::c_uint,
    ///< Pointer size - for 32/64 bit OS
    pub elem_size: ::std::os::raw::c_uint,
    ///< The buffer contains mbuf pointers
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_kni_fifo() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_fifo>(),
        16usize,
        concat!("Size of: ", stringify!(rte_kni_fifo))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_fifo>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_fifo))
    );
}
impl Default for rte_kni_fifo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_kni_mbuf {
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub buf_physaddr: u64,
    ///< Start address of data in segment buffer.
    pub data_off: u16,
    pub pad1: [::std::os::raw::c_char; 2usize],
    ///< Number of segments.
    pub nb_segs: u16,
    pub pad4: [::std::os::raw::c_char; 2usize],
    ///< Offload features.
    pub ol_flags: u64,
    pub pad2: [::std::os::raw::c_char; 4usize],
    ///< Total pkt len: sum of all segment data_len.
    pub pkt_len: u32,
    ///< Amount of data in segment buffer.
    pub data_len: u16,
    pub __bindgen_padding_0: [u8; 22usize],
    pub pad3: [::std::os::raw::c_char; 8usize],
    pub pool: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub __bindgen_padding_1: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_rte_kni_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_kni_mbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).buf_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).buf_physaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(buf_physaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).data_off as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).nb_segs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(nb_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad4 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).ol_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pkt_len as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).data_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pad3 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).pool as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_mbuf>())).next as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_mbuf),
            "::",
            stringify!(next)
        )
    );
}
impl Default for rte_kni_mbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_kni_device_info {
    ///< Network device name for KNI
    pub name: [::std::os::raw::c_char; 32usize],
    pub tx_phys: phys_addr_t,
    pub rx_phys: phys_addr_t,
    pub alloc_phys: phys_addr_t,
    pub free_phys: phys_addr_t,
    pub req_phys: phys_addr_t,
    pub resp_phys: phys_addr_t,
    pub sync_phys: phys_addr_t,
    pub sync_va: *mut ::std::os::raw::c_void,
    pub mbuf_va: *mut ::std::os::raw::c_void,
    pub mbuf_phys: phys_addr_t,
    ///< Vendor ID or PCI_ANY_ID.
    pub vendor_id: u16,
    ///< Device ID or PCI_ANY_ID.
    pub device_id: u16,
    ///< Device bus
    pub bus: u8,
    ///< Device ID
    pub devid: u8,
    ///< Device function.
    pub function: u8,
    ///< Group ID
    pub group_id: u16,
    ///< core ID to bind for kernel thread
    pub core_id: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub mtu: ::std::os::raw::c_uint,
    pub mac_addr: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_rte_kni_device_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_device_info>(),
        152usize,
        concat!("Size of: ", stringify!(rte_kni_device_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_device_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_device_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).tx_phys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(tx_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).rx_phys as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(rx_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).alloc_phys as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(alloc_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).free_phys as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(free_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).req_phys as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(req_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).resp_phys as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(resp_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).sync_phys as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(sync_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).sync_va as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(sync_va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_va as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_phys as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_phys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).vendor_id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).device_id as *const _ as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).bus as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).devid as *const _ as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).function as *const _ as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).group_id as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).core_id as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mbuf_size as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mtu as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_device_info>())).mac_addr as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_device_info),
            "::",
            stringify!(mac_addr)
        )
    );
}
impl Default for rte_kni_device_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl rte_kni_device_info {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_kni {
    _unused: [u8; 0],
}
/// Structure which has the function pointers for KNI interface.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rte_kni_ops {
    pub port_id: u16,
    pub change_mtu: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, new_mtu: ::std::os::raw::c_uint)
            -> ::std::os::raw::c_int,
    >,
    pub config_network_if: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, if_up: u8) -> ::std::os::raw::c_int,
    >,
    pub config_mac_address: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, mac_addr: *mut u8) -> ::std::os::raw::c_int,
    >,
    pub config_promiscusity: ::std::option::Option<
        unsafe extern "C" fn(port_id: u16, to_on: u8) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rte_kni_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_ops>(),
        40usize,
        concat!("Size of: ", stringify!(rte_kni_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).port_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).change_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(change_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_network_if as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_network_if)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_mac_address as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_mac_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_ops>())).config_promiscusity as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_ops),
            "::",
            stringify!(config_promiscusity)
        )
    );
}
impl Default for rte_kni_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Structure for configuring KNI device.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_kni_conf {
    pub name: [::std::os::raw::c_char; 32usize],
    pub core_id: u32,
    pub group_id: u16,
    pub mbuf_size: ::std::os::raw::c_uint,
    pub addr: rte_pci_addr,
    pub id: rte_pci_id,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub mac_addr: [::std::os::raw::c_char; 6usize],
    pub mtu: u16,
}
#[test]
fn bindgen_test_layout_rte_kni_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_conf>(),
        76usize,
        concat!("Size of: ", stringify!(rte_kni_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_kni_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).core_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).group_id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mbuf_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mbuf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).addr as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).id as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mac_addr as *const _ as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_kni_conf>())).mtu as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_kni_conf),
            "::",
            stringify!(mtu)
        )
    );
}
impl rte_kni_conf {
    #[inline]
    pub fn force_bind(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_bind(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(force_bind: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_bind: u8 = unsafe { ::std::mem::transmute(force_bind) };
            force_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    /// Initialize and preallocate KNI subsystem
    ///
    /// This function is to be executed on the MASTER lcore only, after EAL
    /// initialization and before any KNI interface is attempted to be
    /// allocated
    ///
    /// @param max_kni_ifaces
    ///  The maximum number of KNI interfaces that can coexist concurrently
    ///
    /// @return
    ///  - 0 indicates success.
    ///  - negative value indicates failure.
    pub fn rte_kni_init(max_kni_ifaces: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Allocate KNI interface according to the port id, mbuf size, mbuf pool,
    /// configurations and callbacks for kernel requests.The KNI interface created
    /// in the kernel space is the net interface the traditional Linux application
    /// talking to.
    ///
    /// The rte_kni_alloc shall not be called before rte_kni_init() has been
    /// called. rte_kni_alloc is thread safe.
    ///
    /// The mempool should have capacity of more than "2 x KNI_FIFO_COUNT_MAX"
    /// elements for each KNI interface allocated.
    ///
    /// @param pktmbuf_pool
    ///  The mempool for allocating mbufs for packets.
    /// @param conf
    ///  The pointer to the configurations of the KNI device.
    /// @param ops
    ///  The pointer to the callbacks for the KNI kernel requests.
    ///
    /// @return
    ///  - The pointer to the context of a KNI interface.
    ///  - NULL indicate error.
    pub fn rte_kni_alloc(
        pktmbuf_pool: *mut rte_mempool,
        conf: *const rte_kni_conf,
        ops: *mut rte_kni_ops,
    ) -> *mut rte_kni;
}
extern "C" {
    /// Release KNI interface according to the context. It will also release the
    /// paired KNI interface in kernel space. All processing on the specific KNI
    /// context need to be stopped before calling this interface.
    ///
    /// rte_kni_release is thread safe.
    ///
    /// @param kni
    ///  The pointer to the context of an existent KNI interface.
    ///
    /// @return
    ///  - 0 indicates success.
    ///  - negative value indicates failure.
    pub fn rte_kni_release(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    /// It is used to handle the request mbufs sent from kernel space.
    /// Then analyzes it and calls the specific actions for the specific requests.
    /// Finally constructs the response mbuf and puts it back to the resp_q.
    ///
    /// @param kni
    ///  The pointer to the context of an existent KNI interface.
    ///
    /// @return
    ///  - 0
    ///  - negative value indicates failure.
    pub fn rte_kni_handle_request(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Retrieve a burst of packets from a KNI interface. The retrieved packets are
    /// stored in rte_mbuf structures whose pointers are supplied in the array of
    /// mbufs, and the maximum number is indicated by num. It handles allocating
    /// the mbufs for KNI interface alloc queue.
    ///
    /// @param kni
    ///  The KNI interface context.
    /// @param mbufs
    ///  The array to store the pointers of mbufs.
    /// @param num
    ///  The maximum number per burst.
    ///
    /// @return
    ///  The actual number of packets retrieved.
    pub fn rte_kni_rx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Send a burst of packets to a KNI interface. The packets to be sent out are
    /// stored in rte_mbuf structures whose pointers are supplied in the array of
    /// mbufs, and the maximum number is indicated by num. It handles the freeing of
    /// the mbufs in the free queue of KNI interface.
    ///
    /// @param kni
    ///  The KNI interface context.
    /// @param mbufs
    ///  The array to store the pointers of mbufs.
    /// @param num
    ///  The maximum number per burst.
    ///
    /// @return
    ///  The actual number of packets sent.
    pub fn rte_kni_tx_burst(
        kni: *mut rte_kni,
        mbufs: *mut *mut rte_mbuf,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// Get the KNI context of its name.
    ///
    /// @param name
    ///  pointer to the KNI device name.
    ///
    /// @return
    ///  On success: Pointer to KNI interface.
    ///  On failure: NULL.
    pub fn rte_kni_get(name: *const ::std::os::raw::c_char) -> *mut rte_kni;
}
extern "C" {
    /// Get the name given to a KNI device
    ///
    /// @param kni
    ///   The KNI instance to query
    /// @return
    ///   The pointer to the KNI name
    pub fn rte_kni_get_name(kni: *const rte_kni) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Register KNI request handling for a specified port,and it can
    /// be called by master process or slave process.
    ///
    /// @param kni
    ///  pointer to struct rte_kni.
    /// @param ops
    ///  pointer to struct rte_kni_ops.
    ///
    /// @return
    ///  On success: 0
    ///  On failure: -1
    pub fn rte_kni_register_handlers(
        kni: *mut rte_kni,
        ops: *mut rte_kni_ops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Unregister KNI request handling for a specified port.
    ///
    ///  @param kni
    ///   pointer to struct rte_kni.
    ///
    ///  @return
    ///   On success: 0
    ///   On failure: -1
    pub fn rte_kni_unregister_handlers(kni: *mut rte_kni) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Update link carrier state for KNI port.
    ///
    /// Update the linkup/linkdown state of a KNI interface in the kernel.
    ///
    /// @param kni
    ///  pointer to struct rte_kni.
    /// @param linkup
    ///  New link state:
    ///  0 for linkdown.
    ///  > 0 for linkup.
    ///
    /// @return
    ///  On failure: -1
    ///  Previous link state == linkdown: 0
    ///  Previous link state == linkup: 1
    pub fn rte_kni_update_link(
        kni: *mut rte_kni,
        linkup: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    ///  Close KNI device.
    pub fn rte_kni_close();
}
extern "C" {
    /// Create a bonded rte_eth_dev device
    ///
    /// @param name			Name of new link bonding device.
    /// @param mode			Mode to initialize bonding device in.
    /// @param socket_id		Socket Id on which to allocate eth_dev resources.
    ///
    /// @return
    ///	Port Id of created rte_eth_dev on success, negative value otherwise
    pub fn rte_eth_bond_create(
        name: *const ::std::os::raw::c_char,
        mode: u8,
        socket_id: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Free a bonded rte_eth_dev device
    ///
    /// @param name			Name of the link bonding device.
    ///
    /// @return
    ///	0 on success, negative value otherwise
    pub fn rte_eth_bond_free(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a rte_eth_dev device as a slave to the bonded device
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param slave_port_id		Port ID of slave device.
    ///
    /// @return
    ///	0 on success, negative value otherwise
    pub fn rte_eth_bond_slave_add(bonded_port_id: u16, slave_port_id: u16)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a slave rte_eth_dev device from the bonded device
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param slave_port_id		Port ID of slave device.
    ///
    /// @return
    ///	0 on success, negative value otherwise
    pub fn rte_eth_bond_slave_remove(
        bonded_port_id: u16,
        slave_port_id: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set link bonding mode of bonded device
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param mode				Bonding mode to set
    ///
    /// @return
    ///	0 on success, negative value otherwise
    pub fn rte_eth_bond_mode_set(bonded_port_id: u16, mode: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get link bonding mode of bonded device
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    ///
    /// @return
    ///	link bonding mode on success, negative value otherwise
    pub fn rte_eth_bond_mode_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set slave rte_eth_dev as primary slave of bonded device
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param slave_port_id		Port ID of slave device.
    ///
    /// @return
    ///	0 on success, negative value otherwise
    pub fn rte_eth_bond_primary_set(
        bonded_port_id: u16,
        slave_port_id: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get primary slave of bonded device
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    ///
    /// @return
    ///	Port Id of primary slave on success, -1 on failure
    pub fn rte_eth_bond_primary_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Populate an array with list of the slaves port id's of the bonded device
    ///
    /// @param bonded_port_id	Port ID of bonded eth_dev to interrogate
    /// @param slaves			Array to be populated with the current active slaves
    /// @param len				Length of slaves array
    ///
    /// @return
    ///	Number of slaves associated with bonded device on success,
    ///	negative value otherwise
    pub fn rte_eth_bond_slaves_get(
        bonded_port_id: u16,
        slaves: *mut u16,
        len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Populate an array with list of the active slaves port id's of the bonded
    /// device.
    ///
    /// @param bonded_port_id	Port ID of bonded eth_dev to interrogate
    /// @param slaves			Array to be populated with the current active slaves
    /// @param len				Length of slaves array
    ///
    /// @return
    ///	Number of active slaves associated with bonded device on success,
    ///	negative value otherwise
    pub fn rte_eth_bond_active_slaves_get(
        bonded_port_id: u16,
        slaves: *mut u16,
        len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set explicit MAC address to use on bonded device and it's slaves.
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param mac_addr			MAC Address to use on bonded device overriding
    ///							slaves MAC addresses
    ///
    /// @return
    ///	0 on success, negative value otherwise
    pub fn rte_eth_bond_mac_address_set(
        bonded_port_id: u16,
        mac_addr: *mut ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Reset bonded device to use MAC from primary slave on bonded device and it's
    /// slaves.
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    ///
    /// @return
    ///	0 on success, negative value otherwise
    pub fn rte_eth_bond_mac_address_reset(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the transmit policy for bonded device to use when it is operating in
    /// balance mode, this parameter is otherwise ignored in other modes of
    /// operation.
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param policy			Balance mode transmission policy.
    ///
    /// @return
    ///	0 on success, negative value otherwise.
    pub fn rte_eth_bond_xmit_policy_set(bonded_port_id: u16, policy: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the transmit policy set on bonded device for balance mode operation
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    ///
    /// @return
    ///	Balance transmit policy on success, negative value otherwise.
    pub fn rte_eth_bond_xmit_policy_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the link monitoring frequency (in ms) for monitoring the link status of
    /// slave devices
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param internal_ms		Monitoring interval in milliseconds
    ///
    /// @return
    ///	0 on success, negative value otherwise.
    pub fn rte_eth_bond_link_monitoring_set(
        bonded_port_id: u16,
        internal_ms: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current link monitoring frequency (in ms) for monitoring of the link
    /// status of slave devices
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    ///
    /// @return
    ///	Monitoring interval on success, negative value otherwise.
    pub fn rte_eth_bond_link_monitoring_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the period in milliseconds for delaying the disabling of a bonded link
    /// when the link down status has been detected
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param delay_ms			Delay period in milliseconds.
    ///
    /// @return
    ///  0 on success, negative value otherwise.
    pub fn rte_eth_bond_link_down_prop_delay_set(
        bonded_port_id: u16,
        delay_ms: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the period in milliseconds set for delaying the disabling of a bonded
    /// link when the link down status has been detected
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    ///
    /// @return
    ///  Delay period on success, negative value otherwise.
    pub fn rte_eth_bond_link_down_prop_delay_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the period in milliseconds for delaying the enabling of a bonded link
    /// when the link up status has been detected
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    /// @param delay_ms			Delay period in milliseconds.
    ///
    /// @return
    ///  0 on success, negative value otherwise.
    pub fn rte_eth_bond_link_up_prop_delay_set(
        bonded_port_id: u16,
        delay_ms: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the period in milliseconds set for delaying the enabling of a bonded
    /// link when the link up status has been detected
    ///
    /// @param bonded_port_id	Port ID of bonded device.
    ///
    /// @return
    ///  Delay period on success, negative value otherwise.
    pub fn rte_eth_bond_link_up_prop_delay_get(bonded_port_id: u16) -> ::std::os::raw::c_int;
}
/// ARP header IPv4 payload.
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct arp_ipv4 {
    ///< sender hardware address
    pub arp_sha: ether_addr,
    ///< sender IP address
    pub arp_sip: u32,
    ///< target hardware address
    pub arp_tha: ether_addr,
    ///< target IP address
    pub arp_tip: u32,
}
#[test]
fn bindgen_test_layout_arp_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<arp_ipv4>(),
        20usize,
        concat!("Size of: ", stringify!(arp_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<arp_ipv4>(),
        1usize,
        concat!("Alignment of ", stringify!(arp_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_ipv4>())).arp_sha as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_ipv4),
            "::",
            stringify!(arp_sha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_ipv4>())).arp_sip as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_ipv4),
            "::",
            stringify!(arp_sip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_ipv4>())).arp_tha as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_ipv4),
            "::",
            stringify!(arp_tha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_ipv4>())).arp_tip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_ipv4),
            "::",
            stringify!(arp_tip)
        )
    );
}
/// ARP header.
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct arp_hdr {
    pub arp_hrd: u16,
    pub arp_pro: u16,
    pub arp_hln: u8,
    pub arp_pln: u8,
    pub arp_op: u16,
    pub arp_data: arp_ipv4,
}
#[test]
fn bindgen_test_layout_arp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<arp_hdr>(),
        28usize,
        concat!("Size of: ", stringify!(arp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<arp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(arp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_hdr>())).arp_hrd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_hdr),
            "::",
            stringify!(arp_hrd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_hdr>())).arp_pro as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_hdr),
            "::",
            stringify!(arp_pro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_hdr>())).arp_hln as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_hdr),
            "::",
            stringify!(arp_hln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_hdr>())).arp_pln as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_hdr),
            "::",
            stringify!(arp_pln)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_hdr>())).arp_op as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_hdr),
            "::",
            stringify!(arp_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arp_hdr>())).arp_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arp_hdr),
            "::",
            stringify!(arp_data)
        )
    );
}
extern "C" {
    /// @warning
    /// @b EXPERIMENTAL: this API may change without prior notice
    ///
    /// Make a RARP packet based on MAC addr.
    ///
    /// @param mpool
    ///   Pointer to the rte_mempool
    /// @param mac
    ///   Pointer to the MAC addr
    ///
    /// @return
    ///   - RARP packet pointer on success, or NULL on error
    pub fn rte_net_make_rarp_packet(
        mpool: *mut rte_mempool,
        mac: *const ether_addr,
    ) -> *mut rte_mbuf;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type socklen_t = __socklen_t;
pub mod __socket_type {
    pub type Type = u32;
    pub const SOCK_STREAM: Type = 1;
    pub const SOCK_DGRAM: Type = 2;
    pub const SOCK_RAW: Type = 3;
    pub const SOCK_RDM: Type = 4;
    pub const SOCK_SEQPACKET: Type = 5;
    pub const SOCK_DCCP: Type = 6;
    pub const SOCK_PACKET: Type = 10;
    pub const SOCK_CLOEXEC: Type = 524288;
    pub const SOCK_NONBLOCK: Type = 2048;
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod _bindgen_ty_14 {
    pub type Type = u32;
    pub const MSG_OOB: Type = 1;
    pub const MSG_PEEK: Type = 2;
    pub const MSG_DONTROUTE: Type = 4;
    pub const MSG_CTRUNC: Type = 8;
    pub const MSG_PROXY: Type = 16;
    pub const MSG_TRUNC: Type = 32;
    pub const MSG_DONTWAIT: Type = 64;
    pub const MSG_EOR: Type = 128;
    pub const MSG_WAITALL: Type = 256;
    pub const MSG_FIN: Type = 512;
    pub const MSG_SYN: Type = 1024;
    pub const MSG_CONFIRM: Type = 2048;
    pub const MSG_RST: Type = 4096;
    pub const MSG_ERRQUEUE: Type = 8192;
    pub const MSG_NOSIGNAL: Type = 16384;
    pub const MSG_MORE: Type = 32768;
    pub const MSG_WAITFORONE: Type = 65536;
    pub const MSG_BATCH: Type = 262144;
    pub const MSG_ZEROCOPY: Type = 67108864;
    pub const MSG_FASTOPEN: Type = 536870912;
    pub const MSG_CMSG_CLOEXEC: Type = 1073741824;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub mod _bindgen_ty_15 {
    pub type Type = u32;
    pub const SCM_RIGHTS: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub mod _bindgen_ty_16 {
    pub type Type = u32;
    pub const SHUT_RD: Type = 0;
    pub const SHUT_WR: Type = 1;
    pub const SHUT_RDWR: Type = 2;
}
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
impl Default for ip_opts {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
pub mod _bindgen_ty_17 {
    pub type Type = u32;
    pub const IPPROTO_IP: Type = 0;
    pub const IPPROTO_ICMP: Type = 1;
    pub const IPPROTO_IGMP: Type = 2;
    pub const IPPROTO_IPIP: Type = 4;
    pub const IPPROTO_TCP: Type = 6;
    pub const IPPROTO_EGP: Type = 8;
    pub const IPPROTO_PUP: Type = 12;
    pub const IPPROTO_UDP: Type = 17;
    pub const IPPROTO_IDP: Type = 22;
    pub const IPPROTO_TP: Type = 29;
    pub const IPPROTO_DCCP: Type = 33;
    pub const IPPROTO_IPV6: Type = 41;
    pub const IPPROTO_RSVP: Type = 46;
    pub const IPPROTO_GRE: Type = 47;
    pub const IPPROTO_ESP: Type = 50;
    pub const IPPROTO_AH: Type = 51;
    pub const IPPROTO_MTP: Type = 92;
    pub const IPPROTO_BEETPH: Type = 94;
    pub const IPPROTO_ENCAP: Type = 98;
    pub const IPPROTO_PIM: Type = 103;
    pub const IPPROTO_COMP: Type = 108;
    pub const IPPROTO_SCTP: Type = 132;
    pub const IPPROTO_UDPLITE: Type = 136;
    pub const IPPROTO_MPLS: Type = 137;
    pub const IPPROTO_RAW: Type = 255;
    pub const IPPROTO_MAX: Type = 256;
}
pub mod _bindgen_ty_18 {
    pub type Type = u32;
    pub const IPPROTO_HOPOPTS: Type = 0;
    pub const IPPROTO_ROUTING: Type = 43;
    pub const IPPROTO_FRAGMENT: Type = 44;
    pub const IPPROTO_ICMPV6: Type = 58;
    pub const IPPROTO_NONE: Type = 59;
    pub const IPPROTO_DSTOPTS: Type = 60;
    pub const IPPROTO_MH: Type = 135;
}
pub type in_port_t = u16;
pub mod _bindgen_ty_19 {
    pub type Type = u32;
    pub const IPPORT_ECHO: Type = 7;
    pub const IPPORT_DISCARD: Type = 9;
    pub const IPPORT_SYSTAT: Type = 11;
    pub const IPPORT_DAYTIME: Type = 13;
    pub const IPPORT_NETSTAT: Type = 15;
    pub const IPPORT_FTP: Type = 21;
    pub const IPPORT_TELNET: Type = 23;
    pub const IPPORT_SMTP: Type = 25;
    pub const IPPORT_TIMESERVER: Type = 37;
    pub const IPPORT_NAMESERVER: Type = 42;
    pub const IPPORT_WHOIS: Type = 43;
    pub const IPPORT_MTP: Type = 57;
    pub const IPPORT_TFTP: Type = 69;
    pub const IPPORT_RJE: Type = 77;
    pub const IPPORT_FINGER: Type = 79;
    pub const IPPORT_TTYLINK: Type = 87;
    pub const IPPORT_SUPDUP: Type = 95;
    pub const IPPORT_EXECSERVER: Type = 512;
    pub const IPPORT_LOGINSERVER: Type = 513;
    pub const IPPORT_CMDSERVER: Type = 514;
    pub const IPPORT_EFSSERVER: Type = 520;
    pub const IPPORT_BIFFUDP: Type = 512;
    pub const IPPORT_WHOSERVER: Type = 513;
    pub const IPPORT_ROUTESERVER: Type = 520;
    pub const IPPORT_RESERVED: Type = 1024;
    pub const IPPORT_USERRESERVED: Type = 5000;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
impl Default for group_req {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
impl Default for group_source_req {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
impl Default for group_filter {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
/// IPv4 Header
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ipv4_hdr {
    ///< version and header length
    pub version_ihl: u8,
    ///< type of service
    pub type_of_service: u8,
    ///< length of packet
    pub total_length: u16,
    ///< packet ID
    pub packet_id: u16,
    ///< fragmentation offset
    pub fragment_offset: u16,
    ///< time to live
    pub time_to_live: u8,
    ///< protocol ID
    pub next_proto_id: u8,
    ///< header checksum
    pub hdr_checksum: u16,
    ///< source address
    pub src_addr: u32,
    ///< destination address
    pub dst_addr: u32,
}
#[test]
fn bindgen_test_layout_ipv4_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ipv4_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(ipv4_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv4_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ipv4_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).version_ihl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(version_ihl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).type_of_service as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(type_of_service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).total_length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).packet_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(packet_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).fragment_offset as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(fragment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).time_to_live as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(time_to_live)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).next_proto_id as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(next_proto_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).hdr_checksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(hdr_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).src_addr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv4_hdr>())).dst_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv4_hdr),
            "::",
            stringify!(dst_addr)
        )
    );
}
/// IPv6 Header
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct ipv6_hdr {
    ///< IP version, traffic class & flow label.
    pub vtc_flow: u32,
    ///< IP packet length - includes sizeof(ip_header).
    pub payload_len: u16,
    ///< Protocol, next header.
    pub proto: u8,
    ///< Hop limits.
    pub hop_limits: u8,
    ///< IP address of source host.
    pub src_addr: [u8; 16usize],
    ///< IP address of destination host(s).
    pub dst_addr: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ipv6_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_hdr>(),
        40usize,
        concat!("Size of: ", stringify!(ipv6_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ipv6_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_hdr>())).vtc_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_hdr),
            "::",
            stringify!(vtc_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_hdr>())).payload_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_hdr),
            "::",
            stringify!(payload_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_hdr>())).proto as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_hdr),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_hdr>())).hop_limits as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_hdr),
            "::",
            stringify!(hop_limits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_hdr>())).src_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_hdr),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_hdr>())).dst_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_hdr),
            "::",
            stringify!(dst_addr)
        )
    );
}
/// ICMP Header
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: u16,
    pub icmp_ident: u16,
    pub icmp_seq_nb: u16,
}
#[test]
fn bindgen_test_layout_icmp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<icmp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(icmp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<icmp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(icmp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_hdr>())).icmp_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_hdr),
            "::",
            stringify!(icmp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_hdr>())).icmp_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_hdr),
            "::",
            stringify!(icmp_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_hdr>())).icmp_cksum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_hdr),
            "::",
            stringify!(icmp_cksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_hdr>())).icmp_ident as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_hdr),
            "::",
            stringify!(icmp_ident)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<icmp_hdr>())).icmp_seq_nb as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(icmp_hdr),
            "::",
            stringify!(icmp_seq_nb)
        )
    );
}
/// TCP Header
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct tcp_hdr {
    ///< TCP source port.
    pub src_port: u16,
    ///< TCP destination port.
    pub dst_port: u16,
    ///< TX data sequence number.
    pub sent_seq: u32,
    ///< RX data acknowledgement sequence number.
    pub recv_ack: u32,
    ///< Data offset.
    pub data_off: u8,
    ///< TCP flags
    pub tcp_flags: u8,
    ///< RX flow control window.
    pub rx_win: u16,
    ///< TCP checksum.
    pub cksum: u16,
    ///< TCP urgent pointer, if any.
    pub tcp_urp: u16,
}
#[test]
fn bindgen_test_layout_tcp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<tcp_hdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(tcp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).sent_seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(sent_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).recv_ack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(recv_ack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).data_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).tcp_flags as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).rx_win as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(rx_win)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).cksum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(cksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tcp_hdr>())).tcp_urp as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_hdr),
            "::",
            stringify!(tcp_urp)
        )
    );
}
/// UDP Header
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct udp_hdr {
    ///< UDP source port.
    pub src_port: u16,
    ///< UDP destination port.
    pub dst_port: u16,
    ///< UDP datagram length
    pub dgram_len: u16,
    ///< UDP datagram checksum
    pub dgram_cksum: u16,
}
#[test]
fn bindgen_test_layout_udp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<udp_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(udp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<udp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(udp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<udp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(udp_hdr),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<udp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(udp_hdr),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<udp_hdr>())).dgram_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(udp_hdr),
            "::",
            stringify!(dgram_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<udp_hdr>())).dgram_cksum as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(udp_hdr),
            "::",
            stringify!(dgram_cksum)
        )
    );
}
/// SCTP Header
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct sctp_hdr {
    ///< Source port.
    pub src_port: u16,
    ///< Destin port.
    pub dst_port: u16,
    ///< Validation tag.
    pub tag: u32,
    ///< Checksum.
    pub cksum: u32,
}
#[test]
fn bindgen_test_layout_sctp_hdr() {
    assert_eq!(
        ::std::mem::size_of::<sctp_hdr>(),
        12usize,
        concat!("Size of: ", stringify!(sctp_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<sctp_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(sctp_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sctp_hdr>())).src_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sctp_hdr),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sctp_hdr>())).dst_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sctp_hdr),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sctp_hdr>())).tag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sctp_hdr),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sctp_hdr>())).cksum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sctp_hdr),
            "::",
            stringify!(cksum)
        )
    );
}
/// This structure is the header of a cirbuf type.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cirbuf {
    ///< total len of the fifo (number of elements)
    pub maxlen: ::std::os::raw::c_uint,
    ///< indice of the first elt
    pub start: ::std::os::raw::c_uint,
    ///< indice of the last elt
    pub end: ::std::os::raw::c_uint,
    ///< current len of fifo
    pub len: ::std::os::raw::c_uint,
    pub buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cirbuf() {
    assert_eq!(
        ::std::mem::size_of::<cirbuf>(),
        24usize,
        concat!("Size of: ", stringify!(cirbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<cirbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(cirbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).maxlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cirbuf),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).start as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cirbuf),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cirbuf),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cirbuf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cirbuf>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cirbuf),
            "::",
            stringify!(buf)
        )
    );
}
impl Default for cirbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Init the circular buffer
    pub fn cirbuf_init(
        cbuf: *mut cirbuf,
        buf: *mut ::std::os::raw::c_char,
        start: ::std::os::raw::c_uint,
        maxlen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a character at head of the circular buffer. Return 0 on success, or
    /// a negative value on error.
    pub fn cirbuf_add_head_safe(
        cbuf: *mut cirbuf,
        c: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a character at head of the circular buffer. You _must_ check that you
    /// have enough free space in the buffer before calling this func.
    pub fn cirbuf_add_head(cbuf: *mut cirbuf, c: ::std::os::raw::c_char);
}
extern "C" {
    /// Add a character at tail of the circular buffer. Return 0 on success, or
    /// a negative value on error.
    pub fn cirbuf_add_tail_safe(
        cbuf: *mut cirbuf,
        c: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a character at tail of the circular buffer. You _must_ check that you
    /// have enough free space in the buffer before calling this func.
    pub fn cirbuf_add_tail(cbuf: *mut cirbuf, c: ::std::os::raw::c_char);
}
extern "C" {
    /// Remove a char at the head of the circular buffer. Return 0 on
    /// success, or a negative value on error.
    pub fn cirbuf_del_head_safe(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a char at the head of the circular buffer. You _must_ check
    /// that buffer is not empty before calling the function.
    pub fn cirbuf_del_head(cbuf: *mut cirbuf);
}
extern "C" {
    /// Remove a char at the tail of the circular buffer. Return 0 on
    /// success, or a negative value on error.
    pub fn cirbuf_del_tail_safe(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove a char at the tail of the circular buffer. You _must_ check
    /// that buffer is not empty before calling the function.
    pub fn cirbuf_del_tail(cbuf: *mut cirbuf);
}
extern "C" {
    /// Return the head of the circular buffer. You _must_ check that
    /// buffer is not empty before calling the function.
    pub fn cirbuf_get_head(cbuf: *mut cirbuf) -> ::std::os::raw::c_char;
}
extern "C" {
    /// Return the tail of the circular buffer. You _must_ check that
    /// buffer is not empty before calling the function.
    pub fn cirbuf_get_tail(cbuf: *mut cirbuf) -> ::std::os::raw::c_char;
}
extern "C" {
    /// Add a buffer at head of the circular buffer. 'c' is a pointer to a
    /// buffer, and n is the number of char to add. Return the number of
    /// copied bytes on success, or a negative value on error.
    pub fn cirbuf_add_buf_head(
        cbuf: *mut cirbuf,
        c: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add a buffer at tail of the circular buffer. 'c' is a pointer to a
    /// buffer, and n is the number of char to add. Return the number of
    /// copied bytes on success, or a negative value on error.
    pub fn cirbuf_add_buf_tail(
        cbuf: *mut cirbuf,
        c: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove chars at the head of the circular buffer. Return 0 on
    /// success, or a negative value on error.
    pub fn cirbuf_del_buf_head(
        cbuf: *mut cirbuf,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Remove chars at the tail of the circular buffer. Return 0 on
    /// success, or a negative value on error.
    pub fn cirbuf_del_buf_tail(
        cbuf: *mut cirbuf,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Copy a maximum of 'size' characters from the head of the circular
    /// buffer to a flat one pointed by 'c'. Return the number of copied
    /// chars.
    pub fn cirbuf_get_buf_head(
        cbuf: *mut cirbuf,
        c: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Copy a maximum of 'size' characters from the tail of the circular
    /// buffer to a flat one pointed by 'c'. Return the number of copied
    /// chars.
    pub fn cirbuf_get_buf_tail(
        cbuf: *mut cirbuf,
        c: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the start of the data to the index 0 of the internal buffer.
    pub fn cirbuf_align_left(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the end of the data to the last index of the internal buffer.
    pub fn cirbuf_align_right(cbuf: *mut cirbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}cmdline_vt100_commands"]
    pub static mut cmdline_vt100_commands: [*const ::std::os::raw::c_char; 0usize];
}
pub mod cmdline_vt100_parser_state {
    pub type Type = u32;
    pub const CMDLINE_VT100_INIT: Type = 0;
    pub const CMDLINE_VT100_ESCAPE: Type = 1;
    pub const CMDLINE_VT100_ESCAPE_CSI: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_vt100 {
    pub bufpos: u8,
    pub buf: [::std::os::raw::c_char; 8usize],
    pub state: cmdline_vt100_parser_state::Type,
}
#[test]
fn bindgen_test_layout_cmdline_vt100() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_vt100>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_vt100))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_vt100>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_vt100))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_vt100>())).bufpos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_vt100),
            "::",
            stringify!(bufpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_vt100>())).buf as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_vt100),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_vt100>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_vt100),
            "::",
            stringify!(state)
        )
    );
}
impl Default for cmdline_vt100 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Init
    pub fn vt100_init(vt: *mut cmdline_vt100);
}
extern "C" {
    /// Input a new character.
    /// Return -1 if the character is not part of a control sequence
    /// Return -2 if c is not the last char of a control sequence
    /// Else return the index in vt100_commands[]
    pub fn vt100_parser(vt: *mut cmdline_vt100, c: ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
pub mod rdline_status {
    pub type Type = u32;
    pub const RDLINE_INIT: Type = 0;
    pub const RDLINE_RUNNING: Type = 1;
    pub const RDLINE_EXITED: Type = 2;
}
pub type rdline_write_char_t = ::std::option::Option<
    unsafe extern "C" fn(rdl: *mut rdline, arg1: ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
pub type rdline_validate_t = ::std::option::Option<
    unsafe extern "C" fn(
        rdl: *mut rdline,
        buf: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ),
>;
pub type rdline_complete_t = ::std::option::Option<
    unsafe extern "C" fn(
        rdl: *mut rdline,
        buf: *const ::std::os::raw::c_char,
        dstbuf: *mut ::std::os::raw::c_char,
        dstsize: ::std::os::raw::c_uint,
        state: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdline {
    pub status: rdline_status::Type,
    pub left: cirbuf,
    pub right: cirbuf,
    pub left_buf: [::std::os::raw::c_char; 514usize],
    pub right_buf: [::std::os::raw::c_char; 512usize],
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub prompt_size: ::std::os::raw::c_uint,
    pub kill_buf: [::std::os::raw::c_char; 512usize],
    pub kill_size: ::std::os::raw::c_uint,
    pub history: cirbuf,
    pub history_buf: [::std::os::raw::c_char; 8192usize],
    pub history_cur_line: ::std::os::raw::c_int,
    pub write_char: rdline_write_char_t,
    pub validate: rdline_validate_t,
    pub complete: rdline_complete_t,
    pub vt100: cmdline_vt100,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rdline() {
    assert_eq!(
        ::std::mem::size_of::<rdline>(),
        9912usize,
        concat!("Size of: ", stringify!(rdline))
    );
    assert_eq!(
        ::std::mem::align_of::<rdline>(),
        8usize,
        concat!("Alignment of ", stringify!(rdline))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).left as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).right as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).left_buf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(left_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).right_buf as *const _ as usize },
        570usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(right_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).prompt as *const _ as usize },
        1082usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(prompt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).prompt_size as *const _ as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(prompt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).kill_buf as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(kill_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).kill_size as *const _ as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(kill_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).history as *const _ as usize },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(history)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).history_buf as *const _ as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(history_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).history_cur_line as *const _ as usize },
        9856usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(history_cur_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).write_char as *const _ as usize },
        9864usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(write_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).validate as *const _ as usize },
        9872usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).complete as *const _ as usize },
        9880usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).vt100 as *const _ as usize },
        9888usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(vt100)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdline>())).opaque as *const _ as usize },
        9904usize,
        concat!(
            "Offset of field: ",
            stringify!(rdline),
            "::",
            stringify!(opaque)
        )
    );
}
impl Default for rdline {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    /// Init fields for a struct rdline. Call this only once at the beginning
    /// of your program.
    /// \param rdl A pointer to an uninitialized struct rdline
    /// \param write_char The function used by the function to write a character
    /// \param validate A pointer to the function to execute when the
    ///                 user validates the buffer.
    /// \param complete A pointer to the function to execute when the
    ///                 user completes the buffer.
    pub fn rdline_init(
        rdl: *mut rdline,
        write_char: rdline_write_char_t,
        validate: rdline_validate_t,
        complete: rdline_complete_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Init the current buffer, and display a prompt.
    /// \param rdl A pointer to a struct rdline
    /// \param prompt A string containing the prompt
    pub fn rdline_newline(rdl: *mut rdline, prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    /// Call it and all received chars will be ignored.
    /// \param rdl A pointer to a struct rdline
    pub fn rdline_stop(rdl: *mut rdline);
}
extern "C" {
    /// Same than rdline_stop() except that next calls to rdline_char_in()
    /// will return RDLINE_RES_EXITED.
    /// \param rdl A pointer to a struct rdline
    pub fn rdline_quit(rdl: *mut rdline);
}
extern "C" {
    /// Restart after a call to rdline_stop() or rdline_quit()
    /// \param rdl A pointer to a struct rdline
    pub fn rdline_restart(rdl: *mut rdline);
}
extern "C" {
    /// Redisplay the current buffer
    /// \param rdl A pointer to a struct rdline
    pub fn rdline_redisplay(rdl: *mut rdline);
}
extern "C" {
    /// Reset the current buffer and setup for a new line.
    ///  \param rdl A pointer to a struct rdline
    pub fn rdline_reset(rdl: *mut rdline);
}
extern "C" {
    /// append a char to the readline buffer.
    /// Return RDLINE_RES_VALIDATE when the line has been validated.
    /// Return RDLINE_RES_COMPLETE when the user asked to complete the buffer.
    /// Return RDLINE_RES_NOT_RUNNING if it is not running.
    /// Return RDLINE_RES_EOF if EOF (ctrl-d on an empty line).
    /// Else return RDLINE_RES_SUCCESS.
    /// XXX error case when the buffer is full ?
    ///
    /// \param rdl A pointer to a struct rdline
    /// \param c The character to append
    pub fn rdline_char_in(rdl: *mut rdline, c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the current buffer, terminated by '\0'.
    /// \param rdl A pointer to a struct rdline
    pub fn rdline_get_buffer(rdl: *mut rdline) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Add the buffer to history.
    /// return < 0 on error.
    /// \param rdl A pointer to a struct rdline
    /// \param buf A buffer that is terminated by '\0'
    pub fn rdline_add_history(
        rdl: *mut rdline,
        buf: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Clear current history
    /// \param rdl A pointer to a struct rdline
    pub fn rdline_clear_history(rdl: *mut rdline);
}
extern "C" {
    /// Get the i-th history item
    pub fn rdline_get_history_item(
        rdl: *mut rdline,
        i: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
/// Stores a pointer to the ops struct, and the offset: the place to
/// write the parsed result in the destination structure.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_hdr {
    pub ops: *mut cmdline_token_ops,
    pub offset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cmdline_token_hdr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_token_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_hdr>())).ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_hdr),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_hdr>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_hdr),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for cmdline_token_hdr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_hdr_t = cmdline_token_hdr;
/// A token is defined by this structure.
///
/// parse() takes the token as first argument, then the source buffer
/// starting at the token we want to parse. The 3rd arg is a pointer
/// where we store the parsed data (as binary). It returns the number of
/// parsed chars on success and a negative value on error.
///
/// complete_get_nb() returns the number of possible values for this
/// token if completion is possible. If it is NULL or if it returns 0,
/// no completion is possible.
///
/// complete_get_elt() copy in dstbuf (the size is specified in the
/// parameter) the i-th possible completion for this token.  returns 0
/// on success or and a negative value on error.
///
/// get_help() fills the dstbuf with the help for the token. It returns
/// -1 on error and 0 on success.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_ops {
    /// parse(token ptr, buf, res pts, buf len)
    pub parse: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cmdline_parse_token_hdr_t,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_void,
            arg4: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    /// return the num of possible choices for this token
    pub complete_get_nb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut cmdline_parse_token_hdr_t) -> ::std::os::raw::c_int,
    >,
    /// return the elt x for this token (token, idx, dstbuf, size)
    pub complete_get_elt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cmdline_parse_token_hdr_t,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    /// get help for this token (token, dstbuf, size)
    pub get_help: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cmdline_parse_token_hdr_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_cmdline_token_ops() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_ops>(),
        32usize,
        concat!("Size of: ", stringify!(cmdline_token_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ops>())).parse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cmdline_token_ops>())).complete_get_nb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(complete_get_nb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cmdline_token_ops>())).complete_get_elt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(complete_get_elt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ops>())).get_help as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ops),
            "::",
            stringify!(get_help)
        )
    );
}
impl Default for cmdline_token_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Store a instruction, which is a pointer to a callback function and
/// its parameter that is called when the instruction is parsed, a help
/// string, and a list of token composing this instruction.
///
/// When no tokens are defined (tokens[0] == NULL), they are retrieved
/// dynamically by calling f() as follows:
///
/// @code
///
/// f((struct cmdline_token_hdr **)&token_p,
///   NULL,
///   (struct cmdline_token_hdr **)&inst->tokens[num]);
///
/// @endcode
///
/// The address of the resulting token is expected at the location pointed by
/// the first argument. Can be set to NULL to end the list.
///
/// The cmdline argument (struct cmdline *) is always NULL.
///
/// The last argument points to the inst->tokens[] entry to retrieve, which
/// is not necessarily inside allocated memory and should neither be read nor
/// written. Its sole purpose is to deduce the token entry index of interest
/// as described in the example below.
///
/// Note about constraints:
///
/// - Only the address of these tokens is dynamic, their storage should be
///   static like normal tokens.
/// - Dynamic token lists that need to maintain an internal context (e.g. in
///   order to determine the next token) must store it statically also. This
///   context must be reinitialized when the first token is requested, that
///   is, when &inst->tokens[0] is provided as the third argument.
/// - Dynamic token lists must be NULL-terminated to generate usable
///   commands.
///
/// @code
///
/// // Assuming first and third arguments are respectively named "token_p"
/// // and "token":
///
/// int index = token - inst->tokens;
///
/// if (!index) {
///     [...] // Clean up internal context if any.
/// }
/// [...] // Then set up dyn_token according to index.
///
/// if (no_more_tokens)
///     *token_p = NULL;
/// else
///     *token_p = &dyn_token;
///
/// @endcode
#[repr(C)]
#[derive(Debug)]
pub struct cmdline_inst {
    pub f: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut cmdline,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    pub data: *mut ::std::os::raw::c_void,
    pub help_str: *const ::std::os::raw::c_char,
    pub tokens: __IncompleteArrayField<*mut cmdline_parse_token_hdr_t>,
}
#[test]
fn bindgen_test_layout_cmdline_inst() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_inst>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_inst))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_inst>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_inst))
    );
}
impl Default for cmdline_inst {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_inst_t = cmdline_inst;
/// A context is identified by its name, and contains a list of
/// instruction
///
pub type cmdline_parse_ctx_t = *mut cmdline_parse_inst_t;
extern "C" {
    /// Try to parse a buffer according to the specified context. The
    /// argument buf must ends with "\n\0". The function returns
    /// CMDLINE_PARSE_AMBIGUOUS, CMDLINE_PARSE_NOMATCH or
    /// CMDLINE_PARSE_BAD_ARGS on error. Else it calls the associated
    /// function (defined in the context) and returns 0
    /// (CMDLINE_PARSE_SUCCESS).
    pub fn cmdline_parse(
        cl: *mut cmdline,
        buf: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// complete() must be called with *state==0 (try to complete) or
    /// with *state==-1 (just display choices), then called without
    /// modifying *state until it returns CMDLINE_PARSE_COMPLETED_BUFFER or
    /// CMDLINE_PARSE_COMPLETED_BUFFER.
    ///
    /// It returns < 0 on error.
    ///
    /// Else it returns:
    ///   - CMDLINE_PARSE_COMPLETED_BUFFER on completion (one possible
    ///     choice). In this case, the chars are appended in dst buffer.
    ///   - CMDLINE_PARSE_COMPLETE_AGAIN if there is several possible
    ///     choices. In this case, you must call the function again,
    ///     keeping the value of state intact.
    ///   - CMDLINE_PARSE_COMPLETED_BUFFER when the iteration is
    ///     finished. The dst is not valid for this last call.
    ///
    /// The returned dst buf ends with \0.
    pub fn cmdline_complete(
        cl: *mut cmdline,
        buf: *const ::std::os::raw::c_char,
        state: *mut ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendoftoken(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_isendofcommand(c: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_etheraddr {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_etheraddr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_etheraddr>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_token_etheraddr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_etheraddr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_etheraddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_etheraddr>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_etheraddr),
            "::",
            stringify!(hdr)
        )
    );
}
impl Default for cmdline_token_etheraddr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_etheraddr_t = cmdline_token_etheraddr;
extern "C" {
    #[link_name = "\u{1}cmdline_token_etheraddr_ops"]
    pub static mut cmdline_token_etheraddr_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_etheraddr(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_etheraddr(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmdline_ipaddr {
    pub family: u8,
    pub addr: cmdline_ipaddr__bindgen_ty_1,
    pub prefixlen: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmdline_ipaddr__bindgen_ty_1 {
    pub ipv4: in_addr,
    pub ipv6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_ipaddr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_ipaddr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_ipaddr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_ipaddr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cmdline_ipaddr__bindgen_ty_1>())).ipv4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cmdline_ipaddr__bindgen_ty_1>())).ipv6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr__bindgen_ty_1),
            "::",
            stringify!(ipv6)
        )
    );
}
impl Default for cmdline_ipaddr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_cmdline_ipaddr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_ipaddr>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_ipaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_ipaddr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_ipaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr>())).addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_ipaddr>())).prefixlen as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_ipaddr),
            "::",
            stringify!(prefixlen)
        )
    );
}
impl Default for cmdline_ipaddr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_ipaddr_t = cmdline_ipaddr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cmdline_token_ipaddr_data {
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr_data() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_ipaddr_data>(),
        1usize,
        concat!("Size of: ", stringify!(cmdline_token_ipaddr_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_ipaddr_data>(),
        1usize,
        concat!("Alignment of ", stringify!(cmdline_token_ipaddr_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ipaddr_data>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ipaddr_data),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_ipaddr {
    pub hdr: cmdline_token_hdr,
    pub ipaddr_data: cmdline_token_ipaddr_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_ipaddr() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_ipaddr>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_token_ipaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_ipaddr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_ipaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_ipaddr>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ipaddr),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cmdline_token_ipaddr>())).ipaddr_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_ipaddr),
            "::",
            stringify!(ipaddr_data)
        )
    );
}
impl Default for cmdline_token_ipaddr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_ipaddr_t = cmdline_token_ipaddr;
extern "C" {
    #[link_name = "\u{1}cmdline_token_ipaddr_ops"]
    pub static mut cmdline_token_ipaddr_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_ipaddr(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_ipaddr(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub mod cmdline_numtype {
    pub type Type = u32;
    pub const UINT8: Type = 0;
    pub const UINT16: Type = 1;
    pub const UINT32: Type = 2;
    pub const UINT64: Type = 3;
    pub const INT8: Type = 4;
    pub const INT16: Type = 5;
    pub const INT32: Type = 6;
    pub const INT64: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_num_data {
    pub type_: cmdline_numtype::Type,
}
#[test]
fn bindgen_test_layout_cmdline_token_num_data() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_num_data>(),
        4usize,
        concat!("Size of: ", stringify!(cmdline_token_num_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_num_data>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_token_num_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_num_data>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_num_data),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for cmdline_token_num_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_num {
    pub hdr: cmdline_token_hdr,
    pub num_data: cmdline_token_num_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_num() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_num>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_token_num))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_num>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_num))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_num>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_num),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_num>())).num_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_num),
            "::",
            stringify!(num_data)
        )
    );
}
impl Default for cmdline_token_num {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_num_t = cmdline_token_num;
extern "C" {
    #[link_name = "\u{1}cmdline_token_num_ops"]
    pub static mut cmdline_token_num_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_num(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_num(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct cmdline_portlist {
    pub map: u32,
}
#[test]
fn bindgen_test_layout_cmdline_portlist() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_portlist>(),
        4usize,
        concat!("Size of: ", stringify!(cmdline_portlist))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_portlist>(),
        4usize,
        concat!("Alignment of ", stringify!(cmdline_portlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_portlist>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_portlist),
            "::",
            stringify!(map)
        )
    );
}
pub type cmdline_portlist_t = cmdline_portlist;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_portlist {
    pub hdr: cmdline_token_hdr,
}
#[test]
fn bindgen_test_layout_cmdline_token_portlist() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_portlist>(),
        16usize,
        concat!("Size of: ", stringify!(cmdline_token_portlist))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_portlist>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_portlist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_portlist>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_portlist),
            "::",
            stringify!(hdr)
        )
    );
}
impl Default for cmdline_token_portlist {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_portlist_t = cmdline_token_portlist;
extern "C" {
    #[link_name = "\u{1}cmdline_token_portlist_ops"]
    pub static mut cmdline_token_portlist_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_portlist(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_portlist(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type cmdline_fixed_string_t = [::std::os::raw::c_char; 128usize];
pub type cmdline_multi_string_t = [::std::os::raw::c_char; 4096usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_string_data {
    pub str: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cmdline_token_string_data() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_string_data>(),
        8usize,
        concat!("Size of: ", stringify!(cmdline_token_string_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_string_data>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_string_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_string_data>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_string_data),
            "::",
            stringify!(str)
        )
    );
}
impl Default for cmdline_token_string_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct cmdline_token_string {
    pub hdr: cmdline_token_hdr,
    pub string_data: cmdline_token_string_data,
}
#[test]
fn bindgen_test_layout_cmdline_token_string() {
    assert_eq!(
        ::std::mem::size_of::<cmdline_token_string>(),
        24usize,
        concat!("Size of: ", stringify!(cmdline_token_string))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline_token_string>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline_token_string))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline_token_string>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_string),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cmdline_token_string>())).string_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline_token_string),
            "::",
            stringify!(string_data)
        )
    );
}
impl Default for cmdline_token_string {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type cmdline_parse_token_string_t = cmdline_token_string;
extern "C" {
    #[link_name = "\u{1}cmdline_token_string_ops"]
    pub static mut cmdline_token_string_ops: cmdline_token_ops;
}
extern "C" {
    pub fn cmdline_parse_string(
        tk: *mut cmdline_parse_token_hdr_t,
        srcbuf: *const ::std::os::raw::c_char,
        res: *mut ::std::os::raw::c_void,
        ressize: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_nb_string(
        tk: *mut cmdline_parse_token_hdr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_complete_get_elt_string(
        tk: *mut cmdline_parse_token_hdr_t,
        idx: ::std::os::raw::c_int,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_get_help_string(
        tk: *mut cmdline_parse_token_hdr_t,
        dstbuf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_uint;
pub type tcflag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        60usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        4usize,
        concat!("Alignment of ", stringify!(termios))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_iflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_iflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_oflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_oflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cflag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_lflag as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_lflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_cc as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ispeed as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ispeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<termios>())).c_ospeed as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ospeed)
        )
    );
}
extern "C" {
    pub fn cfgetospeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetispeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetospeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetispeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetspeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetattr(
        __fd: ::std::os::raw::c_int,
        __termios_p: *mut termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsetattr(
        __fd: ::std::os::raw::c_int,
        __optional_actions: ::std::os::raw::c_int,
        __termios_p: *const termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfmakeraw(__termios_p: *mut termios);
}
extern "C" {
    pub fn tcsendbreak(
        __fd: ::std::os::raw::c_int,
        __duration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcdrain(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflush(
        __fd: ::std::os::raw::c_int,
        __queue_selector: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflow(
        __fd: ::std::os::raw::c_int,
        __action: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetsid(__fd: ::std::os::raw::c_int) -> __pid_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmdline {
    pub s_in: ::std::os::raw::c_int,
    pub s_out: ::std::os::raw::c_int,
    pub ctx: *mut cmdline_parse_ctx_t,
    pub rdl: rdline,
    pub prompt: [::std::os::raw::c_char; 32usize],
    pub oldterm: termios,
}
#[test]
fn bindgen_test_layout_cmdline() {
    assert_eq!(
        ::std::mem::size_of::<cmdline>(),
        10024usize,
        concat!("Size of: ", stringify!(cmdline))
    );
    assert_eq!(
        ::std::mem::align_of::<cmdline>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdline))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).s_in as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline),
            "::",
            stringify!(s_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).s_out as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline),
            "::",
            stringify!(s_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).rdl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline),
            "::",
            stringify!(rdl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).prompt as *const _ as usize },
        9928usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline),
            "::",
            stringify!(prompt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmdline>())).oldterm as *const _ as usize },
        9960usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdline),
            "::",
            stringify!(oldterm)
        )
    );
}
impl Default for cmdline {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn cmdline_new(
        ctx: *mut cmdline_parse_ctx_t,
        prompt: *const ::std::os::raw::c_char,
        s_in: ::std::os::raw::c_int,
        s_out: ::std::os::raw::c_int,
    ) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_set_prompt(cl: *mut cmdline, prompt: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cmdline_free(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_printf(cl: *const cmdline, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn cmdline_in(
        cl: *mut cmdline,
        buf: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_write_char(rdl: *mut rdline, c: ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function is nonblocking equivalent of ``cmdline_interact()``. It polls
    /// *cl* for one character and interpret it. If return value is *RDLINE_EXITED*
    /// it mean that ``cmdline_quit()`` was invoked.
    ///
    /// @param cl
    ///   The command line object.
    ///
    /// @return
    ///   On success return object status - one of *enum rdline_status*.
    ///   On error return negative value.
    pub fn cmdline_poll(cl: *mut cmdline) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cmdline_interact(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_quit(cl: *mut cmdline);
}
extern "C" {
    pub fn cmdline_file_new(
        ctx: *mut cmdline_parse_ctx_t,
        prompt: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_new(
        ctx: *mut cmdline_parse_ctx_t,
        prompt: *const ::std::os::raw::c_char,
    ) -> *mut cmdline;
}
extern "C" {
    pub fn cmdline_stdin_exit(cl: *mut cmdline);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
///< class handle.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct rte_class {
    pub _address: u8,
}
