#[macro_use]
extern crate log;
#[macro_use]
extern crate lazy_static;
extern crate num_cpus;
extern crate pretty_env_logger;

#[cfg(feature = "gen")]
extern crate bindgen;
#[cfg(feature = "gen")]
extern crate itertools;
#[cfg(feature = "gen")]
extern crate raw_cpuid;

use std::env;
use std::env::consts::*;
use std::fs::File;
use std::io::prelude::*;
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::str::FromStr;

fn build_dpdk(rte_sdk: &Path, rte_target: &str) {
    let debug_mode = env::var("DEBUG")
        .map(|s| s.parse().unwrap_or_default())
        .unwrap_or_default();

    info!(
        "building {} mode DPDK {} @ {:?}",
        if debug_mode { "debug" } else { "release" },
        rte_target,
        rte_sdk
    );

    Command::new("make")
        .arg("install")
        .arg(format!("T={}", rte_target))
        .args(&["-j", &num_cpus::get().to_string()])
        .env("CONFIG_RTE_BUILD_COMBINE_LIBS", "y")
        .env(
            "EXTRA_CFLAGS",
            if debug_mode {
                "-fPIC -O0 -g -ggdb"
            } else {
                "-fPIC -O"
            },
        ).current_dir(rte_sdk)
        .status()
        .unwrap_or_else(|e| panic!("failed to build DPDK: {}", e));
}

// fn gen_cargo_config(rte_sdk_dir: &PathBuf) {
//     let libs = vec![
//         "ethdev",
//         "rte_acl",
//         "rte_cfgfile",
//         "rte_cmdline",
//         "rte_cryptodev",
//         "rte_distributor",
//         "rte_eal",
//         "rte_hash",
//         "rte_ip_frag",
//         "rte_jobstats",
//         "rte_kni",
//         "rte_kvargs",
//         "rte_lpm",
//         "rte_mbuf",
//         "rte_mempool",
//         "rte_meter",
//         "rte_pipeline",
//         "rte_port",
//         "rte_ring",
//         "rte_table",
//         "rte_timer",
//         "rte_vhost",
//     ];

//     for lib in libs {
//         println!("cargo:rustc-link-lib=static={}", lib);
//     }

//     println!(
//         "cargo:rustc-link-search=native={}",
//         rte_sdk_dir.join("lib").to_str().unwrap()
//     );
//     println!(
//         "cargo:include={}",
//         rte_sdk_dir.join("include").to_str().unwrap()
//     );
// }

fn gen_rte_config(rte_sdk_dir: &Path, dest_path: &Path) {
    let config_file = rte_sdk_dir.join(".config");

    info!("generating DPDK config base on {:?}", config_file);

    let mut f = File::create(&dest_path).unwrap();

    writeln!(
        &mut f,
        "/* automatically generated by {} v{}, DON'T EDIT IT */\n",
        env::var("CARGO_PKG_NAME").unwrap(),
        env::var("CARGO_PKG_VERSION").unwrap(),
    );

    let r = BufReader::new(File::open(&config_file).expect("RTE config file"));

    for line in r.lines().flat_map(|line| line) {
        if line.starts_with("#") {
            writeln!(&mut f, "///{}", &line[1..]);
        } else {
            let mut i = line.splitn(2, "=");
            let key = i.next().expect("key");
            let value = i.next().expect("value");

            match value {
                "" => {
                    writeln!(&mut f, "pub const {}: () = ();", key);
                }
                "y" => {
                    writeln!(&mut f, "pub const {}: bool = true;", key);
                }
                "n" => {
                    writeln!(&mut f, "pub const {}: bool = false;", key);
                }
                s if s.starts_with('"') && s.ends_with('"') => {
                    writeln!(&mut f, "pub const {}: &str = {};", key, value);
                }
                _ => {
                    if let Ok(n) = u32::from_str(value) {
                        writeln!(&mut f, "pub const {}: u32 = {};", key, n);
                    } else {
                        writeln!(&mut f, "// pub const {}: _ = {};", key, value);
                    }
                }
            }
        }
    }
}

#[cfg(feature = "gen")]
fn gen_rte_binding(rte_sdk_dir: &Path, dest_path: &Path) {
    let rte_header = "src/rte.h";

    info!("generating RTE binding file base on \"{}\"", rte_header);

    let rte_sdk_inc_dir = rte_sdk_dir.join("include");
    let cflags = vec!["-march=native", "-I", rte_sdk_inc_dir.to_str().unwrap()];

    bindgen::Builder::default()
        .header(rte_header)
        .generate_comments(true)
        .derive_copy(true)
        .derive_debug(true)
        .derive_default(true)
        .derive_partialeq(true)
        .default_enum_style(bindgen::EnumVariation::ModuleConsts)
        .clang_args(
            cflags
                .into_iter()
                .map(|s| s.to_owned())
                .chain(gen_cpu_features()),
        ).rustfmt_bindings(true)
        .time_phases(true)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(dest_path)
        .expect("Couldn't write bindings!");
}

#[cfg(feature = "gen")]
fn gen_cpu_features() -> impl Iterator<Item = String> {
    use std::iter;

    let mut cflags = vec![];
    let mut compile_time_cpuflags = vec![];

    let cpuid = raw_cpuid::CpuId::new();

    if let Some(features) = cpuid.get_feature_info() {
        if features.has_sse() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_SSE");
            compile_time_cpuflags.push("RTE_CPUFLAG_SSE");
        }
        if features.has_sse2() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_SSE2");
            compile_time_cpuflags.push("RTE_CPUFLAG_SSE2");
        }
        if features.has_sse3() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_SSE3");
            compile_time_cpuflags.push("RTE_CPUFLAG_SSE3");
        }
        if features.has_ssse3() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_SSSE3");
            compile_time_cpuflags.push("RTE_CPUFLAG_SSSE3");
        }
        if features.has_sse41() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_SSE4_1");
            compile_time_cpuflags.push("RTE_CPUFLAG_SSE4_1");
        }
        if features.has_sse42() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_SSE4_2");
            compile_time_cpuflags.push("RTE_CPUFLAG_SSE4_2");
        }
        if features.has_aesni() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_AES");
            compile_time_cpuflags.push("RTE_CPUFLAG_AES");
        }
        if features.has_pclmulqdq() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_PCLMULQDQ");
            compile_time_cpuflags.push("RTE_CPUFLAG_PCLMULQDQ");
        }
        if features.has_avx() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_AVX");
            compile_time_cpuflags.push("RTE_CPUFLAG_AVX");
        }
        if features.has_rdrand() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_RDRAND");
        }
        if features.has_f16c() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_F16C");
        }
    }

    if let Some(features) = cpuid.get_extended_feature_info() {
        if features.has_fsgsbase() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_FSGSBASE");
        }
        if features.has_avx2() {
            cflags.push("-DRTE_MACHINE_CPUFLAG_AVX2");
            compile_time_cpuflags.push("RTE_CPUFLAG_AVX2");
        }
        if features.has_avx512f() {
            cflags.push("-RTE_MACHINE_CPUFLAG_AVX512F");
            compile_time_cpuflags.push("RTE_CPUFLAG_AVX512F");
        }
    }

    cflags
        .into_iter()
        .map(|s| s.to_owned())
        .chain(iter::once(format!(
            "-DRTE_COMPILE_TIME_CPUFLAGS={}",
            itertools::join(compile_time_cpuflags, ",")
        )))
}

#[cfg(not(feature = "gen"))]
fn gen_rte_binding(_rte_sdk_dir: &Path, dest_path: &Path) {
    use std::fs;

    info!("coping RTE binding file");

    fs::copy("src/raw.rs", dest_path).expect("copy binding file");
}

pub const MACHINE: &str = "native";
pub const TOOLCHAIN: &str = "gcc";

lazy_static! {
    static ref RTE_SDK: PathBuf = env::var("RTE_SDK")
        .expect("RTE_SDK - Points to the DPDK installation directory.")
        .into();
    static ref RTE_ARCH: String = env::var("RTE_ARCH").unwrap_or(ARCH.to_owned());
    static ref RTE_MACHINE: String = env::var("RTE_MACHINE").unwrap_or(MACHINE.to_owned());
    static ref RTE_OS: String = env::var("RTE_OS").unwrap_or(OS.to_owned());
    static ref RTE_TOOLCHAIN: String = env::var("RTE_TOOLCHAIN").unwrap_or(TOOLCHAIN.to_owned());
    static ref RTE_TARGET: String = env::var("RTE_TARGET").unwrap_or(format!(
        "{}-{}-{}app-{}",
        *RTE_ARCH, *RTE_MACHINE, *RTE_OS, *RTE_TOOLCHAIN,
    ));
    static ref OUT_DIR: PathBuf = env::var("OUT_DIR").unwrap().into();
}

fn main() {
    pretty_env_logger::init();

    let rte_sdk_dir = RTE_SDK.join(RTE_TARGET.as_str());

    info!("using DPDK @ {:?}", rte_sdk_dir);

    if !rte_sdk_dir.exists() || !rte_sdk_dir.join("lib/libdpdk.a").exists() {
        build_dpdk(RTE_SDK.as_path(), RTE_TARGET.as_str());
    }

    gen_rte_config(&rte_sdk_dir, &OUT_DIR.join("config.rs"));

    gen_rte_binding(&rte_sdk_dir, &OUT_DIR.join("raw.rs"));
}
