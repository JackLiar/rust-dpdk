use std::env;
use std::env::consts::*;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::str::FromStr;

pub const MACHINE: &str = "native";
pub const TOOLCHAIN: &str = "gcc";

lazy_static! {
    pub static ref RTE_LIB_DIR: std::vec::Vec<std::string::String> = {
        let libdpdk = pkg_config::Config::new()
            .cargo_metadata(true)
            .env_metadata(true)
            .probe("libdpdk")
            .expect("RTE_LIBDIR - Failed to get information from libdpdk.pc");
        libdpdk.link_paths.iter().map(|p| p.to_string_lossy().to_string()).rev().collect()
    };
    pub static ref RTE_INCLUDE_DIR: std::vec::Vec<std::string::String> = {
        let libdpdk = pkg_config::Config::new()
            .cargo_metadata(true)
            .env_metadata(true)
            .probe("libdpdk")
            .expect("RTE_LIBDIR - Failed to get information from libdpdk.pc");
        libdpdk.include_paths.iter().map(|p| p.to_string_lossy().to_string()).rev().collect()
    };
    pub static ref RTE_CORE_LIBS: std::vec::Vec<std::string::String> = {
        let libdpdk = pkg_config::Config::new()
            .cargo_metadata(true)
            .env_metadata(true)
            .probe("libdpdk")
            .expect("RTE_LIBDIR - Failed to get information from libdpdk.pc");
        let mut libs = Vec::new();
        for lib in &libdpdk.libs {
            if lib.contains("pmd") {
                continue;
            }
            libs.push(lib.to_string());
        }
        return libs;
    };
    pub static ref RTE_PMD_LIBS: std::vec::Vec<std::string::String> = {
        let libdpdk = pkg_config::Config::new()
            .cargo_metadata(true)
            .env_metadata(true)
            .probe("libdpdk")
            .expect("RTE_LIBDIR - Failed to get information of libdpdk.pc");
        let mut libs = Vec::new();
        for lib in &libdpdk.libs {
            if lib.contains("pmd") {
                libs.push(lib.to_string());
            }
        }
        return libs;
    };
    // pub static ref RTE_SDK: PathBuf = env::var("RTE_SDK")
    //     .expect("RTE_SDK - Points to the DPDK installation directory.")
    //     .into();
    pub static ref RTE_ARCH: String = env::var("RTE_ARCH").unwrap_or_else(|_| ARCH.to_owned());
    pub static ref RTE_MACHINE: String = env::var("RTE_MACHINE").unwrap_or_else(|_| MACHINE.to_owned());
    pub static ref RTE_OS: String = env::var("RTE_OS").unwrap_or_else(|_| OS.to_owned());
    pub static ref RTE_TOOLCHAIN: String = env::var("RTE_TOOLCHAIN").unwrap_or_else(|_| TOOLCHAIN.to_owned());
    pub static ref RTE_TARGET: String = env::var("RTE_TARGET")
        .unwrap_or_else(|_| format!("{}-{}-{}app-{}", *RTE_ARCH, *RTE_MACHINE, *RTE_OS, *RTE_TOOLCHAIN,));
    pub static ref RTE_DEPS_LIBS: Vec<String> = vec![String::from("numa")];
}

// pub fn gen_rte_config(rte_sdk_dir: &Path, dest_path: &Path) {
//     let config_file = rte_sdk_dir.join(".config");

//     info!("generating DPDK config base on {:?}", config_file);

//     let mut f = File::create(&dest_path).unwrap();

//     writeln!(
//         &mut f,
//         "/* automatically generated by {} v{}, DON'T EDIT IT */\n",
//         env::var("CARGO_PKG_NAME").unwrap(),
//         env::var("CARGO_PKG_VERSION").unwrap(),
//     )
//     .unwrap();

//     let r = BufReader::new(File::open(&config_file).expect("RTE config file"));

//     for line in r.lines().flat_map(|line| line) {
//         if line.starts_with('#') {
//             writeln!(&mut f, "///{}", &line[1..]).unwrap();
//         } else {
//             let mut i = line.splitn(2, '=');
//             let key = i.next().expect("key");
//             let value = i.next().expect("value");

//             match value {
//                 "" => {
//                     writeln!(&mut f, "pub const {}: () = ();", key).unwrap();
//                 }
//                 "y" => {
//                     writeln!(&mut f, "pub const {}: bool = true;", key).unwrap();
//                 }
//                 "n" => {
//                     writeln!(&mut f, "pub const {}: bool = false;", key).unwrap();
//                 }
//                 s if s.starts_with('"') && s.ends_with('"') => {
//                     writeln!(&mut f, "pub const {}: &str = {};", key, value).unwrap();
//                 }
//                 _ => {
//                     if let Ok(n) = u32::from_str(value) {
//                         writeln!(&mut f, "pub const {}: u32 = {};", key, n).unwrap();
//                     } else {
//                         writeln!(&mut f, "// pub const {}: _ = {};", key, value).unwrap();
//                     }
//                 }
//             }
//         }
//     }
// }

pub fn apply_patches(rte_sdk_dir: &Path) {
    let mut patch = Command::new("patch")
        .stdin(Stdio::piped())
        .current_dir(rte_sdk_dir)
        .spawn()
        .expect("failed to apply patches");
    {
        patch
            .stdin
            .as_mut()
            .expect("Failed to open stdin")
            .write_all(include_bytes!("../patches/librte_bbdev.patch"))
            .expect("Failed to send patch");
    }
    let _ = patch.wait_with_output().expect("Failed to read stdout");
}
